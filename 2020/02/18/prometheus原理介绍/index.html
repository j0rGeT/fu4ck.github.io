<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  
  <title>Prometheus 架构和源码学习 | Saar&#39;s Blog</title>
  
  

  
  <link rel="alternate" href="/atom.xml" title="Saar's Blog">
  

  <meta name="HandheldFriendly" content="True" />
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <!-- meta -->
  

  <!-- link -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
  
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-waves@0.7.6/dist/waves.min.css">
  
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.10.1/css/all.min.css">
  

  <!--自定义看板娘-->
  <script src="https://cdn.jsdelivr.net/npm/jquery/dist/jquery.min.js"></script>
  <script src="/live2d-widget/autoload.js"></script>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome/css/font-awesome.min.css"/>

  

  
    
<link rel="stylesheet" href="/style.css">

  

  <script>
    function setLoadingBarProgress(num) {
      document.getElementById('loading-bar').style.width=num+"%";
    }
  </script>

  
  
<meta name="generator" content="Hexo 4.2.0"><link rel="alternate" href="/atom.xml" title="Saar's Blog" type="application/atom+xml">
</head>

<body>
  
  
  <div class="cover-wrapper">
    <cover class='cover post half'>
      
        
  <h1 class='title'>Saar's Blog</h1>


  <div class="m_search">
    <form name="searchform" class="form u-search-form">
      <input type="text" class="input u-search-input" placeholder="" />
      <i class="icon fas fa-search fa-fw"></i>
    </form>
  </div>

<div class='menu navgation'>
  <ul class='h-list'>
    
      
        <li>
          <a class="nav home" href="/"
            
            
            id="home">
            <i class='fas fa-rss fa-fw'></i>&nbsp;博文
          </a>
        </li>
      
    
  </ul>
</div>

      
    </cover>
    <header class="l_header material">
  <div id="loading-bar-wrapper">
    <div id="loading-bar" class="material"></div>
  </div>

	<div class='wrapper'>
		<div class="nav-main container container--flex">
      <a class="logo flat-box" href='/' >
        
          Saar's Blog
        
      </a>
			<div class='menu navgation'>
				<ul class='h-list'>
          
  					
  						<li>
								<a class="nav flat-box" href="/"
                  
                  
                  id="home">
									<i class='fas fa-grin fa-fw'></i>&nbsp;首页
								</a>
							</li>
      			
      		
				</ul>
			</div>

			
				<div class="m_search">
					<form name="searchform" class="form u-search-form">
						<input type="text" class="input u-search-input" placeholder="搜索" />
						<i class="icon fas fa-search fa-fw"></i>
					</form>
				</div>
			
			<ul class='switcher h-list'>
				
					<li class='s-search'><a class="fas fa-search fa-fw" href='javascript:void(0)'></a></li>
				
				<li class='s-menu'><a class="fas fa-bars fa-fw" href='javascript:void(0)'></a></li>
			</ul>
		</div>

		<div class='nav-sub container container--flex'>
			<a class="logo flat-box"></a>
			<ul class='switcher h-list'>
				<li class='s-comment'><a class="flat-btn fas fa-comments fa-fw" href='javascript:void(0)'></a></li>
        
          <li class='s-toc'><a class="flat-btn fas fa-list fa-fw" href='javascript:void(0)'></a></li>
        
			</ul>
		</div>
	</div>
</header>
	<aside class="menu-phone">
    <header>
		<nav class="menu navgation">
      <ul>
        
          
            <li>
							<a class="nav flat-box" href="/"
                
                
                id="home">
								<i class='fas fa-clock fa-fw'></i>&nbsp;近期文章
							</a>
            </li>
          
       
      </ul>
		</nav>
    </header>
	</aside>
<script>setLoadingBarProgress(40);</script>

  </div>


  <div class="l_body">
    <div class='body-wrapper'>
      <div class='l_main'>
  

  <article id="post" class="post white-box article-type-post" itemscope itemprop="blogPost">
    


  <section class='meta'>
    
    
    <div class="meta" id="header-meta">
      
        
  
    <h1 class="title">
      <a href="/2020/02/18/prometheus%E5%8E%9F%E7%90%86%E4%BB%8B%E7%BB%8D/">
        Prometheus 架构和源码学习
      </a>
    </h1>
  


      
      <div class='new-meta-box'>
        
          
        
          
            
  <div class='new-meta-item author'>
    
      <a href="http://www.yorzorzy.xyz" rel="nofollow">
        
          <i class="fas fa-user" aria-hidden="true"></i>
        
        <p>Saar</p>
      </a>
    
  </div>


          
        
          
            <div class="new-meta-item date">
  <a class='notlink'>
    <i class="fas fa-calendar-alt" aria-hidden="true"></i>
    <p>2020-02-18</p>
  </a>
</div>

          
        
          
            
  
  <div class='new-meta-item category'>
    <a href='/categories/prometheus/' rel="nofollow">
      <i class="fas fa-folder-open" aria-hidden="true"></i>
      <p>prometheus</p>
    </a>
  </div>


          
        
          
            
  
    <div class="new-meta-item browse busuanzi">
      <a class='notlink'>
        <i class="fas fa-eye" aria-hidden="true"></i>
        <p>
          <span id="busuanzi_value_page_pv">
            <i class="fas fa-spinner fa-spin fa-fw" aria-hidden="true"></i>
          </span>
        </p>
      </a>
    </div>
  


          
        
          
            
  

          
        
          
            

          
        
      </div>
      
        <hr>
      
    </div>
  </section>


    <section class="article typo">
      <div class="article-entry" itemprop="articleBody">
        <h1 id="Prometheus-架构和源码"><a href="#Prometheus-架构和源码" class="headerlink" title="Prometheus 架构和源码"></a>Prometheus 架构和源码</h1><h2 id="Prometheus架构"><a href="#Prometheus架构" class="headerlink" title="Prometheus架构"></a>Prometheus架构</h2><p><img src="http://www.aneasystone.com/usr/uploads/2018/10/4197609471.png" alt="architecture.png"></p>
<h2 id="构成部分"><a href="#构成部分" class="headerlink" title="构成部分"></a>构成部分</h2><p>prometheus源码分析（prometheus基于版本2.1.0和alertmanager版本0.8.0）：</p>
<ol>
<li>notifier</li>
<li>ruleManager</li>
<li>queryengine</li>
<li>web</li>
<li>discovermanager</li>
<li>scrapeManager</li>
<li>localstorage/remotestorage</li>
<li>alertManager</li>
<li>pushgateway</li>
</ol>
<p>各个组件的构成结构图：</p>
<p><img src="/images/1572413613743.png" alt="1572413613743"></p>
<h2 id="Notifier"><a href="#Notifier" class="headerlink" title="Notifier"></a>Notifier</h2><p>notifier 组件用于告警通知，在完成初始化后，notifier组件内部会构建一个告警通知队列，队列的大小由命令行参数–alertmanager.notification-queue-capacity确定，默认值为10000 ，且告警信息通过sendAlerts方法发送给AlertManager 。</p>
<p>初始化notifier组件：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">notifier               = notifier.New(&amp;cfg.notifier, log.With(logger, <span class="string">"component"</span>, <span class="string">"notifier"</span>))</span><br></pre></td></tr></table></figure>

<p>notifier将规则触发的告警信息AlertManagers服务组的过程，通知管理服务由发现AlertManager服务，注册notifier和notifier服务组成。</p>
<p>发现alertManager服务（discoveryManagerScrape）的逻辑与发现scrape服务（discoveryManagerNotify）的逻辑是一样的，</p>
<p>如果将alertmanager组件结合，那么服务发现的类型就是static_configs</p>
<p>初始化的过程中会完成对rulemanager和notifier组件的构造，同时notifier会通过sendAlerts向ruleManager回调注册。</p>
<p>启动notifier服务：</p>
<p>1.构建notifier结构实列</p>
<p>2.加载系统配置</p>
<p>3.启动notifier</p>
<p>notifier服务结构：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Notifier is responsible for dispatching alert notifications to an</span></span><br><span class="line"><span class="comment">// alert manager service.</span></span><br><span class="line"><span class="keyword">type</span> Notifier <span class="keyword">struct</span> &#123;</span><br><span class="line">	queue []*Alert</span><br><span class="line">	opts  *Options</span><br><span class="line"></span><br><span class="line">	metrics *alertMetrics</span><br><span class="line"></span><br><span class="line">	more   <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">	mtx    sync.RWMutex</span><br><span class="line">	ctx    context.Context</span><br><span class="line">	cancel <span class="function"><span class="keyword">func</span><span class="params">()</span></span></span><br><span class="line"></span><br><span class="line">	alertmanagers <span class="keyword">map</span>[<span class="keyword">string</span>]*alertmanagerSet</span><br><span class="line">	logger        log.Logger</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>notifier实列使用New方法来实现，处理逻辑：</p>
<ol>
<li>QueueCapacity的大小构建告警信息缓存队列，QueueCapacity的大小使用命令行启动参数–alertmanager.notification-queue-capacity指定</li>
<li>context协同控制notifier服务</li>
<li>注册notifier服务指标：告警缓存队列大小，告警信息长度，告警地址个书，丢弃的告警信息个数</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// New constructs a new Notifier.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(o *Options, logger log.Logger)</span> *<span class="title">Notifier</span></span> &#123;</span><br><span class="line">	ctx, cancel := context.WithCancel(context.Background())</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> o.Do == <span class="literal">nil</span> &#123;</span><br><span class="line">		o.Do = ctxhttp.Do</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> logger == <span class="literal">nil</span> &#123;</span><br><span class="line">		logger = log.NewNopLogger()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	n := &amp;Notifier&#123;</span><br><span class="line">		queue:  <span class="built_in">make</span>([]*Alert, <span class="number">0</span>, o.QueueCapacity),</span><br><span class="line">		ctx:    ctx,</span><br><span class="line">		cancel: cancel,</span><br><span class="line">		more:   <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, <span class="number">1</span>),</span><br><span class="line">		opts:   o,</span><br><span class="line">		logger: logger,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	queueLenFunc := <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">float64</span></span> &#123; <span class="keyword">return</span> <span class="keyword">float64</span>(n.queueLen()) &#125;</span><br><span class="line">	alertmanagersDiscoveredFunc := <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">float64</span></span> &#123; <span class="keyword">return</span> <span class="keyword">float64</span>(<span class="built_in">len</span>(n.Alertmanagers())) &#125;</span><br><span class="line"></span><br><span class="line">	n.metrics = newAlertMetrics(</span><br><span class="line">		o.Registerer,</span><br><span class="line">		o.QueueCapacity,</span><br><span class="line">		queueLenFunc,</span><br><span class="line">		alertmanagersDiscoveredFunc,</span><br><span class="line">	)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> n</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>newAlertMetrics是将notifier服务指标注册到prometheus系统的具体实现：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newAlertMetrics</span><span class="params">(r prometheus.Registerer, queueCap <span class="keyword">int</span>, queueLen, alertmanagersDiscovered <span class="keyword">func</span>()</span> <span class="title">float64</span>) *<span class="title">alertMetrics</span></span> &#123;</span><br><span class="line">	m := &amp;alertMetrics&#123;</span><br><span class="line">		latency: prometheus.NewSummaryVec(prometheus.SummaryOpts&#123;</span><br><span class="line">			Namespace: namespace,</span><br><span class="line">			Subsystem: subsystem,</span><br><span class="line">			Name:      <span class="string">"latency_seconds"</span>,</span><br><span class="line">			Help:      <span class="string">"Latency quantiles for sending alert notifications (not including dropped notifications)."</span>,</span><br><span class="line">		&#125;,</span><br><span class="line">			[]<span class="keyword">string</span>&#123;alertmanagerLabel&#125;,</span><br><span class="line">		),</span><br><span class="line">		errors: prometheus.NewCounterVec(prometheus.CounterOpts&#123;</span><br><span class="line">			Namespace: namespace,</span><br><span class="line">			Subsystem: subsystem,</span><br><span class="line">			Name:      <span class="string">"errors_total"</span>,</span><br><span class="line">			Help:      <span class="string">"Total number of errors sending alert notifications."</span>,</span><br><span class="line">		&#125;,</span><br><span class="line">			[]<span class="keyword">string</span>&#123;alertmanagerLabel&#125;,</span><br><span class="line">		),</span><br><span class="line">		sent: prometheus.NewCounterVec(prometheus.CounterOpts&#123;</span><br><span class="line">			Namespace: namespace,</span><br><span class="line">			Subsystem: subsystem,</span><br><span class="line">			Name:      <span class="string">"sent_total"</span>,</span><br><span class="line">			Help:      <span class="string">"Total number of alerts successfully sent."</span>,</span><br><span class="line">		&#125;,</span><br><span class="line">			[]<span class="keyword">string</span>&#123;alertmanagerLabel&#125;,</span><br><span class="line">		),</span><br><span class="line">		dropped: prometheus.NewCounter(prometheus.CounterOpts&#123;</span><br><span class="line">			Namespace: namespace,</span><br><span class="line">			Subsystem: subsystem,</span><br><span class="line">			Name:      <span class="string">"dropped_total"</span>,</span><br><span class="line">			Help:      <span class="string">"Total number of alerts dropped due to errors when sending to Alertmanager."</span>,</span><br><span class="line">		&#125;),</span><br><span class="line">		queueLength: prometheus.NewGaugeFunc(prometheus.GaugeOpts&#123;</span><br><span class="line">			Namespace: namespace,</span><br><span class="line">			Subsystem: subsystem,</span><br><span class="line">			Name:      <span class="string">"queue_length"</span>,</span><br><span class="line">			Help:      <span class="string">"The number of alert notifications in the queue."</span>,</span><br><span class="line">		&#125;, queueLen),</span><br><span class="line">		queueCapacity: prometheus.NewGauge(prometheus.GaugeOpts&#123;</span><br><span class="line">			Namespace: namespace,</span><br><span class="line">			Subsystem: subsystem,</span><br><span class="line">			Name:      <span class="string">"queue_capacity"</span>,</span><br><span class="line">			Help:      <span class="string">"The capacity of the alert notifications queue."</span>,</span><br><span class="line">		&#125;),</span><br><span class="line">		alertmanagersDiscovered: prometheus.NewGaugeFunc(prometheus.GaugeOpts&#123;</span><br><span class="line">			Name: <span class="string">"prometheus_notifications_alertmanagers_discovered"</span>,</span><br><span class="line">			Help: <span class="string">"The number of alertmanagers discovered and active."</span>,</span><br><span class="line">		&#125;, alertmanagersDiscovered),</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	m.queueCapacity.Set(<span class="keyword">float64</span>(queueCap))</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> r != <span class="literal">nil</span> &#123;</span><br><span class="line">		r.MustRegister(</span><br><span class="line">			m.latency,</span><br><span class="line">			m.errors,</span><br><span class="line">			m.sent,</span><br><span class="line">			m.dropped,</span><br><span class="line">			m.queueLength,</span><br><span class="line">			m.queueCapacity,</span><br><span class="line">			m.alertmanagersDiscovered,</span><br><span class="line">		)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> m</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>加载服务配置：</p>
<p>加载系统的配置过程，notifier服务会从prometheus.yml中获取external_labels, alert_relabel_configs和告警服务配置信息，将其保存到alertmanager中，告警触发的时候，根据external_labels,alert_relabel_configs的规则添加，重置对应的label，更具告警服务信息完成告警的信息发送。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// ApplyConfig updates the status state as the new config requires.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *Notifier)</span> <span class="title">ApplyConfig</span><span class="params">(conf *config.Config)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	n.mtx.Lock()</span><br><span class="line">	<span class="keyword">defer</span> n.mtx.Unlock()</span><br><span class="line"></span><br><span class="line">	n.opts.ExternalLabels = conf.GlobalConfig.ExternalLabels</span><br><span class="line">	n.opts.RelabelConfigs = conf.AlertingConfig.AlertRelabelConfigs</span><br><span class="line"></span><br><span class="line">	amSets := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]*alertmanagerSet)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> _, cfg := <span class="keyword">range</span> conf.AlertingConfig.AlertmanagerConfigs &#123;</span><br><span class="line">		ams, err := newAlertmanagerSet(cfg, n.logger)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		ams.metrics = n.metrics</span><br><span class="line"></span><br><span class="line">		<span class="comment">// The config hash is used for the map lookup identifier.</span></span><br><span class="line">		b, err := json.Marshal(cfg)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">		amSets[fmt.Sprintf(<span class="string">"%x"</span>, md5.Sum(b))] = ams</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	n.alertmanagers = amSets</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>newAlertmanagerSet方法会根据告警服务的配置信息构建alertmanagerSet结构实列，告警服务对应的ams还是初始化空列表</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// alertmanagerSet contains a set of Alertmanagers discovered via a group of service</span></span><br><span class="line"><span class="comment">// discovery definitions that have a common configuration on how alerts should be sent.</span></span><br><span class="line"><span class="keyword">type</span> alertmanagerSet <span class="keyword">struct</span> &#123;</span><br><span class="line">	cfg    *config.AlertmanagerConfig</span><br><span class="line">	client *http.Client</span><br><span class="line"></span><br><span class="line">	metrics *alertMetrics</span><br><span class="line"></span><br><span class="line">	mtx    sync.RWMutex</span><br><span class="line">	ams    []alertmanager</span><br><span class="line">	logger log.Logger</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>初始化函数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newAlertmanagerSet</span><span class="params">(cfg *config.AlertmanagerConfig, logger log.Logger)</span> <span class="params">(*alertmanagerSet, error)</span></span> &#123;</span><br><span class="line">	client, err := httputil.NewClientFromConfig(cfg.HTTPClientConfig, <span class="string">"alertmanager"</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	s := &amp;alertmanagerSet&#123;</span><br><span class="line">		client: client,</span><br><span class="line">		cfg:    cfg,</span><br><span class="line">		logger: logger,</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> s, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>启动notifier服务：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Run dispatches notifications continuously.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *Notifier)</span> <span class="title">Run</span><span class="params">(tsets &lt;-<span class="keyword">chan</span> <span class="keyword">map</span>[<span class="keyword">string</span>][]*targetgroup.Group)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> &lt;-n.ctx.Done():</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		<span class="keyword">case</span> ts := &lt;-tsets:</span><br><span class="line">			n.reload(ts)</span><br><span class="line">		<span class="keyword">case</span> &lt;-n.more:</span><br><span class="line">		&#125;</span><br><span class="line">		alerts := n.nextBatch()</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> !n.sendAll(alerts...) &#123;</span><br><span class="line">			n.metrics.dropped.Add(<span class="keyword">float64</span>(<span class="built_in">len</span>(alerts)))</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// If the queue still has items left, kick off the next iteration.</span></span><br><span class="line">		<span class="keyword">if</span> n.queueLen() &gt; <span class="number">0</span> &#123;</span><br><span class="line">			n.setMore()</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>服务收到更新信号调用reload方法，将告警服务ts放入reload方法中，更新服务目标服务信息。</p>
<p>scrape发现服务以job_name为单元，notifier发现服务以告警服务为单元，告警服务作用域所有的job_name.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *Notifier)</span> <span class="title">reload</span><span class="params">(tgs <span class="keyword">map</span>[<span class="keyword">string</span>][]*targetgroup.Group)</span></span> &#123;</span><br><span class="line">	n.mtx.Lock()</span><br><span class="line">	<span class="keyword">defer</span> n.mtx.Unlock()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> id, tgroup := <span class="keyword">range</span> tgs &#123;</span><br><span class="line">		am, ok := n.alertmanagers[id]</span><br><span class="line">		<span class="keyword">if</span> !ok &#123;</span><br><span class="line">			level.Error(n.logger).Log(<span class="string">"msg"</span>, <span class="string">"couldn't sync alert manager set"</span>, <span class="string">"err"</span>, fmt.Sprintf(<span class="string">"invalid id:%v"</span>, id))</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		am.sync(tgroup)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用sync方法，同步告警服务信息</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sync extracts a deduplicated set of Alertmanager endpoints from a list</span></span><br><span class="line"><span class="comment">// of target groups definitions.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *alertmanagerSet)</span> <span class="title">sync</span><span class="params">(tgs []*targetgroup.Group)</span></span> &#123;</span><br><span class="line">	all := []alertmanager&#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> _, tg := <span class="keyword">range</span> tgs &#123;</span><br><span class="line">		ams, err := alertmanagerFromGroup(tg, s.cfg)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			level.Error(s.logger).Log(<span class="string">"msg"</span>, <span class="string">"Creating discovered Alertmanagers failed"</span>, <span class="string">"err"</span>, err)</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		all = <span class="built_in">append</span>(all, ams...)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	s.mtx.Lock()</span><br><span class="line">	<span class="keyword">defer</span> s.mtx.Unlock()</span><br><span class="line">	<span class="comment">// Set new Alertmanagers and deduplicate them along their unique URL.</span></span><br><span class="line">	s.ams = []alertmanager&#123;&#125;</span><br><span class="line">	seen := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> _, am := <span class="keyword">range</span> all &#123;</span><br><span class="line">		us := am.url().String()</span><br><span class="line">		<span class="keyword">if</span> _, ok := seen[us]; ok &#123;</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// This will initialise the Counters for the AM to 0.</span></span><br><span class="line">		s.metrics.sent.WithLabelValues(us)</span><br><span class="line">		s.metrics.errors.WithLabelValues(us)</span><br><span class="line">		<span class="comment">//根据URL地址构建唯一键值，</span></span><br><span class="line">		seen[us] = <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">        <span class="comment">//保存alertmanager</span></span><br><span class="line">		s.ams = <span class="built_in">append</span>(s.ams, am)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>alertmanagerFromGroup 方法中将对告警信息的label 进行整理，包括<strong>address</strong>, <strong>alerts_path</strong> 和 <strong>scheme</strong>，每个实列的内容都为告警服务的URL地址。</p>
<p>sendAll方法，发送告警到所有配置的alertmanagers，当至少一个alertmanager成功，返回成功。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sendAll sends the alerts to all configured Alertmanagers concurrently.</span></span><br><span class="line"><span class="comment">// It returns true if the alerts could be sent successfully to at least one Alertmanager.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *Notifier)</span> <span class="title">sendAll</span><span class="params">(alerts ...*Alert)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	begin := time.Now()</span><br><span class="line"></span><br><span class="line">	b, err := json.Marshal(alerts)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		level.Error(n.logger).Log(<span class="string">"msg"</span>, <span class="string">"Encoding alerts failed"</span>, <span class="string">"err"</span>, err)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	n.mtx.RLock()</span><br><span class="line">	amSets := n.alertmanagers</span><br><span class="line">	n.mtx.RUnlock()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> (</span><br><span class="line">		wg         sync.WaitGroup</span><br><span class="line">		numSuccess <span class="keyword">uint64</span></span><br><span class="line">	)</span><br><span class="line">	<span class="keyword">for</span> _, ams := <span class="keyword">range</span> amSets &#123;</span><br><span class="line">		ams.mtx.RLock()</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> _, am := <span class="keyword">range</span> ams.ams &#123;</span><br><span class="line">			wg.Add(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">			ctx, cancel := context.WithTimeout(n.ctx, ams.cfg.Timeout)</span><br><span class="line">			<span class="keyword">defer</span> cancel()</span><br><span class="line"></span><br><span class="line">			<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(ams *alertmanagerSet, am alertmanager)</span></span> &#123;</span><br><span class="line">				u := am.url().String()</span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span> err := n.sendOne(ctx, ams.client, u, b); err != <span class="literal">nil</span> &#123;</span><br><span class="line">					level.Error(n.logger).Log(<span class="string">"alertmanager"</span>, u, <span class="string">"count"</span>, <span class="built_in">len</span>(alerts), <span class="string">"msg"</span>, <span class="string">"Error sending alert"</span>, <span class="string">"err"</span>, err)</span><br><span class="line">					n.metrics.errors.WithLabelValues(u).Inc()</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					atomic.AddUint64(&amp;numSuccess, <span class="number">1</span>)</span><br><span class="line">				&#125;</span><br><span class="line">				n.metrics.latency.WithLabelValues(u).Observe(time.Since(begin).Seconds())</span><br><span class="line">				n.metrics.sent.WithLabelValues(u).Add(<span class="keyword">float64</span>(<span class="built_in">len</span>(alerts)))</span><br><span class="line"></span><br><span class="line">				wg.Done()</span><br><span class="line">			&#125;(ams, am)</span><br><span class="line">		&#125;</span><br><span class="line">		ams.mtx.RUnlock()</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//发送告警同步等待</span></span><br><span class="line">	wg.Wait()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> numSuccess &gt; <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用sendOne发送告警信息，使用http请求的方式发送告警信息</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *Notifier)</span> <span class="title">sendOne</span><span class="params">(ctx context.Context, c *http.Client, url <span class="keyword">string</span>, b []<span class="keyword">byte</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	req, err := http.NewRequest(<span class="string">"POST"</span>, url, bytes.NewReader(b))</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	req.Header.Set(<span class="string">"Content-Type"</span>, contentTypeJSON)</span><br><span class="line">	resp, err := n.opts.Do(ctx, c, req)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> resp.Body.Close()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Any HTTP status 2xx is OK.</span></span><br><span class="line">	<span class="keyword">if</span> resp.StatusCode/<span class="number">100</span> != <span class="number">2</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">"bad response status %v"</span>, resp.Status)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>notifier流程：</p>
<p><img src="/images/1572404957636.png" alt="1572404957636"></p>
<p>注册notifier:</p>
<p>初始化过程中将notifier服务注册到rulemanager中，规则运算过程中触发告警，会调用注册的sendAlerts方法完成告警信息发送。</p>
<p>告警状态分为三种：StateInactive（告警活动状态），StatePending (告警待定状态)，StateFiring(告警激活状态)。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sendAlerts implements a the rules.NotifyFunc for a Notifier.</span></span><br><span class="line"><span class="comment">// It filters any non-firing alerts from the input.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sendAlerts</span><span class="params">(n *notifier.Notifier, externalURL <span class="keyword">string</span>)</span> <span class="title">rules</span>.<span class="title">NotifyFunc</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context, expr <span class="keyword">string</span>, alerts ...*rules.Alert)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">		<span class="keyword">var</span> res []*notifier.Alert</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> _, alert := <span class="keyword">range</span> alerts &#123;</span><br><span class="line">			<span class="comment">// Only send actually firing alerts.</span></span><br><span class="line">			<span class="keyword">if</span> alert.State == rules.StatePending &#123;</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125;</span><br><span class="line">			a := &amp;notifier.Alert&#123;</span><br><span class="line">				StartsAt:     alert.FiredAt,</span><br><span class="line">				Labels:       alert.Labels,</span><br><span class="line">				Annotations:  alert.Annotations,</span><br><span class="line">				GeneratorURL: externalURL + strutil.TableLinkForExpression(expr),</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> !alert.ResolvedAt.IsZero() &#123;</span><br><span class="line">				a.EndsAt = alert.ResolvedAt</span><br><span class="line">			&#125;</span><br><span class="line">			res = <span class="built_in">append</span>(res, a)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(alerts) &gt; <span class="number">0</span> &#123;</span><br><span class="line">			n.Send(res...)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>告警信息alerts通过notifier.Send方法添加到告警队列中，在添加之前需要对告警信息的label进行扩展和重置。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Send queues the given notification requests for processing.</span></span><br><span class="line"><span class="comment">// Panics if called on a handler that is not running.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *Notifier)</span> <span class="title">Send</span><span class="params">(alerts ...*Alert)</span></span> &#123;</span><br><span class="line">	n.mtx.Lock()</span><br><span class="line">	<span class="keyword">defer</span> n.mtx.Unlock()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Attach external labels before relabelling and sending.</span></span><br><span class="line">	<span class="keyword">for</span> _, a := <span class="keyword">range</span> alerts &#123;</span><br><span class="line">		lb := labels.NewBuilder(a.Labels)</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> ln, lv := <span class="keyword">range</span> n.opts.ExternalLabels &#123;</span><br><span class="line">			<span class="keyword">if</span> a.Labels.Get(<span class="keyword">string</span>(ln)) == <span class="string">""</span> &#123;</span><br><span class="line">				lb.Set(<span class="keyword">string</span>(ln), <span class="keyword">string</span>(lv))</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		a.Labels = lb.Labels()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	alerts = n.relabelAlerts(alerts)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Queue capacity should be significantly larger than a single alert</span></span><br><span class="line">	<span class="comment">// batch could be.</span></span><br><span class="line">	<span class="keyword">if</span> d := <span class="built_in">len</span>(alerts) - n.opts.QueueCapacity; d &gt; <span class="number">0</span> &#123;</span><br><span class="line">		alerts = alerts[d:]</span><br><span class="line"></span><br><span class="line">		level.Warn(n.logger).Log(<span class="string">"msg"</span>, <span class="string">"Alert batch larger than queue capacity, dropping alerts"</span>, <span class="string">"num_dropped"</span>, d)</span><br><span class="line">		n.metrics.dropped.Add(<span class="keyword">float64</span>(d))</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// If the queue is full, remove the oldest alerts in favor</span></span><br><span class="line">	<span class="comment">// of newer ones.</span></span><br><span class="line">	<span class="keyword">if</span> d := (<span class="built_in">len</span>(n.queue) + <span class="built_in">len</span>(alerts)) - n.opts.QueueCapacity; d &gt; <span class="number">0</span> &#123;</span><br><span class="line">		n.queue = n.queue[d:]</span><br><span class="line"></span><br><span class="line">		level.Warn(n.logger).Log(<span class="string">"msg"</span>, <span class="string">"Alert notification queue full, dropping alerts"</span>, <span class="string">"num_dropped"</span>, d)</span><br><span class="line">		n.metrics.dropped.Add(<span class="keyword">float64</span>(d))</span><br><span class="line">	&#125;</span><br><span class="line">	n.queue = <span class="built_in">append</span>(n.queue, alerts...)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Notify sending goroutine that there are alerts to be processed.</span></span><br><span class="line">	n.setMore()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主要的流程图：</p>
<p><img src="/images/1572406923577.png" alt="1572406923577"></p>
<h2 id="RuleManager"><a href="#RuleManager" class="headerlink" title="RuleManager"></a>RuleManager</h2><p>ruleManager在prometheus初始化阶段调用rules.NewManager方法完成构建，ruleManager为Manager类型：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The Manager manages recording and alerting rules.</span></span><br><span class="line"><span class="keyword">type</span> Manager <span class="keyword">struct</span> &#123;</span><br><span class="line">	opts   *ManagerOptions</span><br><span class="line">	groups <span class="keyword">map</span>[<span class="keyword">string</span>]*Group</span><br><span class="line">	mtx    sync.RWMutex</span><br><span class="line">	block  <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">	logger log.Logger</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>groups为map[string]*Group类型，key为规则组名，Group为具体的规则信息。</p>
<p>Group结构定义如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Group is a set of rules that have a logical relation.</span></span><br><span class="line"><span class="keyword">type</span> Group <span class="keyword">struct</span> &#123;</span><br><span class="line">	name                 <span class="keyword">string</span></span><br><span class="line">	file                 <span class="keyword">string</span></span><br><span class="line">	interval             time.Duration</span><br><span class="line">	rules                []Rule</span><br><span class="line">	seriesInPreviousEval []<span class="keyword">map</span>[<span class="keyword">string</span>]labels.Labels <span class="comment">// One per Rule.</span></span><br><span class="line">	opts                 *ManagerOptions</span><br><span class="line">	evaluationTime       time.Duration</span><br><span class="line">	mtx                  sync.Mutex</span><br><span class="line"></span><br><span class="line">	done       <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">	terminated <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">	logger log.Logger</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>更新规则：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Update the rule manager's state as the config requires. If</span></span><br><span class="line"><span class="comment">// loading the new rules failed the old rule set is restored.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Manager)</span> <span class="title">Update</span><span class="params">(interval time.Duration, files []<span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	m.mtx.Lock()</span><br><span class="line">	<span class="keyword">defer</span> m.mtx.Unlock()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// To be replaced with a configurable per-group interval.</span></span><br><span class="line">	groups, errs := m.loadGroups(interval, files...)</span><br><span class="line">	<span class="keyword">if</span> errs != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">for</span> _, e := <span class="keyword">range</span> errs &#123;</span><br><span class="line">			level.Error(m.logger).Log(<span class="string">"msg"</span>, <span class="string">"loading groups failed"</span>, <span class="string">"err"</span>, e)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> errors.New(<span class="string">"error loading rules, previous rule set restored"</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> _, newg := <span class="keyword">range</span> groups &#123;</span><br><span class="line">		wg.Add(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">		<span class="comment">// If there is an old group with the same identifier, stop it and wait for</span></span><br><span class="line">		<span class="comment">// it to finish the current iteration. Then copy it into the new group.</span></span><br><span class="line">		gn := groupKey(newg.name, newg.file)</span><br><span class="line">		oldg, ok := m.groups[gn]</span><br><span class="line">		<span class="built_in">delete</span>(m.groups, gn)</span><br><span class="line"></span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(newg *Group)</span></span> &#123;</span><br><span class="line">			<span class="keyword">if</span> ok &#123;</span><br><span class="line">				oldg.stop()</span><br><span class="line">				newg.copyState(oldg)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">				<span class="comment">// Wait with starting evaluation until the rule manager</span></span><br><span class="line">				<span class="comment">// is told to run. This is necessary to avoid running</span></span><br><span class="line">				<span class="comment">// queries against a bootstrapping storage.</span></span><br><span class="line">				&lt;-m.block</span><br><span class="line">				newg.run(m.opts.Context)</span><br><span class="line">			&#125;()</span><br><span class="line">			wg.Done()</span><br><span class="line">		&#125;(newg)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Stop remaining old groups.</span></span><br><span class="line">	<span class="keyword">for</span> _, oldg := <span class="keyword">range</span> m.groups &#123;</span><br><span class="line">		oldg.stop()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	wg.Wait()</span><br><span class="line">	m.groups = groups</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 规则组状态复制Group.copyState指从源规则组中，将与目标规则组相同规则名称下的指标赋值给对应的目标规则，将源规则组处于活跃状态下的指标赋值到目标规则组的活跃区域。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// copyState copies the alerting rule and staleness related state from the given group.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Rules are matched based on their name. If there are duplicates, the</span></span><br><span class="line"><span class="comment">// first is matched with the first, second with the second etc.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *Group)</span> <span class="title">copyState</span><span class="params">(from *Group)</span></span> &#123;</span><br><span class="line">	g.evaluationTime = from.evaluationTime</span><br><span class="line"></span><br><span class="line">	ruleMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>][]<span class="keyword">int</span>, <span class="built_in">len</span>(from.rules))</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> fi, fromRule := <span class="keyword">range</span> from.rules &#123;</span><br><span class="line">		l, _ := ruleMap[fromRule.Name()]</span><br><span class="line">		ruleMap[fromRule.Name()] = <span class="built_in">append</span>(l, fi)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i, rule := <span class="keyword">range</span> g.rules &#123;</span><br><span class="line">		indexes, _ := ruleMap[rule.Name()]</span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(indexes) == <span class="number">0</span> &#123;</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		fi := indexes[<span class="number">0</span>]</span><br><span class="line">		g.seriesInPreviousEval[i] = from.seriesInPreviousEval[fi]</span><br><span class="line">		ruleMap[rule.Name()] = indexes[<span class="number">1</span>:]</span><br><span class="line"></span><br><span class="line">		ar, ok := rule.(*AlertingRule)</span><br><span class="line">		<span class="keyword">if</span> !ok &#123;</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		far, ok := from.rules[fi].(*AlertingRule)</span><br><span class="line">		<span class="keyword">if</span> !ok &#123;</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> fp, a := <span class="keyword">range</span> far.active &#123;</span><br><span class="line">			ar.active[fp] = a</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>规则组启动流程：进入 run  方法后先进行初始化等待，以使得规则运算的时间间隔interval对齐。定义规则运算调度方法iter, 调度收起interval指定；iter方法中调用eval方法。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *Group)</span> <span class="title">run</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> <span class="built_in">close</span>(g.terminated)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Wait an initial amount to have consistently slotted intervals.</span></span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> &lt;-time.After(g.offset()):</span><br><span class="line">	<span class="keyword">case</span> &lt;-g.done:</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	iter := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		iterationsScheduled.Inc()</span><br><span class="line"></span><br><span class="line">		start := time.Now()</span><br><span class="line">		g.Eval(ctx, start)</span><br><span class="line"></span><br><span class="line">		iterationDuration.Observe(time.Since(start).Seconds())</span><br><span class="line">		g.SetEvaluationTime(time.Since(start))</span><br><span class="line">	&#125;</span><br><span class="line">	lastTriggered := time.Now()</span><br><span class="line">	iter()</span><br><span class="line"></span><br><span class="line">	tick := time.NewTicker(g.interval)</span><br><span class="line">	<span class="keyword">defer</span> tick.Stop()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> &lt;-g.done:</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			<span class="keyword">select</span> &#123;</span><br><span class="line">			<span class="keyword">case</span> &lt;-g.done:</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			<span class="keyword">case</span> &lt;-tick.C:</span><br><span class="line">				missed := (time.Since(lastTriggered).Nanoseconds() / g.interval.Nanoseconds()) - <span class="number">1</span></span><br><span class="line">				<span class="keyword">if</span> missed &gt; <span class="number">0</span> &#123;</span><br><span class="line">					iterationsMissed.Add(<span class="keyword">float64</span>(missed))</span><br><span class="line">					iterationsScheduled.Add(<span class="keyword">float64</span>(missed))</span><br><span class="line">				&#125;</span><br><span class="line">				lastTriggered = time.Now()</span><br><span class="line">				iter()</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>规则组的调度在Eval中实现，Eval方法会将规则组中的每个规则一次放到queryEngine中执行，如果呗执行的规则是AlertingRule类型，执行后结果指标会通过notifier组件发送给告警服务，最后将结果指标存储到prometheus的存储管理器，并对过期指标进行存储标记处理。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Eval runs a single evaluation cycle in which all rules are evaluated sequentially.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *Group)</span> <span class="title">Eval</span><span class="params">(ctx context.Context, ts time.Time)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i, rule := <span class="keyword">range</span> g.rules &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> &lt;-g.done:</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>, rule Rule)</span></span> &#123;</span><br><span class="line">			<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">(t time.Time)</span></span> &#123;</span><br><span class="line">				evalDuration.Observe(time.Since(t).Seconds())</span><br><span class="line">				rule.SetEvaluationTime(time.Since(t))</span><br><span class="line">			&#125;(time.Now())</span><br><span class="line"></span><br><span class="line">			evalTotal.Inc()</span><br><span class="line"></span><br><span class="line">			vector, err := rule.Eval(ctx, ts, g.opts.QueryFunc, g.opts.ExternalURL)</span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="comment">// Canceled queries are intentional termination of queries. This normally</span></span><br><span class="line">				<span class="comment">// happens on shutdown and thus we skip logging of any errors here.</span></span><br><span class="line">				<span class="keyword">if</span> _, ok := err.(promql.ErrQueryCanceled); !ok &#123;</span><br><span class="line">					level.Warn(g.logger).Log(<span class="string">"msg"</span>, <span class="string">"Evaluating rule failed"</span>, <span class="string">"rule"</span>, rule, <span class="string">"err"</span>, err)</span><br><span class="line">				&#125;</span><br><span class="line">				evalFailures.Inc()</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> ar, ok := rule.(*AlertingRule); ok &#123;</span><br><span class="line">				g.opts.NotifyFunc(ctx, ar.vector.String(), ar.currentAlerts()...)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">var</span> (</span><br><span class="line">				numOutOfOrder = <span class="number">0</span></span><br><span class="line">				numDuplicates = <span class="number">0</span></span><br><span class="line">			)</span><br><span class="line"></span><br><span class="line">			app, err := g.opts.Appendable.Appender()</span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				level.Warn(g.logger).Log(<span class="string">"msg"</span>, <span class="string">"creating appender failed"</span>, <span class="string">"err"</span>, err)</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			seriesReturned := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]labels.Labels, <span class="built_in">len</span>(g.seriesInPreviousEval[i]))</span><br><span class="line">			<span class="keyword">for</span> _, s := <span class="keyword">range</span> vector &#123;</span><br><span class="line">				<span class="keyword">if</span> _, err := app.Add(s.Metric, s.T, s.V); err != <span class="literal">nil</span> &#123;</span><br><span class="line">					<span class="keyword">switch</span> err &#123;</span><br><span class="line">					<span class="keyword">case</span> storage.ErrOutOfOrderSample:</span><br><span class="line">						numOutOfOrder++</span><br><span class="line">						level.Debug(g.logger).Log(<span class="string">"msg"</span>, <span class="string">"Rule evaluation result discarded"</span>, <span class="string">"err"</span>, err, <span class="string">"sample"</span>, s)</span><br><span class="line">					<span class="keyword">case</span> storage.ErrDuplicateSampleForTimestamp:</span><br><span class="line">						numDuplicates++</span><br><span class="line">						level.Debug(g.logger).Log(<span class="string">"msg"</span>, <span class="string">"Rule evaluation result discarded"</span>, <span class="string">"err"</span>, err, <span class="string">"sample"</span>, s)</span><br><span class="line">					<span class="keyword">default</span>:</span><br><span class="line">						level.Warn(g.logger).Log(<span class="string">"msg"</span>, <span class="string">"Rule evaluation result discarded"</span>, <span class="string">"err"</span>, err, <span class="string">"sample"</span>, s)</span><br><span class="line">					&#125;</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					seriesReturned[s.Metric.String()] = s.Metric</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> numOutOfOrder &gt; <span class="number">0</span> &#123;</span><br><span class="line">				level.Warn(g.logger).Log(<span class="string">"msg"</span>, <span class="string">"Error on ingesting out-of-order result from rule evaluation"</span>, <span class="string">"numDropped"</span>, numOutOfOrder)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> numDuplicates &gt; <span class="number">0</span> &#123;</span><br><span class="line">				level.Warn(g.logger).Log(<span class="string">"msg"</span>, <span class="string">"Error on ingesting results from rule evaluation with different value but same timestamp"</span>, <span class="string">"numDropped"</span>, numDuplicates)</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">for</span> metric, lset := <span class="keyword">range</span> g.seriesInPreviousEval[i] &#123;</span><br><span class="line">				<span class="keyword">if</span> _, ok := seriesReturned[metric]; !ok &#123;</span><br><span class="line">					<span class="comment">// Series no longer exposed, mark it stale.</span></span><br><span class="line">					_, err = app.Add(lset, timestamp.FromTime(ts), math.Float64frombits(value.StaleNaN))</span><br><span class="line">					<span class="keyword">switch</span> err &#123;</span><br><span class="line">					<span class="keyword">case</span> <span class="literal">nil</span>:</span><br><span class="line">					<span class="keyword">case</span> storage.ErrOutOfOrderSample, storage.ErrDuplicateSampleForTimestamp:</span><br><span class="line">						<span class="comment">// Do not count these in logging, as this is expected if series</span></span><br><span class="line">						<span class="comment">// is exposed from a different rule.</span></span><br><span class="line">					<span class="keyword">default</span>:</span><br><span class="line">						level.Warn(g.logger).Log(<span class="string">"msg"</span>, <span class="string">"adding stale sample failed"</span>, <span class="string">"sample"</span>, metric, <span class="string">"err"</span>, err)</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> err := app.Commit(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">				level.Warn(g.logger).Log(<span class="string">"msg"</span>, <span class="string">"rule sample appending failed"</span>, <span class="string">"err"</span>, err)</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				g.seriesInPreviousEval[i] = seriesReturned</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;(i, rule)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>规则调度的流程：</p>
<p><img src="/images/1572412222861.png" alt="1572412222861"></p>
<h2 id="QueryEngine"><a href="#QueryEngine" class="headerlink" title="QueryEngine"></a>QueryEngine</h2><p>queryengine是核心模块，规则分为告警规则和记录规则，告警规则会产生告警信息，通过通知组件发送给告警服务，告警规则的计算表达式可以引用记录规则。</p>
<p>Rule接口：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A Rule encapsulates a vector expression which is evaluated at a specified</span></span><br><span class="line"><span class="comment">// interval and acted upon (currently either recorded or used for alerting).</span></span><br><span class="line"><span class="keyword">type</span> Rule <span class="keyword">interface</span> &#123;</span><br><span class="line">	Name() <span class="keyword">string</span></span><br><span class="line">	<span class="comment">// eval evaluates the rule, including any associated recording or alerting actions.</span></span><br><span class="line">	Eval(context.Context, time.Time, QueryFunc, *url.URL) (promql.Vector, error)</span><br><span class="line">	<span class="comment">// String returns a human-readable string representation of the rule.</span></span><br><span class="line">	String() <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line">	SetEvaluationTime(time.Duration)</span><br><span class="line">	GetEvaluationTime() time.Duration</span><br><span class="line">	<span class="comment">// HTMLSnippet returns a human-readable string representation of the rule,</span></span><br><span class="line">	<span class="comment">// decorated with HTML elements for use the web frontend.</span></span><br><span class="line">	HTMLSnippet(pathPrefix <span class="keyword">string</span>) html_template.HTML</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>两种规则都是通过实现Rule接口中的Eval方法来完成。</p>
<p>1）告警状态为StatePending时候，告警持续时间必须大于等于告警规则所配置的持续时间。</p>
<p>2）告警状态为StateFiring</p>
<p>告警规则和记录规则Eval方法的实现代码路径为rules/alerting和reording.go</p>
<p>查询引擎通过EngineQueryFunc方法完成了在RuleManager中的注册。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// QueryFunc processes PromQL queries.</span></span><br><span class="line"><span class="keyword">type</span> QueryFunc <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context, q <span class="keyword">string</span>, t time.Time)</span> <span class="params">(promql.Vector, error)</span></span></span><br></pre></td></tr></table></figure>

<p>规则在查询引擎中运算之前，需要调用Engine.NewInstantQuery方法初始化，完成对规则的解析和对查询器的构建。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NewInstantQuery returns an evaluation query for the given expression at the given time.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ng *Engine)</span> <span class="title">NewInstantQuery</span><span class="params">(qs <span class="keyword">string</span>, ts time.Time)</span> <span class="params">(Query, error)</span></span> &#123;</span><br><span class="line">	expr, err := ParseExpr(qs)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	qry := ng.newQuery(expr, ts, ts, <span class="number">0</span>)</span><br><span class="line">	qry.q = qs</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> qry, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>规则允许的调用链为:</p>
<p>query.Exec-&gt;Engine.exec-&gt;Engine.execEvalStmt-&gt;evaluator.eval。最为关键的部分在evaluator.eval方法中实现。</p>
<p>支持的表达式类型：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">AggregateExpr</span><br><span class="line">BinaryExpr</span><br><span class="line">Call</span><br><span class="line">MatrixSelector</span><br><span class="line">NumberLiteral</span><br><span class="line">ParenExpr</span><br><span class="line">StringLiteral</span><br><span class="line">UnaryExpr</span><br><span class="line">VectorSelector</span><br></pre></td></tr></table></figure>

<p>enginequery模块主要代码在promql目录下；</p>
<p>ast.go定义查询引擎中常用的结构</p>
<p>engine.go具体实现</p>
<p>functions.go实现查询引擎的内置方法</p>
<p>fuzz.go，parse.go实现两种各不同的表达式解析器</p>
<p>printer.go, quantile.go, value.go 查询引擎的公共基础方法</p>
<p>BinaryExpr运算：</p>
<p><img src="/images/1572413062094.png" alt="1572413062094"></p>
<p>时间窗口规则运算：</p>
<p><img src="/images/1572413083570.png" alt="1572413083570"></p>
<p>规则计算和指标查询：</p>
<p>查询引擎在规则运算过程中，先对规则进行解析，然后解析后的规则转换成为对应类型的表达式，最后根据转换后的表达式和数据完成规则计算。</p>
<p>查询引擎是通过调用读写代理器fanoutStorage中的Querier方法获取指标数据的。 Querier方法的主要参数为指标名称，开始时间和结束时间。</p>
<p>加入指标查询后的规则运算调用链为： query.Exec=&gt;Engine.Exec=&gt;Engine.execEvalStat=&gt;Engine.populateIterators=&gt;Engine.queryable.Querier=&gt;evaluator.eval</p>
<h2 id="Web"><a href="#Web" class="headerlink" title="Web"></a>Web</h2><p>web组件引用了localStorage组件，fanoutStorage组件，scrapeManager组件，ruleManager组件和notifier组件，对外提供http服务。</p>
<p>prometheus server服务的handler的数据结构如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Handler serves various HTTP endpoints of the Prometheus server</span></span><br><span class="line"><span class="keyword">type</span> Handler <span class="keyword">struct</span> &#123;</span><br><span class="line">	logger log.Logger</span><br><span class="line"></span><br><span class="line">	scrapeManager *retrieval.ScrapeManager</span><br><span class="line">	ruleManager   *rules.Manager</span><br><span class="line">	queryEngine   *promql.Engine</span><br><span class="line">	context       context.Context</span><br><span class="line">	tsdb          <span class="function"><span class="keyword">func</span><span class="params">()</span> *<span class="title">tsdb</span>.<span class="title">DB</span></span></span><br><span class="line">	storage       storage.Storage</span><br><span class="line">	notifier      *notifier.Notifier</span><br><span class="line"></span><br><span class="line">	apiV1 *api_v1.API</span><br><span class="line"></span><br><span class="line">	router       *route.Router</span><br><span class="line">	quitCh       <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">	reloadCh     <span class="keyword">chan</span> <span class="keyword">chan</span> error</span><br><span class="line">	options      *Options</span><br><span class="line">	config       *config.Config</span><br><span class="line">	configString <span class="keyword">string</span></span><br><span class="line">	versionInfo  *PrometheusVersion</span><br><span class="line">	birth        time.Time</span><br><span class="line">	cwd          <span class="keyword">string</span></span><br><span class="line">	flagsMap     <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span></span><br><span class="line"></span><br><span class="line">	externalLabels model.LabelSet</span><br><span class="line">	mtx            sync.RWMutex</span><br><span class="line">	now            <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">model</span>.<span class="title">Time</span></span></span><br><span class="line"></span><br><span class="line">	ready <span class="keyword">uint32</span> <span class="comment">// ready is uint32 rather than boolean to be able to use atomic functions.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>web初始化再main中：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">webHandler := web.New(log.With(logger, <span class="string">"component"</span>, <span class="string">"web"</span>), &amp;cfg.web)</span><br></pre></td></tr></table></figure>

<p>注册api接口：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(logger log.Logger, o *Options)</span> *<span class="title">Handler</span></span> &#123;</span><br><span class="line">	router := route.New()</span><br><span class="line">	cwd, err := os.Getwd()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		cwd = <span class="string">"&lt;error retrieving current working directory&gt;"</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> logger == <span class="literal">nil</span> &#123;</span><br><span class="line">		logger = log.NewNopLogger()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	h := &amp;Handler&#123;</span><br><span class="line">		logger:      logger,</span><br><span class="line">		router:      router,</span><br><span class="line">		quitCh:      <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;),</span><br><span class="line">		reloadCh:    <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">chan</span> error),</span><br><span class="line">		options:     o,</span><br><span class="line">		versionInfo: o.Version,</span><br><span class="line">		birth:       time.Now(),</span><br><span class="line">		cwd:         cwd,</span><br><span class="line">		flagsMap:    o.Flags,</span><br><span class="line"></span><br><span class="line">		context:       o.Context,</span><br><span class="line">		scrapeManager: o.ScrapeManager,</span><br><span class="line">		ruleManager:   o.RuleManager,</span><br><span class="line">		queryEngine:   o.QueryEngine,</span><br><span class="line">		tsdb:          o.TSDB,</span><br><span class="line">		storage:       o.Storage,</span><br><span class="line">		notifier:      o.Notifier,</span><br><span class="line"></span><br><span class="line">		now: model.Now,</span><br><span class="line"></span><br><span class="line">		ready: <span class="number">0</span>,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	h.apiV1 = api_v1.NewAPI(h.queryEngine, h.storage, h.scrapeManager, h.notifier,</span><br><span class="line">		<span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">config</span>.<span class="title">Config</span></span> &#123;</span><br><span class="line">			h.mtx.RLock()</span><br><span class="line">			<span class="keyword">defer</span> h.mtx.RUnlock()</span><br><span class="line">			<span class="keyword">return</span> *h.config</span><br><span class="line">		&#125;,</span><br><span class="line">		h.testReady,</span><br><span class="line">		h.options.TSDB,</span><br><span class="line">		h.options.EnableAdminAPI,</span><br><span class="line">	)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> o.RoutePrefix != <span class="string">"/"</span> &#123;</span><br><span class="line">		<span class="comment">// If the prefix is missing for the root path, prepend it.</span></span><br><span class="line">		router.Get(<span class="string">"/"</span>, <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">			http.Redirect(w, r, o.RoutePrefix, http.StatusFound)</span><br><span class="line">		&#125;)</span><br><span class="line">		router = router.WithPrefix(o.RoutePrefix)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	instrh := prometheus.InstrumentHandler</span><br><span class="line">	instrf := prometheus.InstrumentHandlerFunc</span><br><span class="line">	readyf := h.testReady</span><br><span class="line"></span><br><span class="line">	router.Get(<span class="string">"/"</span>, <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">		http.Redirect(w, r, path.Join(o.ExternalURL.Path, <span class="string">"/graph"</span>), http.StatusFound)</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	router.Get(<span class="string">"/alerts"</span>, readyf(instrf(<span class="string">"alerts"</span>, h.alerts)))   <span class="comment">//alerts信息</span></span><br><span class="line">	router.Get(<span class="string">"/graph"</span>, readyf(instrf(<span class="string">"graph"</span>, h.graph)))      <span class="comment">//graph接口</span></span><br><span class="line">	router.Get(<span class="string">"/status"</span>, readyf(instrf(<span class="string">"status"</span>, h.status)))    <span class="comment">//status状态</span></span><br><span class="line">	router.Get(<span class="string">"/flags"</span>, readyf(instrf(<span class="string">"flags"</span>, h.flags)))</span><br><span class="line">	router.Get(<span class="string">"/config"</span>, readyf(instrf(<span class="string">"config"</span>, h.serveConfig)))</span><br><span class="line">	router.Get(<span class="string">"/rules"</span>, readyf(instrf(<span class="string">"rules"</span>, h.rules)))      <span class="comment">//rules</span></span><br><span class="line">	router.Get(<span class="string">"/targets"</span>, readyf(instrf(<span class="string">"targets"</span>, h.targets))) <span class="comment">// Bucket targets by job label</span></span><br><span class="line">	router.Get(<span class="string">"/version"</span>, readyf(instrf(<span class="string">"version"</span>, h.version)))</span><br><span class="line">	router.Get(<span class="string">"/service-discovery"</span>, readyf(instrf(<span class="string">"servicediscovery"</span>, h.serviceDiscovery)))</span><br><span class="line">	<span class="comment">//服务发现</span></span><br><span class="line">	router.Get(<span class="string">"/heap"</span>, instrf(<span class="string">"heap"</span>, h.dumpHeap))</span><br><span class="line"></span><br><span class="line">	router.Get(<span class="string">"/metrics"</span>, prometheus.Handler().ServeHTTP)</span><br><span class="line">	<span class="comment">//当前所有指标数据</span></span><br><span class="line">	router.Get(<span class="string">"/federate"</span>, readyf(instrh(<span class="string">"federate"</span>, httputil.CompressionHandler&#123;</span><br><span class="line">		Handler: http.HandlerFunc(h.federation),</span><br><span class="line">	&#125;)))</span><br><span class="line"></span><br><span class="line">	router.Get(<span class="string">"/consoles/*filepath"</span>, readyf(instrf(<span class="string">"consoles"</span>, h.consoles)))</span><br><span class="line"></span><br><span class="line">	router.Get(<span class="string">"/static/*filepath"</span>, instrf(<span class="string">"static"</span>, h.serveStaticAsset))</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> o.UserAssetsPath != <span class="string">""</span> &#123;</span><br><span class="line">		router.Get(<span class="string">"/user/*filepath"</span>, instrf(<span class="string">"user"</span>, route.FileServe(o.UserAssetsPath)))</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> o.EnableLifecycle &#123;</span><br><span class="line">		router.Post(<span class="string">"/-/quit"</span>, h.quit)</span><br><span class="line">		router.Post(<span class="string">"/-/reload"</span>, h.reload)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		router.Post(<span class="string">"/-/quit"</span>, <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, _ *http.Request)</span></span> &#123;</span><br><span class="line">			w.WriteHeader(http.StatusForbidden)</span><br><span class="line">			w.Write([]<span class="keyword">byte</span>(<span class="string">"Lifecycle APIs are not enabled"</span>))</span><br><span class="line">		&#125;)</span><br><span class="line">		router.Post(<span class="string">"/-/reload"</span>, <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, _ *http.Request)</span></span> &#123;</span><br><span class="line">			w.WriteHeader(http.StatusForbidden)</span><br><span class="line">			w.Write([]<span class="keyword">byte</span>(<span class="string">"Lifecycle APIs are not enabled"</span>))</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">	router.Get(<span class="string">"/-/quit"</span>, <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, _ *http.Request)</span></span> &#123;</span><br><span class="line">		w.WriteHeader(http.StatusMethodNotAllowed)</span><br><span class="line">		w.Write([]<span class="keyword">byte</span>(<span class="string">"Only POST requests allowed"</span>))</span><br><span class="line">	&#125;)</span><br><span class="line">	router.Get(<span class="string">"/-/reload"</span>, <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, _ *http.Request)</span></span> &#123;</span><br><span class="line">		w.WriteHeader(http.StatusMethodNotAllowed)</span><br><span class="line">		w.Write([]<span class="keyword">byte</span>(<span class="string">"Only POST requests allowed"</span>))</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	router.Get(<span class="string">"/debug/*subpath"</span>, serveDebug)</span><br><span class="line">	router.Post(<span class="string">"/debug/*subpath"</span>, serveDebug)</span><br><span class="line"></span><br><span class="line">	router.Get(<span class="string">"/-/healthy"</span>, <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">		w.WriteHeader(http.StatusOK)</span><br><span class="line">		fmt.Fprintf(w, <span class="string">"Prometheus is Healthy.\n"</span>)</span><br><span class="line">	&#125;)</span><br><span class="line">	router.Get(<span class="string">"/-/ready"</span>, readyf(<span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">		w.WriteHeader(http.StatusOK)</span><br><span class="line">		fmt.Fprintf(w, <span class="string">"Prometheus is Ready.\n"</span>)</span><br><span class="line">	&#125;))</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> h</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>reload接口调用发送信号给reloadCh，重新加载配置。web主要内容就这些。</p>
<h2 id="DiscoveryManager"><a href="#DiscoveryManager" class="headerlink" title="DiscoveryManager"></a>DiscoveryManager</h2><p>数据采集之前，prometheus需要先发现数据采集的目标服务，然后从目标服务中获取指标数据，最后将指标数据存储到prometheus存储管理器中。</p>
<p>服务发现结构配置：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// ServiceDiscoveryConfig configures lists of different service discovery mechanisms.</span></span><br><span class="line"><span class="keyword">type</span> ServiceDiscoveryConfig <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// List of labeled target groups for this job.</span></span><br><span class="line">	StaticConfigs []*targetgroup.Group <span class="string">`yaml:"static_configs,omitempty"`</span></span><br><span class="line">	<span class="comment">// List of DNS service discovery configurations.</span></span><br><span class="line">	DNSSDConfigs []*dns.SDConfig <span class="string">`yaml:"dns_sd_configs,omitempty"`</span></span><br><span class="line">	<span class="comment">// List of file service discovery configurations.</span></span><br><span class="line">	FileSDConfigs []*file.SDConfig <span class="string">`yaml:"file_sd_configs,omitempty"`</span></span><br><span class="line">	<span class="comment">// List of Consul service discovery configurations.</span></span><br><span class="line">	ConsulSDConfigs []*consul.SDConfig <span class="string">`yaml:"consul_sd_configs,omitempty"`</span></span><br><span class="line">	<span class="comment">// List of Serverset service discovery configurations.</span></span><br><span class="line">	ServersetSDConfigs []*zookeeper.ServersetSDConfig <span class="string">`yaml:"serverset_sd_configs,omitempty"`</span></span><br><span class="line">	<span class="comment">// NerveSDConfigs is a list of Nerve service discovery configurations.</span></span><br><span class="line">	NerveSDConfigs []*zookeeper.NerveSDConfig <span class="string">`yaml:"nerve_sd_configs,omitempty"`</span></span><br><span class="line">	<span class="comment">// MarathonSDConfigs is a list of Marathon service discovery configurations.</span></span><br><span class="line">	MarathonSDConfigs []*marathon.SDConfig <span class="string">`yaml:"marathon_sd_configs,omitempty"`</span></span><br><span class="line">	<span class="comment">// List of Kubernetes service discovery configurations.</span></span><br><span class="line">	KubernetesSDConfigs []*kubernetes.SDConfig <span class="string">`yaml:"kubernetes_sd_configs,omitempty"`</span></span><br><span class="line">	<span class="comment">// List of GCE service discovery configurations.</span></span><br><span class="line">	GCESDConfigs []*gce.SDConfig <span class="string">`yaml:"gce_sd_configs,omitempty"`</span></span><br><span class="line">	<span class="comment">// List of EC2 service discovery configurations.</span></span><br><span class="line">	EC2SDConfigs []*ec2.SDConfig <span class="string">`yaml:"ec2_sd_configs,omitempty"`</span></span><br><span class="line">	<span class="comment">// List of OpenStack service discovery configurations.</span></span><br><span class="line">	OpenstackSDConfigs []*openstack.SDConfig <span class="string">`yaml:"openstack_sd_configs,omitempty"`</span></span><br><span class="line">	<span class="comment">// List of Azure service discovery configurations.</span></span><br><span class="line">	AzureSDConfigs []*azure.SDConfig <span class="string">`yaml:"azure_sd_configs,omitempty"`</span></span><br><span class="line">	<span class="comment">// List of Triton service discovery configurations.</span></span><br><span class="line">	TritonSDConfigs []*triton.SDConfig <span class="string">`yaml:"triton_sd_configs,omitempty"`</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Catches all undefined fields and must be empty after parsing.</span></span><br><span class="line">	XXX <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125; <span class="string">`yaml:",inline"`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>prometheus支持以上服务，除了StaticConfigs静态服务配置，其他都是动态的服务配置。</p>
<p>对所有的服务发现，都提供一个抽象接口：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Discoverer <span class="keyword">interface</span> &#123;</span><br><span class="line">	<span class="comment">// Run hands a channel to the discovery provider(consul,dns etc) through which it can send</span></span><br><span class="line">	<span class="comment">// updated target groups.</span></span><br><span class="line">	<span class="comment">// Must returns if the context gets canceled. It should not close the update</span></span><br><span class="line">	<span class="comment">// channel on returning.</span></span><br><span class="line">	Run(ctx context.Context, up <span class="keyword">chan</span>&lt;- []*targetgroup.Group)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>prometheus将所发现的服务都转换成为了targetGroup.Group结构，通过 up发送给ScrapeManager，完成服务上线。</p>
<p>代码路径：/discovery/targetgroup/targetgroup.go</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Group is a set of targets with a common label set(production , test, staging etc.).</span></span><br><span class="line"><span class="keyword">type</span> Group <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// Targets is a list of targets identified by a label set. Each target is</span></span><br><span class="line">	<span class="comment">// uniquely identifiable in the group by its address label.</span></span><br><span class="line">	Targets []model.LabelSet</span><br><span class="line">	<span class="comment">// Labels is a set of labels that is common across all targets in the group.</span></span><br><span class="line">	Labels model.LabelSet</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Source is an identifier that describes a group of targets.</span></span><br><span class="line">	Source <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>服务发现管理者Manager是所有发现服务的入口，服务的上线，下线和更新都需要进行服务同步。</p>
<p>Manager的结构：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/ Manager maintains a set of discovery providers and sends each update to a <span class="keyword">map</span> channel.</span><br><span class="line"><span class="comment">// Targets are grouped by the target set name.</span></span><br><span class="line"><span class="keyword">type</span> Manager <span class="keyword">struct</span> &#123;</span><br><span class="line">	logger         log.Logger  <span class="comment">//系统日志记录</span></span><br><span class="line">	mtx            sync.RWMutex  <span class="comment">//同步读写锁</span></span><br><span class="line">	ctx            context.Context  <span class="comment">//协同控制</span></span><br><span class="line">	discoverCancel []context.CancelFunc <span class="comment">//服务下线调用</span></span><br><span class="line">	<span class="comment">// Some Discoverers(eg. k8s) send only the updates for a given target group</span></span><br><span class="line">	<span class="comment">// so we use map[tg.Source]*targetgroup.Group to know which group to update.</span></span><br><span class="line">    <span class="comment">//发现的目标服务</span></span><br><span class="line">	targets <span class="keyword">map</span>[poolKey]<span class="keyword">map</span>[<span class="keyword">string</span>]*targetgroup.Group</span><br><span class="line">	<span class="comment">// The sync channels sends the updates in map[targetSetName] where targetSetName is the job value from the scrape config.</span></span><br><span class="line">    <span class="comment">//将所发现的目标服务以chan的方式通知接受方</span></span><br><span class="line">	syncCh <span class="keyword">chan</span> <span class="keyword">map</span>[<span class="keyword">string</span>][]*targetgroup.Group</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在初始化的过程中给，构建discoveryManagerScrape，并通过调用applyConfig方法完成对Discoverer的构建。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ApplyConfig removes all running discovery providers and starts new ones using the provided config.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Manager)</span> <span class="title">ApplyConfig</span><span class="params">(cfg <span class="keyword">map</span>[<span class="keyword">string</span>]sd_config.ServiceDiscoveryConfig)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	m.mtx.Lock()</span><br><span class="line">	<span class="keyword">defer</span> m.mtx.Unlock()</span><br><span class="line"></span><br><span class="line">	m.cancelDiscoverers()</span><br><span class="line">	<span class="keyword">for</span> name, scfg := <span class="keyword">range</span> cfg &#123;</span><br><span class="line">		<span class="keyword">for</span> provName, prov := <span class="keyword">range</span> m.providersFromConfig(scfg) &#123;</span><br><span class="line">			m.startProvider(m.ctx, poolKey&#123;setName: name, provider: provName&#125;, prov)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>startProvider方法根据job_name，服务名称和具体的Discoverer实例启动所发现的scrape服务。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Manager)</span> <span class="title">providersFromConfig</span><span class="params">(cfg sd_config.ServiceDiscoveryConfig)</span> <span class="title">map</span>[<span class="title">string</span>]<span class="title">Discoverer</span></span> &#123;</span><br><span class="line">	providers := <span class="keyword">map</span>[<span class="keyword">string</span>]Discoverer&#123;&#125;</span><br><span class="line"></span><br><span class="line">	app := <span class="function"><span class="keyword">func</span><span class="params">(mech <span class="keyword">string</span>, i <span class="keyword">int</span>, tp Discoverer)</span></span> &#123;</span><br><span class="line">		providers[fmt.Sprintf(<span class="string">"%s/%d"</span>, mech, i)] = tp</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i, c := <span class="keyword">range</span> cfg.DNSSDConfigs &#123;</span><br><span class="line">		app(<span class="string">"dns"</span>, i, dns.NewDiscovery(*c, log.With(m.logger, <span class="string">"discovery"</span>, <span class="string">"dns"</span>)))</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> i, c := <span class="keyword">range</span> cfg.FileSDConfigs &#123;</span><br><span class="line">		app(<span class="string">"file"</span>, i, file.NewDiscovery(c, log.With(m.logger, <span class="string">"discovery"</span>, <span class="string">"file"</span>)))</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> i, c := <span class="keyword">range</span> cfg.ConsulSDConfigs &#123;</span><br><span class="line">		k, err := consul.NewDiscovery(c, log.With(m.logger, <span class="string">"discovery"</span>, <span class="string">"consul"</span>))</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			level.Error(m.logger).Log(<span class="string">"msg"</span>, <span class="string">"Cannot create Consul discovery"</span>, <span class="string">"err"</span>, err)</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		app(<span class="string">"consul"</span>, i, k)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> i, c := <span class="keyword">range</span> cfg.MarathonSDConfigs &#123;</span><br><span class="line">		t, err := marathon.NewDiscovery(*c, log.With(m.logger, <span class="string">"discovery"</span>, <span class="string">"marathon"</span>))</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			level.Error(m.logger).Log(<span class="string">"msg"</span>, <span class="string">"Cannot create Marathon discovery"</span>, <span class="string">"err"</span>, err)</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		app(<span class="string">"marathon"</span>, i, t)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> i, c := <span class="keyword">range</span> cfg.KubernetesSDConfigs &#123;</span><br><span class="line">		k, err := kubernetes.New(log.With(m.logger, <span class="string">"discovery"</span>, <span class="string">"k8s"</span>), c)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			level.Error(m.logger).Log(<span class="string">"msg"</span>, <span class="string">"Cannot create Kubernetes discovery"</span>, <span class="string">"err"</span>, err)</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		app(<span class="string">"kubernetes"</span>, i, k)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> i, c := <span class="keyword">range</span> cfg.ServersetSDConfigs &#123;</span><br><span class="line">		app(<span class="string">"serverset"</span>, i, zookeeper.NewServersetDiscovery(c, log.With(m.logger, <span class="string">"discovery"</span>, <span class="string">"zookeeper"</span>)))</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> i, c := <span class="keyword">range</span> cfg.NerveSDConfigs &#123;</span><br><span class="line">		app(<span class="string">"nerve"</span>, i, zookeeper.NewNerveDiscovery(c, log.With(m.logger, <span class="string">"discovery"</span>, <span class="string">"nerve"</span>)))</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> i, c := <span class="keyword">range</span> cfg.EC2SDConfigs &#123;</span><br><span class="line">		app(<span class="string">"ec2"</span>, i, ec2.NewDiscovery(c, log.With(m.logger, <span class="string">"discovery"</span>, <span class="string">"ec2"</span>)))</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> i, c := <span class="keyword">range</span> cfg.OpenstackSDConfigs &#123;</span><br><span class="line">		openstackd, err := openstack.NewDiscovery(c, log.With(m.logger, <span class="string">"discovery"</span>, <span class="string">"openstack"</span>))</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			level.Error(m.logger).Log(<span class="string">"msg"</span>, <span class="string">"Cannot initialize OpenStack discovery"</span>, <span class="string">"err"</span>, err)</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		app(<span class="string">"openstack"</span>, i, openstackd)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i, c := <span class="keyword">range</span> cfg.GCESDConfigs &#123;</span><br><span class="line">		gced, err := gce.NewDiscovery(*c, log.With(m.logger, <span class="string">"discovery"</span>, <span class="string">"gce"</span>))</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			level.Error(m.logger).Log(<span class="string">"msg"</span>, <span class="string">"Cannot initialize GCE discovery"</span>, <span class="string">"err"</span>, err)</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		app(<span class="string">"gce"</span>, i, gced)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> i, c := <span class="keyword">range</span> cfg.AzureSDConfigs &#123;</span><br><span class="line">		app(<span class="string">"azure"</span>, i, azure.NewDiscovery(c, log.With(m.logger, <span class="string">"discovery"</span>, <span class="string">"azure"</span>)))</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> i, c := <span class="keyword">range</span> cfg.TritonSDConfigs &#123;</span><br><span class="line">		t, err := triton.New(log.With(m.logger, <span class="string">"discovery"</span>, <span class="string">"trition"</span>), c)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			level.Error(m.logger).Log(<span class="string">"msg"</span>, <span class="string">"Cannot create Triton discovery"</span>, <span class="string">"err"</span>, err)</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		app(<span class="string">"triton"</span>, i, t)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(cfg.StaticConfigs) &gt; <span class="number">0</span> &#123;</span><br><span class="line">		app(<span class="string">"static"</span>, <span class="number">0</span>, NewStaticProvider(cfg.StaticConfigs))</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> providers</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用startProvider启动服务：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Manager)</span> <span class="title">startProvider</span><span class="params">(ctx context.Context, poolKey poolKey, worker Discoverer)</span></span> &#123;</span><br><span class="line">	ctx, cancel := context.WithCancel(ctx)</span><br><span class="line">	updates := <span class="built_in">make</span>(<span class="keyword">chan</span> []*targetgroup.Group)</span><br><span class="line"></span><br><span class="line">	m.discoverCancel = <span class="built_in">append</span>(m.discoverCancel, cancel)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> worker.Run(ctx, updates)</span><br><span class="line">	<span class="keyword">go</span> m.runProvider(ctx, poolKey, updates)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Manager)</span> <span class="title">runProvider</span><span class="params">(ctx context.Context, poolKey poolKey, updates <span class="keyword">chan</span> []*targetgroup.Group)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		<span class="keyword">case</span> tgs, ok := &lt;-updates:</span><br><span class="line">			<span class="comment">// Handle the case that a target provider exits and closes the channel</span></span><br><span class="line">			<span class="comment">// before the context is done.</span></span><br><span class="line">			<span class="keyword">if</span> !ok &#123;</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			&#125;</span><br><span class="line">			m.updateGroup(poolKey, tgs)</span><br><span class="line">			m.syncCh &lt;- m.allGroups()</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>各个服务在discovery目录中对应的服务启动。如DNS Discovery服务在完成启动之后，runProvider将接收更新之后的服务信息updates，并将新的服务信息通过updateGroup方法同步到targets列表，在调用allgroups方法完成对服务快照信息的构建，发送到指标的管理器中ScraperManager。</p>
<p>流程：</p>
<p><img src="/images/1572414553678.png" alt="1572414553678"></p>
<h2 id="ScrapeManager"><a href="#ScrapeManager" class="headerlink" title="ScrapeManager"></a>ScrapeManager</h2><p>scrapeManager组件的采集周期在prometheus.yml配置文件中由global节点下的scrape_interval指定，各个job_name可以在scrape_configs下进行个性化的设置，设置符合自身场景的scrape_interval</p>
<p>指标采集是指从发现的服务中定时获取指标数据。prometheus在启动的过程中会完成对scrapeManager的初始化，初始化过程包括构建scrapeManager实列，加载配置启动scrapeManager实例三个。scrapeManager复制维护scrapePool，并管理scrape组件的生命周期</p>
<p>ScrapeManager通过调用NewScrapeManager方法完成对scapeManager实例的创建。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ScrapeManager maintains a set of scrape pools and manages start/stop cycles</span></span><br><span class="line"><span class="comment">// when receiving new target groups form the discovery manager.</span></span><br><span class="line"><span class="keyword">type</span> ScrapeManager <span class="keyword">struct</span> &#123;</span><br><span class="line">	logger        log.Logger</span><br><span class="line">	<span class="built_in">append</span>        Appendable    <span class="comment">//指标存储器</span></span><br><span class="line">	scrapeConfigs <span class="keyword">map</span>[<span class="keyword">string</span>]*config.ScrapeConfig  <span class="comment">//job_name scrape配置</span></span><br><span class="line">	scrapePools   <span class="keyword">map</span>[<span class="keyword">string</span>]*scrapePool  <span class="comment">//job_name指标采集器</span></span><br><span class="line">	mtx           sync.RWMutex <span class="comment">//同步访问控制，读写锁</span></span><br><span class="line">	graceShut     <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;  <span class="comment">//scrapemanager关闭控制</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>初始化ScrapeManager结构;</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NewScrapeManager is the ScrapeManager constructor</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewScrapeManager</span><span class="params">(logger log.Logger, app Appendable)</span> *<span class="title">ScrapeManager</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> &amp;ScrapeManager&#123;</span><br><span class="line">		<span class="built_in">append</span>:        app,</span><br><span class="line">		logger:        logger,</span><br><span class="line">		scrapeConfigs: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]*config.ScrapeConfig),</span><br><span class="line">		scrapePools:   <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]*scrapePool),</span><br><span class="line">		graceShut:     <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;),</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>scrapeManager的配置加载，是根据prometheus.yml中的scrape_configs配置项，对scrape服务进行配置更新处理，调用方法为ApplyConfig，器内部实现分初次加载和配置更新动态加载两种。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ScrapeConfig configures a scraping unit for Prometheus.</span></span><br><span class="line"><span class="keyword">type</span> ScrapeConfig <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// The job name to which the job label is set by default.</span></span><br><span class="line">	JobName <span class="keyword">string</span> <span class="string">`yaml:"job_name"`</span></span><br><span class="line">	<span class="comment">// Indicator whether the scraped metrics should remain unmodified.</span></span><br><span class="line">	HonorLabels <span class="keyword">bool</span> <span class="string">`yaml:"honor_labels,omitempty"`</span></span><br><span class="line">	<span class="comment">// A set of query parameters with which the target is scraped.</span></span><br><span class="line">	Params url.Values <span class="string">`yaml:"params,omitempty"`</span></span><br><span class="line">	<span class="comment">// How frequently to scrape the targets of this scrape config.</span></span><br><span class="line">	ScrapeInterval model.Duration <span class="string">`yaml:"scrape_interval,omitempty"`</span></span><br><span class="line">	<span class="comment">// The timeout for scraping targets of this config.</span></span><br><span class="line">	ScrapeTimeout model.Duration <span class="string">`yaml:"scrape_timeout,omitempty"`</span></span><br><span class="line">	<span class="comment">// The HTTP resource path on which to fetch metrics from targets.</span></span><br><span class="line">	MetricsPath <span class="keyword">string</span> <span class="string">`yaml:"metrics_path,omitempty"`</span></span><br><span class="line">	<span class="comment">// The URL scheme with which to fetch metrics from targets.</span></span><br><span class="line">	Scheme <span class="keyword">string</span> <span class="string">`yaml:"scheme,omitempty"`</span></span><br><span class="line">	<span class="comment">// More than this many samples post metric-relabelling will cause the scrape to fail.</span></span><br><span class="line">	SampleLimit <span class="keyword">uint</span> <span class="string">`yaml:"sample_limit,omitempty"`</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// We cannot do proper Go type embedding below as the parser will then parse</span></span><br><span class="line">	<span class="comment">// values arbitrarily into the overflow maps of further-down types.</span></span><br><span class="line"></span><br><span class="line">	ServiceDiscoveryConfig sd_config.ServiceDiscoveryConfig <span class="string">`yaml:",inline"`</span></span><br><span class="line">	HTTPClientConfig       config_util.HTTPClientConfig     <span class="string">`yaml:",inline"`</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// List of target relabel configurations.</span></span><br><span class="line">	RelabelConfigs []*RelabelConfig <span class="string">`yaml:"relabel_configs,omitempty"`</span></span><br><span class="line">	<span class="comment">// List of metric relabel configurations.</span></span><br><span class="line">	MetricRelabelConfigs []*RelabelConfig <span class="string">`yaml:"metric_relabel_configs,omitempty"`</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Catches all undefined fields and must be empty after parsing.</span></span><br><span class="line">	XXX <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125; <span class="string">`yaml:",inline"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ApplyConfig resets the manager's target providers and job configurations as defined by the new cfg.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *ScrapeManager)</span> <span class="title">ApplyConfig</span><span class="params">(cfg *config.Config)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	m.mtx.Lock()</span><br><span class="line">	<span class="keyword">defer</span> m.mtx.Unlock()</span><br><span class="line">	c := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]*config.ScrapeConfig)</span><br><span class="line">	<span class="keyword">for</span> _, scfg := <span class="keyword">range</span> cfg.ScrapeConfigs &#123;</span><br><span class="line">		c[scfg.JobName] = scfg</span><br><span class="line">	&#125;</span><br><span class="line">	m.scrapeConfigs = c</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Cleanup and reload pool if config has changed.</span></span><br><span class="line">	<span class="keyword">for</span> name, sp := <span class="keyword">range</span> m.scrapePools &#123;</span><br><span class="line">		<span class="keyword">if</span> cfg, ok := m.scrapeConfigs[name]; !ok &#123;</span><br><span class="line">			sp.stop()</span><br><span class="line">			<span class="built_in">delete</span>(m.scrapePools, name)</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> !reflect.DeepEqual(sp.config, cfg) &#123;</span><br><span class="line">			sp.reload(cfg)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>sp.reload方法将重新配置scrapePool，流程为：</p>
<ol>
<li><p>构建scrapeLoop服务</p>
</li>
<li><p>停止线上所对应的scrapeLoop服务</p>
</li>
<li><p>启动新的scrapeLoop服务</p>
</li>
</ol>
<p>以上三步动态更新；</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// reload the scrape pool with the given scrape configuration. The target state is preserved</span></span><br><span class="line"><span class="comment">// but all scrape loops are restarted with the new scrape configuration.</span></span><br><span class="line"><span class="comment">// This method returns after all scrape loops that were stopped have stopped scraping.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sp *scrapePool)</span> <span class="title">reload</span><span class="params">(cfg *config.ScrapeConfig)</span></span> &#123;</span><br><span class="line">	start := time.Now()</span><br><span class="line"></span><br><span class="line">	sp.mtx.Lock()</span><br><span class="line">	<span class="keyword">defer</span> sp.mtx.Unlock()</span><br><span class="line"></span><br><span class="line">	client, err := httputil.NewClientFromConfig(cfg.HTTPClientConfig, cfg.JobName)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// Any errors that could occur here should be caught during config validation.</span></span><br><span class="line">		level.Error(sp.logger).Log(<span class="string">"msg"</span>, <span class="string">"Error creating HTTP client"</span>, <span class="string">"err"</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	sp.config = cfg</span><br><span class="line">	sp.client = client</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> (</span><br><span class="line">		wg       sync.WaitGroup</span><br><span class="line">		interval = time.Duration(sp.config.ScrapeInterval)</span><br><span class="line">		timeout  = time.Duration(sp.config.ScrapeTimeout)</span><br><span class="line">	)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> fp, oldLoop := <span class="keyword">range</span> sp.loops &#123;</span><br><span class="line">		<span class="keyword">var</span> (</span><br><span class="line">			t       = sp.targets[fp]</span><br><span class="line">			s       = &amp;targetScraper&#123;Target: t, client: sp.client, timeout: timeout&#125;</span><br><span class="line">			newLoop = sp.newLoop(t, s)</span><br><span class="line">		)</span><br><span class="line">		wg.Add(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(oldLoop, newLoop loop)</span></span> &#123;</span><br><span class="line">            <span class="comment">//停止线上的老的scrapeLoop服务</span></span><br><span class="line">			oldLoop.stop()</span><br><span class="line">			wg.Done()</span><br><span class="line">			<span class="comment">//启动新的scrapeLoop服务</span></span><br><span class="line">			<span class="keyword">go</span> newLoop.run(interval, timeout, <span class="literal">nil</span>)</span><br><span class="line">		&#125;(oldLoop, newLoop)</span><br><span class="line">		<span class="comment">//更新scrapePool中的scrapeLoop服务</span></span><br><span class="line">		sp.loops[fp] = newLoop</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	wg.Wait()</span><br><span class="line">	<span class="comment">//更新采集周期		targetReloadIntervalLength.WithLabelValues(interval.String()).Observe(</span></span><br><span class="line">		time.Since(start).Seconds(),</span><br><span class="line">	)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>配置加载流程：</p>
<p><img src="/images/1572415259519.png" alt="1572415259519"></p>
<p>ScrapeManager通过调用retrieval下的Manager.Run方法完成启动，其参数为prometheus.yml配置发现的目标服务，有discovery模块中的Manager.SyncCh 方法负责和ScrapeManager通信。</p>
<p>当SyncSh发生变化时，将触发ScrapeManager中的reload方法，在reload方法中会遍历目标服务，根据tsetName（jobName）从scrapePools中查找scrapePool，如果找不到则新建一个scrapePool，使得每个job都有一个对应的scrapePool</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Run starts background processing to handle target updates and reload the scraping loops.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *ScrapeManager)</span> <span class="title">Run</span><span class="params">(tsets &lt;-<span class="keyword">chan</span> <span class="keyword">map</span>[<span class="keyword">string</span>][]*targetgroup.Group)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	level.Info(m.logger).Log(<span class="string">"msg"</span>, <span class="string">"Starting scrape manager..."</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> ts := &lt;-tsets:</span><br><span class="line">			m.reload(ts)</span><br><span class="line">		<span class="keyword">case</span> &lt;-m.graceShut:</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *ScrapeManager)</span> <span class="title">reload</span><span class="params">(t <span class="keyword">map</span>[<span class="keyword">string</span>][]*targetgroup.Group)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> tsetName, tgroup := <span class="keyword">range</span> t &#123;</span><br><span class="line">		scrapeConfig, ok := m.scrapeConfigs[tsetName]</span><br><span class="line">		<span class="keyword">if</span> !ok &#123;</span><br><span class="line">			level.Error(m.logger).Log(<span class="string">"msg"</span>, <span class="string">"error reloading target set"</span>, <span class="string">"err"</span>, fmt.Sprintf(<span class="string">"invalid config id:%v"</span>, tsetName))</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//检查ScrapePool中服务是否存在，不存在构建新的ScrapePool</span></span><br><span class="line">		<span class="comment">// Scrape pool doesn't exist so start a new one.</span></span><br><span class="line">		existing, ok := m.scrapePools[tsetName]</span><br><span class="line">		<span class="keyword">if</span> !ok &#123;</span><br><span class="line">			sp := newScrapePool(scrapeConfig, m.<span class="built_in">append</span>, log.With(m.logger, <span class="string">"scrape_pool"</span>, tsetName))</span><br><span class="line">			m.scrapePools[tsetName] = sp</span><br><span class="line">			sp.Sync(tgroup)</span><br><span class="line">			<span class="comment">//调用Sync方法同步目标服务和启动scrape</span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//同步目标服务并启动scrape</span></span><br><span class="line">			existing.Sync(tgroup)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>sp.Sync方法主要用于将tgroup转换为Target类型，再调用scrapePool.sync方法同步scrape服务。</p>
<p>ScrapePool主要管理目标服务和scrapeLoop</p>
<p>Sync方法具体实现：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Sync converts target groups into actual scrape targets and synchronizes</span></span><br><span class="line"><span class="comment">// the currently running scraper with the resulting set.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sp *scrapePool)</span> <span class="title">Sync</span><span class="params">(tgs []*targetgroup.Group)</span></span> &#123;</span><br><span class="line">	start := time.Now()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> all []*Target</span><br><span class="line">	sp.mtx.Lock()</span><br><span class="line">	sp.droppedTargets = []*Target&#123;&#125;</span><br><span class="line">	<span class="keyword">for</span> _, tg := <span class="keyword">range</span> tgs &#123;</span><br><span class="line">        <span class="comment">//Group转换成target</span></span><br><span class="line">		targets, err := targetsFromGroup(tg, sp.config)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			level.Error(sp.logger).Log(<span class="string">"msg"</span>, <span class="string">"creating targets failed"</span>, <span class="string">"err"</span>, err)</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> _, t := <span class="keyword">range</span> targets &#123;</span><br><span class="line">            <span class="comment">//检查Target是否存在有有效的Label</span></span><br><span class="line">			<span class="keyword">if</span> t.Labels().Len() &gt; <span class="number">0</span> &#123;</span><br><span class="line">				all = <span class="built_in">append</span>(all, t)</span><br><span class="line">                <span class="comment">//记录无效的Target</span></span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> t.DiscoveredLabels().Len() &gt; <span class="number">0</span> &#123;</span><br><span class="line">				sp.droppedTargets = <span class="built_in">append</span>(sp.droppedTargets, t)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	sp.mtx.Unlock()</span><br><span class="line">    <span class="comment">//同步scrape服务</span></span><br><span class="line">	sp.sync(all)</span><br><span class="line"><span class="comment">//更新系统指标</span></span><br><span class="line">	targetSyncIntervalLength.WithLabelValues(sp.config.JobName).Observe(</span><br><span class="line">		time.Since(start).Seconds(),</span><br><span class="line">	)</span><br><span class="line">	targetScrapePoolSyncsCounter.WithLabelValues(sp.config.JobName).Inc()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>scrapePool.sync方法将输入参数targets与原有的targets列表sp.targets进行对比，如果有新的target加入，就创建新的targetScraper和scrapeLoop，并且启动新的scrapeLoop，如果发现已经失效的target,就会停止scrapeLoop服务并删除对应的target和scrapeLoop</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sync takes a list of potentially duplicated targets, deduplicates them, starts</span></span><br><span class="line"><span class="comment">// scrape loops for new targets, and stops scrape loops for disappeared targets.</span></span><br><span class="line"><span class="comment">// It returns after all stopped scrape loops terminated.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sp *scrapePool)</span> <span class="title">sync</span><span class="params">(targets []*Target)</span></span> &#123;</span><br><span class="line">	sp.mtx.Lock()</span><br><span class="line">	<span class="keyword">defer</span> sp.mtx.Unlock()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> (</span><br><span class="line">		uniqueTargets = <span class="keyword">map</span>[<span class="keyword">uint64</span>]<span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">		interval      = time.Duration(sp.config.ScrapeInterval)</span><br><span class="line">		timeout       = time.Duration(sp.config.ScrapeTimeout)</span><br><span class="line">	)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> _, t := <span class="keyword">range</span> targets &#123;</span><br><span class="line">		t := t</span><br><span class="line">		hash := t.hash()</span><br><span class="line">		uniqueTargets[hash] = <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> _, ok := sp.targets[hash]; !ok &#123;</span><br><span class="line">			s := &amp;targetScraper&#123;Target: t, client: sp.client, timeout: timeout&#125;</span><br><span class="line">			l := sp.newLoop(t, s)</span><br><span class="line"></span><br><span class="line">			sp.targets[hash] = t</span><br><span class="line">			sp.loops[hash] = l</span><br><span class="line"></span><br><span class="line">			<span class="keyword">go</span> l.run(interval, timeout, <span class="literal">nil</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Stop and remove old targets and scraper loops.</span></span><br><span class="line">	<span class="keyword">for</span> hash := <span class="keyword">range</span> sp.targets &#123;</span><br><span class="line">		<span class="keyword">if</span> _, ok := uniqueTargets[hash]; !ok &#123;</span><br><span class="line">			wg.Add(<span class="number">1</span>)</span><br><span class="line">			<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(l loop)</span></span> &#123;</span><br><span class="line">				l.stop()</span><br><span class="line">				wg.Done()</span><br><span class="line">			&#125;(sp.loops[hash])</span><br><span class="line"></span><br><span class="line">			<span class="built_in">delete</span>(sp.loops, hash)</span><br><span class="line">			<span class="built_in">delete</span>(sp.targets, hash)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Wait for all potentially stopped scrapers to terminate.</span></span><br><span class="line">	<span class="comment">// This covers the case of flapping targets. If the server is under high load, a new scraper</span></span><br><span class="line">	<span class="comment">// may be active and tries to insert. The old scraper that didn't terminate yet could still</span></span><br><span class="line">	<span class="comment">// be inserting a previous sample set.</span></span><br><span class="line">	wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>scrapeLoop是scrape的直接管理者，每个scrapeLoop都通过一个goroutine来运行，scrapeLoop控制scrape进行指标的拉取</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sl *scrapeLoop)</span> <span class="title">run</span><span class="params">(interval, timeout time.Duration, errc <span class="keyword">chan</span>&lt;- error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> &lt;-time.After(sl.scraper.offset(interval)):</span><br><span class="line">		<span class="comment">// Continue after a scraping offset.</span></span><br><span class="line">	<span class="keyword">case</span> &lt;-sl.scrapeCtx.Done():</span><br><span class="line">		<span class="built_in">close</span>(sl.stopped)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> last time.Time</span><br><span class="line">     </span><br><span class="line">	ticker := time.NewTicker(interval)</span><br><span class="line">	<span class="keyword">defer</span> ticker.Stop()</span><br><span class="line">    <span class="comment">//初始化指标存储空间</span></span><br><span class="line">	buf := bytes.NewBuffer(<span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">0</span>, <span class="number">16000</span>))</span><br><span class="line"></span><br><span class="line">mainLoop:</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		buf.Reset()</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">            <span class="comment">//停止scrapeLoop</span></span><br><span class="line">		<span class="keyword">case</span> &lt;-sl.ctx.Done():</span><br><span class="line">			<span class="built_in">close</span>(sl.stopped)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		<span class="keyword">case</span> &lt;-sl.scrapeCtx.Done():</span><br><span class="line">			<span class="keyword">break</span> mainLoop</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">var</span> (</span><br><span class="line">			start             = time.Now()</span><br><span class="line">			scrapeCtx, cancel = context.WithTimeout(sl.ctx, timeout)</span><br><span class="line">		)</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Only record after the first scrape.</span></span><br><span class="line">		<span class="keyword">if</span> !last.IsZero() &#123;</span><br><span class="line">			targetIntervalLength.WithLabelValues(interval.String()).Observe(</span><br><span class="line">				time.Since(last).Seconds(),</span><br><span class="line">			)</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">//根据最后一次的scrape到指标的大小来申请本次存储空间</span></span><br><span class="line">		b := sl.buffers.Get(sl.lastScrapeSize)</span><br><span class="line">		buf := bytes.NewBuffer(b)</span><br><span class="line">		<span class="comment">//scrape指标</span></span><br><span class="line">		scrapeErr := sl.scraper.scrape(scrapeCtx, buf)</span><br><span class="line">		cancel()</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> scrapeErr == <span class="literal">nil</span> &#123;</span><br><span class="line">			b = buf.Bytes()</span><br><span class="line">			<span class="comment">// <span class="doctag">NOTE:</span> There were issues with misbehaving clients in the past</span></span><br><span class="line">			<span class="comment">// that occasionally returned empty results. We don't want those</span></span><br><span class="line">			<span class="comment">// to falsely reset our buffer size.</span></span><br><span class="line">			<span class="keyword">if</span> <span class="built_in">len</span>(b) &gt; <span class="number">0</span> &#123;</span><br><span class="line">                <span class="comment">//记录本次scrape到指标的大小</span></span><br><span class="line">				sl.lastScrapeSize = <span class="built_in">len</span>(b)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			level.Debug(sl.l).Log(<span class="string">"msg"</span>, <span class="string">"Scrape failed"</span>, <span class="string">"err"</span>, scrapeErr.Error())</span><br><span class="line">			<span class="keyword">if</span> errc != <span class="literal">nil</span> &#123;</span><br><span class="line">				errc &lt;- scrapeErr</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// A failed scrape is the same as an empty scrape,</span></span><br><span class="line">		<span class="comment">// we still call sl.append to trigger stale markers.</span></span><br><span class="line">        <span class="comment">//存储指标</span></span><br><span class="line">		total, added, appErr := sl.<span class="built_in">append</span>(b, start)</span><br><span class="line">		<span class="keyword">if</span> appErr != <span class="literal">nil</span> &#123;</span><br><span class="line">			level.Warn(sl.l).Log(<span class="string">"msg"</span>, <span class="string">"append failed"</span>, <span class="string">"err"</span>, appErr)</span><br><span class="line">			<span class="comment">// The append failed, probably due to a parse error or sample limit.</span></span><br><span class="line">			<span class="comment">// Call sl.append again with an empty scrape to trigger stale markers.</span></span><br><span class="line">			<span class="keyword">if</span> _, _, err := sl.<span class="built_in">append</span>([]<span class="keyword">byte</span>&#123;&#125;, start); err != <span class="literal">nil</span> &#123;</span><br><span class="line">				level.Warn(sl.l).Log(<span class="string">"msg"</span>, <span class="string">"append failed"</span>, <span class="string">"err"</span>, err)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//对象复用</span></span><br><span class="line">		sl.buffers.Put(b)</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> scrapeErr == <span class="literal">nil</span> &#123;</span><br><span class="line">			scrapeErr = appErr</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//统计采集到的指标</span></span><br><span class="line">		sl.report(start, time.Since(start), total, added, scrapeErr)</span><br><span class="line">		last = start</span><br><span class="line"></span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> &lt;-sl.ctx.Done():</span><br><span class="line">			<span class="built_in">close</span>(sl.stopped)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		<span class="keyword">case</span> &lt;-sl.scrapeCtx.Done():</span><br><span class="line">			<span class="keyword">break</span> mainLoop</span><br><span class="line">		<span class="keyword">case</span> &lt;-ticker.C:</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">close</span>(sl.stopped)</span><br><span class="line"></span><br><span class="line">	sl.endOfRunStaleness(last, ticker, interval)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>run方法中调用sl.scraper.scrape进行指标采集，并将采集到的指标通过sl.append方法进行存储。</p>
<p>再scrape过程中为了提供性能，使用sync.Pool机制来复用对象，再每次scrape后都会向pool申请和scrape结果相同大小的byte slice，并添加到sl.buffers中，以便供下一次获取指标使用</p>
<p>流程：</p>
<p><img src="/images/1572416216523.png" alt="1572416216523"></p>
<h2 id="LocalStorage-RemoteStorage"><a href="#LocalStorage-RemoteStorage" class="headerlink" title="LocalStorage/RemoteStorage"></a>LocalStorage/RemoteStorage</h2><p>Prometheus再通过scrape获取指标后，调用scrapeLoop.append方法将指标存储到fanoutStorage组件中，但再scrape与fanoutStorage之间加了一层scrapeCache，用于指标合法行校验。</p>
<p>scrapeCache缓存了两种不合法的指标：</p>
<p>1）指标纬度为空，无效指标</p>
<p>2）连续两次指标存储中，第一次存储的不带时间戳指标再第二次存储的不带时间戳指标中不存在，这部分指标过期指标</p>
<p>scrapeCache:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// scrapeCache tracks mappings of exposed metric strings to label sets and</span></span><br><span class="line"><span class="comment">// storage references. Additionally, it tracks staleness of series between</span></span><br><span class="line"><span class="comment">// scrapes.</span></span><br><span class="line"><span class="keyword">type</span> scrapeCache <span class="keyword">struct</span> &#123;</span><br><span class="line">	iter <span class="keyword">uint64</span> <span class="comment">// Current scrape iteration.</span></span><br><span class="line">	<span class="comment">// 被缓存的批次数</span></span><br><span class="line">	<span class="comment">// Parsed string to an entry with information about the actual label set</span></span><br><span class="line">	<span class="comment">// and its storage reference.</span></span><br><span class="line">	entries <span class="keyword">map</span>[<span class="keyword">string</span>]*cacheEntry</span><br><span class="line">	<span class="comment">// 缓存本次采集的指标</span></span><br><span class="line">	<span class="comment">// Cache of dropped metric strings and their iteration. The iteration must</span></span><br><span class="line">	<span class="comment">// be a pointer so we can update it without setting a new entry with an unsafe</span></span><br><span class="line">	<span class="comment">// string in addDropped().</span></span><br><span class="line">	dropped <span class="keyword">map</span>[<span class="keyword">string</span>]*<span class="keyword">uint64</span></span><br><span class="line">    <span class="comment">//缓存本次采集的指标</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// seriesCur and seriesPrev store the labels of series that were seen</span></span><br><span class="line">	<span class="comment">// in the current and previous scrape.</span></span><br><span class="line">	<span class="comment">// We hold two maps and swap them out to save allocations.</span></span><br><span class="line">	seriesCur  <span class="keyword">map</span>[<span class="keyword">uint64</span>]labels.Labels</span><br><span class="line">	seriesPrev <span class="keyword">map</span>[<span class="keyword">uint64</span>]labels.Labels</span><br><span class="line">    <span class="comment">//缓存上次采集的指标</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newScrapeCache</span><span class="params">()</span> *<span class="title">scrapeCache</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;scrapeCache&#123;</span><br><span class="line">		entries:    <span class="keyword">map</span>[<span class="keyword">string</span>]*cacheEntry&#123;&#125;,</span><br><span class="line">		dropped:    <span class="keyword">map</span>[<span class="keyword">string</span>]*<span class="keyword">uint64</span>&#123;&#125;,</span><br><span class="line">		seriesCur:  <span class="keyword">map</span>[<span class="keyword">uint64</span>]labels.Labels&#123;&#125;,</span><br><span class="line">		seriesPrev: <span class="keyword">map</span>[<span class="keyword">uint64</span>]labels.Labels&#123;&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>scrapeCache主要方法：</p>
<p>iterDone()；用于scrapeCache缓存整理</p>
<p>get:根据指标信息met获取cacheEntry结构</p>
<p>addRef：根据指标信息增加cacheEntry节点</p>
<p>addDropped:添加无效指标信息到dropped</p>
<p>getDropped: 判断met是否为无效指标</p>
<p>trackStaleness:添加不带时间戳的指标到seriesCur列表</p>
<p>forEachStale：查找过期的指标</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sl *scrapeLoop)</span> <span class="title">append</span><span class="params">(b []<span class="keyword">byte</span>, ts time.Time)</span> <span class="params">(total, added <span class="keyword">int</span>, err error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> (</span><br><span class="line">		app            = sl.appender()</span><br><span class="line">		p              = textparse.New(b)</span><br><span class="line">		defTime        = timestamp.FromTime(ts)</span><br><span class="line">		numOutOfOrder  = <span class="number">0</span></span><br><span class="line">		numDuplicates  = <span class="number">0</span></span><br><span class="line">		numOutOfBounds = <span class="number">0</span></span><br><span class="line">	)</span><br><span class="line">	<span class="keyword">var</span> sampleLimitErr error</span><br><span class="line"></span><br><span class="line">loop:</span><br><span class="line">	<span class="keyword">for</span> p.Next() &#123;</span><br><span class="line">		total++</span><br><span class="line"></span><br><span class="line">		t := defTime</span><br><span class="line">		met, tp, v := p.At()</span><br><span class="line">		<span class="keyword">if</span> tp != <span class="literal">nil</span> &#123;</span><br><span class="line">			t = *tp</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> sl.cache.getDropped(yoloString(met)) &#123;</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		ce, ok := sl.cache.get(yoloString(met))</span><br><span class="line">		<span class="keyword">if</span> ok &#123;</span><br><span class="line">			<span class="keyword">switch</span> err = app.AddFast(ce.lset, ce.ref, t, v); err &#123;</span><br><span class="line">			<span class="keyword">case</span> <span class="literal">nil</span>:</span><br><span class="line">				<span class="keyword">if</span> tp == <span class="literal">nil</span> &#123;</span><br><span class="line">					sl.cache.trackStaleness(ce.hash, ce.lset)</span><br><span class="line">				&#125;</span><br><span class="line">			<span class="keyword">case</span> storage.ErrNotFound:</span><br><span class="line">				ok = <span class="literal">false</span></span><br><span class="line">			<span class="keyword">case</span> storage.ErrOutOfOrderSample:</span><br><span class="line">				numOutOfOrder++</span><br><span class="line">				level.Debug(sl.l).Log(<span class="string">"msg"</span>, <span class="string">"Out of order sample"</span>, <span class="string">"series"</span>, <span class="keyword">string</span>(met))</span><br><span class="line">				targetScrapeSampleOutOfOrder.Inc()</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			<span class="keyword">case</span> storage.ErrDuplicateSampleForTimestamp:</span><br><span class="line">				numDuplicates++</span><br><span class="line">				level.Debug(sl.l).Log(<span class="string">"msg"</span>, <span class="string">"Duplicate sample for timestamp"</span>, <span class="string">"series"</span>, <span class="keyword">string</span>(met))</span><br><span class="line">				targetScrapeSampleDuplicate.Inc()</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			<span class="keyword">case</span> storage.ErrOutOfBounds:</span><br><span class="line">				numOutOfBounds++</span><br><span class="line">				level.Debug(sl.l).Log(<span class="string">"msg"</span>, <span class="string">"Out of bounds metric"</span>, <span class="string">"series"</span>, <span class="keyword">string</span>(met))</span><br><span class="line">				targetScrapeSampleOutOfBounds.Inc()</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			<span class="keyword">case</span> errSampleLimit:</span><br><span class="line">				<span class="comment">// Keep on parsing output if we hit the limit, so we report the correct</span></span><br><span class="line">				<span class="comment">// total number of samples scraped.</span></span><br><span class="line">				sampleLimitErr = err</span><br><span class="line">				added++</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">				<span class="keyword">break</span> loop</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> !ok &#123;</span><br><span class="line">			<span class="keyword">var</span> lset labels.Labels</span><br><span class="line"></span><br><span class="line">			mets := p.Metric(&amp;lset)</span><br><span class="line">			hash := lset.Hash()</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Hash label set as it is seen local to the target. Then add target labels</span></span><br><span class="line">			<span class="comment">// and relabeling and store the final label set.</span></span><br><span class="line">			lset = sl.sampleMutator(lset)</span><br><span class="line"></span><br><span class="line">			<span class="comment">// The label set may be set to nil to indicate dropping.</span></span><br><span class="line">			<span class="keyword">if</span> lset == <span class="literal">nil</span> &#123;</span><br><span class="line">				sl.cache.addDropped(mets)</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">var</span> ref <span class="keyword">uint64</span></span><br><span class="line">			ref, err = app.Add(lset, t, v)</span><br><span class="line">			<span class="comment">// TODO(fabxc): also add a dropped-cache?</span></span><br><span class="line">			<span class="keyword">switch</span> err &#123;</span><br><span class="line">			<span class="keyword">case</span> <span class="literal">nil</span>:</span><br><span class="line">			<span class="keyword">case</span> storage.ErrOutOfOrderSample:</span><br><span class="line">				err = <span class="literal">nil</span></span><br><span class="line">				numOutOfOrder++</span><br><span class="line">				level.Debug(sl.l).Log(<span class="string">"msg"</span>, <span class="string">"Out of order sample"</span>, <span class="string">"series"</span>, <span class="keyword">string</span>(met))</span><br><span class="line">				targetScrapeSampleOutOfOrder.Inc()</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			<span class="keyword">case</span> storage.ErrDuplicateSampleForTimestamp:</span><br><span class="line">				err = <span class="literal">nil</span></span><br><span class="line">				numDuplicates++</span><br><span class="line">				level.Debug(sl.l).Log(<span class="string">"msg"</span>, <span class="string">"Duplicate sample for timestamp"</span>, <span class="string">"series"</span>, <span class="keyword">string</span>(met))</span><br><span class="line">				targetScrapeSampleDuplicate.Inc()</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			<span class="keyword">case</span> storage.ErrOutOfBounds:</span><br><span class="line">				err = <span class="literal">nil</span></span><br><span class="line">				numOutOfBounds++</span><br><span class="line">				level.Debug(sl.l).Log(<span class="string">"msg"</span>, <span class="string">"Out of bounds metric"</span>, <span class="string">"series"</span>, <span class="keyword">string</span>(met))</span><br><span class="line">				targetScrapeSampleOutOfBounds.Inc()</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			<span class="keyword">case</span> errSampleLimit:</span><br><span class="line">				sampleLimitErr = err</span><br><span class="line">				added++</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">				level.Debug(sl.l).Log(<span class="string">"msg"</span>, <span class="string">"unexpected error"</span>, <span class="string">"series"</span>, <span class="keyword">string</span>(met), <span class="string">"err"</span>, err)</span><br><span class="line">				<span class="keyword">break</span> loop</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> tp == <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="comment">// Bypass staleness logic if there is an explicit timestamp.</span></span><br><span class="line">				sl.cache.trackStaleness(hash, lset)</span><br><span class="line">			&#125;</span><br><span class="line">			sl.cache.addRef(mets, ref, lset, hash)</span><br><span class="line">		&#125;</span><br><span class="line">		added++</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">		err = p.Err()</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> sampleLimitErr != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// We only want to increment this once per scrape, so this is Inc'd outside the loop.</span></span><br><span class="line">		targetScrapeSampleLimit.Inc()</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> numOutOfOrder &gt; <span class="number">0</span> &#123;</span><br><span class="line">		level.Warn(sl.l).Log(<span class="string">"msg"</span>, <span class="string">"Error on ingesting out-of-order samples"</span>, <span class="string">"num_dropped"</span>, numOutOfOrder)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> numDuplicates &gt; <span class="number">0</span> &#123;</span><br><span class="line">		level.Warn(sl.l).Log(<span class="string">"msg"</span>, <span class="string">"Error on ingesting samples with different value but same timestamp"</span>, <span class="string">"num_dropped"</span>, numDuplicates)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> numOutOfBounds &gt; <span class="number">0</span> &#123;</span><br><span class="line">		level.Warn(sl.l).Log(<span class="string">"msg"</span>, <span class="string">"Error on ingesting samples that are too old or are too far into the future"</span>, <span class="string">"num_dropped"</span>, numOutOfBounds)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">		sl.cache.forEachStale(<span class="function"><span class="keyword">func</span><span class="params">(lset labels.Labels)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">			<span class="comment">// Series no longer exposed, mark it stale.</span></span><br><span class="line">			_, err = app.Add(lset, defTime, math.Float64frombits(value.StaleNaN))</span><br><span class="line">			<span class="keyword">switch</span> err &#123;</span><br><span class="line">			<span class="keyword">case</span> storage.ErrOutOfOrderSample, storage.ErrDuplicateSampleForTimestamp:</span><br><span class="line">				<span class="comment">// Do not count these in logging, as this is expected if a target</span></span><br><span class="line">				<span class="comment">// goes away and comes back again with a new scrape loop.</span></span><br><span class="line">				err = <span class="literal">nil</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> err == <span class="literal">nil</span></span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		app.Rollback()</span><br><span class="line">		<span class="keyword">return</span> total, added, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> err := app.Commit(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> total, added, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	sl.cache.iterDone()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> total, added, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>存储指标append方法的具体实现，</p>
<p>存储指标的流程：</p>
<p><img src="/images/1572417134533.png" alt="1572417134533"></p>
<p>prometheus支持远程存储，也支持本地存储。</p>
<p>remote中为远程存储，</p>
<p>tsdb中为本地存储</p>
<p>远程存储：存储的数据，发送过来的样本先放入到队列中，这个队列的最大分片是1000，每个分片没秒1000个sample，那么一秒就可以发送1000*1000个sample。</p>
<p>数据结构为：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// QueueManager manages a queue of samples to be sent to the Storage</span></span><br><span class="line"><span class="comment">// indicated by the provided StorageClient.</span></span><br><span class="line"><span class="keyword">type</span> QueueManager <span class="keyword">struct</span> &#123;</span><br><span class="line">	logger log.Logger</span><br><span class="line"></span><br><span class="line">	cfg            config.QueueConfig                     <span class="comment">//队列配置</span></span><br><span class="line">	externalLabels model.LabelSet                         <span class="comment">//</span></span><br><span class="line">	relabelConfigs []*config.RelabelConfig </span><br><span class="line">	client         StorageClient                          <span class="comment">// 存储客户端</span></span><br><span class="line">	queueName      <span class="keyword">string</span>                                 <span class="comment">//队列名称</span></span><br><span class="line">	logLimiter     *rate.Limiter                          <span class="comment">//限流</span></span><br><span class="line"> </span><br><span class="line">	shardsMtx   sync.Mutex</span><br><span class="line">	shards      *shards                                   <span class="comment">//分片</span></span><br><span class="line">	numShards   <span class="keyword">int</span>                                       <span class="comment">//分片数目</span></span><br><span class="line">	reshardChan <span class="keyword">chan</span> <span class="keyword">int</span></span><br><span class="line">	quit        <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">	wg          sync.WaitGroup</span><br><span class="line"></span><br><span class="line">	samplesIn, samplesOut, samplesOutDuration *ewmaRate</span><br><span class="line">	integralAccumulator                       <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>构建好发送队列的函数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NewQueueManager builds a new QueueManager.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewQueueManager</span><span class="params">(logger log.Logger, cfg config.QueueConfig, externalLabels model.LabelSet, relabelConfigs []*config.RelabelConfig, client StorageClient)</span> *<span class="title">QueueManager</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> logger == <span class="literal">nil</span> &#123;</span><br><span class="line">		logger = log.NewNopLogger()</span><br><span class="line">	&#125;</span><br><span class="line">	t := &amp;QueueManager&#123;</span><br><span class="line">		logger:         logger,</span><br><span class="line">		cfg:            cfg,</span><br><span class="line">		externalLabels: externalLabels,</span><br><span class="line">		relabelConfigs: relabelConfigs,</span><br><span class="line">		client:         client,</span><br><span class="line">		queueName:      client.Name(),</span><br><span class="line"></span><br><span class="line">		logLimiter:  rate.NewLimiter(logRateLimit, logBurst),</span><br><span class="line">		numShards:   <span class="number">1</span>,</span><br><span class="line">		reshardChan: <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>),</span><br><span class="line">		quit:        <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;),</span><br><span class="line"></span><br><span class="line">		samplesIn:          newEWMARate(ewmaWeight, shardUpdateDuration),</span><br><span class="line">		samplesOut:         newEWMARate(ewmaWeight, shardUpdateDuration),</span><br><span class="line">		samplesOutDuration: newEWMARate(ewmaWeight, shardUpdateDuration),</span><br><span class="line">	&#125;</span><br><span class="line">	t.shards = t.newShards(t.numShards)</span><br><span class="line">	numShards.WithLabelValues(t.queueName).Set(<span class="keyword">float64</span>(t.numShards))</span><br><span class="line">	queueCapacity.WithLabelValues(t.queueName).Set(<span class="keyword">float64</span>(t.cfg.Capacity))</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Initialise counter labels to zero.</span></span><br><span class="line">    <span class="comment">//初始化</span></span><br><span class="line">	sentBatchDuration.WithLabelValues(t.queueName)                  </span><br><span class="line">	succeededSamplesTotal.WithLabelValues(t.queueName)</span><br><span class="line">	failedSamplesTotal.WithLabelValues(t.queueName)</span><br><span class="line">	droppedSamplesTotal.WithLabelValues(t.queueName)</span><br><span class="line">	<span class="keyword">return</span> t</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用append方法来添加样本数据到队列分片中</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Append queues a sample to be sent to the remote storage. It drops the</span></span><br><span class="line"><span class="comment">// sample on the floor if the queue is full.</span></span><br><span class="line"><span class="comment">// Always returns nil.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *QueueManager)</span> <span class="title">Append</span><span class="params">(s *model.Sample)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> snew model.Sample</span><br><span class="line">	snew = *s</span><br><span class="line">	snew.Metric = s.Metric.Clone()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> ln, lv := <span class="keyword">range</span> t.externalLabels &#123;</span><br><span class="line">		<span class="keyword">if</span> _, ok := s.Metric[ln]; !ok &#123;</span><br><span class="line">			snew.Metric[ln] = lv</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	snew.Metric = model.Metric(</span><br><span class="line">		relabel.Process(model.LabelSet(snew.Metric), t.relabelConfigs...))</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> snew.Metric == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	t.shardsMtx.Lock()</span><br><span class="line">	enqueued := t.shards.enqueue(&amp;snew)</span><br><span class="line">	t.shardsMtx.Unlock()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> enqueued &#123;</span><br><span class="line">		queueLength.WithLabelValues(t.queueName).Inc()</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		droppedSamplesTotal.WithLabelValues(t.queueName).Inc()</span><br><span class="line">		<span class="keyword">if</span> t.logLimiter.Allow() &#123;</span><br><span class="line">			level.Warn(t.logger).Log(<span class="string">"msg"</span>, <span class="string">"Remote storage queue full, discarding sample. Multiple subsequent messages of this kind may be suppressed."</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中使用的函数enqueue发送到队列里面：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *shards)</span> <span class="title">enqueue</span><span class="params">(sample *model.Sample)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	s.qm.samplesIn.incr(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">	fp := sample.Metric.FastFingerprint()</span><br><span class="line">	shard := <span class="keyword">uint64</span>(fp) % <span class="keyword">uint64</span>(<span class="built_in">len</span>(s.queues))</span><br><span class="line"></span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> s.queues[shard] &lt;- sample:</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个队列存储里面用余数去分组的。</p>
<p>使用start方法来启动队列发送任务：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *shards)</span> <span class="title">start</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(s.queues); i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> s.runShard(i)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数runShared生成多个协程去执行：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *shards)</span> <span class="title">runShard</span><span class="params">(i <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> s.wg.Done()</span><br><span class="line">	queue := s.queues[i]</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Send batches of at most MaxSamplesPerSend samples to the remote storage.</span></span><br><span class="line">	<span class="comment">// If we have fewer samples than that, flush them out after a deadline</span></span><br><span class="line">	<span class="comment">// anyways.</span></span><br><span class="line">	pendingSamples := model.Samples&#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> sample, ok := &lt;-queue:</span><br><span class="line">			<span class="keyword">if</span> !ok &#123;</span><br><span class="line">				<span class="keyword">if</span> <span class="built_in">len</span>(pendingSamples) &gt; <span class="number">0</span> &#123;</span><br><span class="line">					level.Debug(s.qm.logger).Log(<span class="string">"msg"</span>, <span class="string">"Flushing samples to remote storage..."</span>, <span class="string">"count"</span>, <span class="built_in">len</span>(pendingSamples))</span><br><span class="line">					s.sendSamples(pendingSamples)</span><br><span class="line">					level.Debug(s.qm.logger).Log(<span class="string">"msg"</span>, <span class="string">"Done flushing."</span>)</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			queueLength.WithLabelValues(s.qm.queueName).Dec()</span><br><span class="line">			pendingSamples = <span class="built_in">append</span>(pendingSamples, sample)</span><br><span class="line"></span><br><span class="line">			<span class="keyword">for</span> <span class="built_in">len</span>(pendingSamples) &gt;= s.qm.cfg.MaxSamplesPerSend &#123;</span><br><span class="line">				s.sendSamples(pendingSamples[:s.qm.cfg.MaxSamplesPerSend])</span><br><span class="line">				pendingSamples = pendingSamples[s.qm.cfg.MaxSamplesPerSend:]</span><br><span class="line">			&#125;</span><br><span class="line">		<span class="keyword">case</span> &lt;-time.After(s.qm.cfg.BatchSendDeadline):</span><br><span class="line">			<span class="keyword">if</span> <span class="built_in">len</span>(pendingSamples) &gt; <span class="number">0</span> &#123;</span><br><span class="line">				s.sendSamples(pendingSamples)</span><br><span class="line">				pendingSamples = pendingSamples[:<span class="number">0</span>]</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中调用了方法sendSamples去发送样本：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *shards)</span> <span class="title">sendSamples</span><span class="params">(samples model.Samples)</span></span> &#123;</span><br><span class="line">	begin := time.Now()</span><br><span class="line">	s.sendSamplesWithBackoff(samples)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// These counters are used to caclulate the dynamic sharding, and as such</span></span><br><span class="line">	<span class="comment">// should be maintained irrespective of success or failure.</span></span><br><span class="line">	s.qm.samplesOut.incr(<span class="keyword">int64</span>(<span class="built_in">len</span>(samples)))</span><br><span class="line">	s.qm.samplesOutDuration.incr(<span class="keyword">int64</span>(time.Since(begin)))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中方法使用了samplesOut和samplesOutDuration来计算分片的动态变化。保证成功发送和失败的数目。</p>
<p>启动调用函数sendSamplesWithBackOff函数来保证远程发送的时候失败的情况：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *shards)</span> <span class="title">sendSamplesWithBackoff</span><span class="params">(samples model.Samples)</span></span> &#123;</span><br><span class="line">	backoff := s.qm.cfg.MinBackoff</span><br><span class="line">	<span class="keyword">for</span> retries := s.qm.cfg.MaxRetries; retries &gt; <span class="number">0</span>; retries-- &#123;</span><br><span class="line">		begin := time.Now()</span><br><span class="line">		req := ToWriteRequest(samples)</span><br><span class="line">		err := s.qm.client.Store(req)</span><br><span class="line"></span><br><span class="line">		sentBatchDuration.WithLabelValues(s.qm.queueName).Observe(time.Since(begin).Seconds())</span><br><span class="line">		<span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">			succeededSamplesTotal.WithLabelValues(s.qm.queueName).Add(<span class="keyword">float64</span>(<span class="built_in">len</span>(samples)))</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		level.Warn(s.qm.logger).Log(<span class="string">"msg"</span>, <span class="string">"Error sending samples to remote storage"</span>, <span class="string">"count"</span>, <span class="built_in">len</span>(samples), <span class="string">"err"</span>, err)</span><br><span class="line">		<span class="keyword">if</span> _, ok := err.(recoverableError); !ok &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		time.Sleep(backoff)</span><br><span class="line">		backoff = backoff * <span class="number">2</span></span><br><span class="line">		<span class="keyword">if</span> backoff &gt; s.qm.cfg.MaxBackoff &#123;</span><br><span class="line">			backoff = s.qm.cfg.MaxBackoff</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">failedSamplesTotal.WithLabelValues(s.qm.queueName).Add(<span class="keyword">float64</span>(<span class="built_in">len</span>(samples)))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果发送失败会重试几次，如果还是失败，会将发送失败的样本计入失败的计算器。</p>
<p>如果成功，会调用Client中的Store方法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Client)</span> <span class="title">Store</span><span class="params">(req *prompb.WriteRequest)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	data, err := proto.Marshal(req)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	compressed := snappy.Encode(<span class="literal">nil</span>, data)</span><br><span class="line">	httpReq, err := http.NewRequest(<span class="string">"POST"</span>, c.url.String(), bytes.NewReader(compressed))</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// Errors from NewRequest are from unparseable URLs, so are not</span></span><br><span class="line">		<span class="comment">// recoverable.</span></span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	httpReq.Header.Add(<span class="string">"Content-Encoding"</span>, <span class="string">"snappy"</span>)</span><br><span class="line">	httpReq.Header.Set(<span class="string">"Content-Type"</span>, <span class="string">"application/x-protobuf"</span>)</span><br><span class="line">	httpReq.Header.Set(<span class="string">"X-Prometheus-Remote-Write-Version"</span>, <span class="string">"0.1.0"</span>)</span><br><span class="line"></span><br><span class="line">	ctx, cancel := context.WithTimeout(context.Background(), c.timeout)</span><br><span class="line">	<span class="keyword">defer</span> cancel()</span><br><span class="line"></span><br><span class="line">	httpResp, err := ctxhttp.Do(ctx, c.client, httpReq)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// Errors from client.Do are from (for example) network errors, so are</span></span><br><span class="line">		<span class="comment">// recoverable.</span></span><br><span class="line">		<span class="keyword">return</span> recoverableError&#123;err&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> httpResp.Body.Close()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> httpResp.StatusCode/<span class="number">100</span> != <span class="number">2</span> &#123;</span><br><span class="line">		scanner := bufio.NewScanner(io.LimitReader(httpResp.Body, maxErrMsgLen))</span><br><span class="line">		line := <span class="string">""</span></span><br><span class="line">		<span class="keyword">if</span> scanner.Scan() &#123;</span><br><span class="line">			line = scanner.Text()</span><br><span class="line">		&#125;</span><br><span class="line">		err = fmt.Errorf(<span class="string">"server returned HTTP status %s: %s"</span>, httpResp.Status, line)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> httpResp.StatusCode/<span class="number">100</span> == <span class="number">5</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> recoverableError&#123;err&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过post方式，发送数据。</p>
<p>本地存储主要使用的tsdb库中，后面的版本对tsdb有较为大的变化。</p>
<p>fanout为本地和远程的读写代理器，入口在fanout中，fanout的数据结构</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> fanout <span class="keyword">struct</span> &#123;</span><br><span class="line">	logger log.Logger</span><br><span class="line"></span><br><span class="line">	primary     Storage</span><br><span class="line">	secondaries []Storage</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>初始化数据结构：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NewFanout returns a new fan-out Storage, which proxies reads and writes</span></span><br><span class="line"><span class="comment">// through to multiple underlying storages.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewFanout</span><span class="params">(logger log.Logger, primary Storage, secondaries ...Storage)</span> <span class="title">Storage</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;fanout&#123;</span><br><span class="line">		logger:      logger,</span><br><span class="line">		primary:     primary,</span><br><span class="line">		secondaries: secondaries,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>添加数据使用appender方法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *fanout)</span> <span class="title">Appender</span><span class="params">()</span> <span class="params">(Appender, error)</span></span> &#123;</span><br><span class="line">	primary, err := f.primary.Appender()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	secondaries := <span class="built_in">make</span>([]Appender, <span class="number">0</span>, <span class="built_in">len</span>(f.secondaries))</span><br><span class="line">	<span class="keyword">for</span> _, storage := <span class="keyword">range</span> f.secondaries &#123;</span><br><span class="line">		appender, err := storage.Appender()</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">		&#125;</span><br><span class="line">		secondaries = <span class="built_in">append</span>(secondaries, appender)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> &amp;fanoutAppender&#123;</span><br><span class="line">		logger:      f.logger,</span><br><span class="line">		primary:     primary,</span><br><span class="line">		secondaries: secondaries,</span><br><span class="line">	&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>本地存储使用tsdb来存储：</p>
<p>prometheus中提供了接口，调用tsdb数据库来进行存储。tsdb后续单独来说明。</p>
<p>打开一个db库函数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Open</span><span class="params">(path <span class="keyword">string</span>, l log.Logger, r prometheus.Registerer, opts *Options)</span> <span class="params">(*tsdb.DB, error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> opts.MinBlockDuration &gt; opts.MaxBlockDuration &#123;</span><br><span class="line">		opts.MaxBlockDuration = opts.MinBlockDuration</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Start with smallest block duration and create exponential buckets until the exceed the</span></span><br><span class="line">	<span class="comment">// configured maximum block duration.</span></span><br><span class="line">	rngs := tsdb.ExponentialBlockRanges(<span class="keyword">int64</span>(time.Duration(opts.MinBlockDuration).Seconds()*<span class="number">1000</span>), <span class="number">10</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i, v := <span class="keyword">range</span> rngs &#123;</span><br><span class="line">		<span class="keyword">if</span> v &gt; <span class="keyword">int64</span>(time.Duration(opts.MaxBlockDuration).Seconds()*<span class="number">1000</span>) &#123;</span><br><span class="line">			rngs = rngs[:i]</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	db, err := tsdb.Open(path, l, r, &amp;tsdb.Options&#123;</span><br><span class="line">		WALFlushInterval:  <span class="number">10</span> * time.Second,</span><br><span class="line">		RetentionDuration: <span class="keyword">uint64</span>(time.Duration(opts.Retention).Seconds() * <span class="number">1000</span>),</span><br><span class="line">		BlockRanges:       rngs,</span><br><span class="line">		NoLockfile:        opts.NoLockfile,</span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> db, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="AlertManager"><a href="#AlertManager" class="headerlink" title="AlertManager"></a>AlertManager</h2><p>接收告警信息请求的地址为：<a href="http://localhost:9093/api/v1/alerts，api接收告警信息后会进入到api.addAlerts中。" target="_blank" rel="noopener">http://localhost:9093/api/v1/alerts，api接收告警信息后会进入到api.addAlerts中。</a></p>
<p>AlertManager服务启动时候，api.addAlerts方法会通过api.Register方法再路由中完成路由请求地址的注册。</p>
<p>在api.addAlerts方法中，会将从参数r中接受到的告警信息解析为types.Alert数组，最后将其插入本地缓存中。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(api *API)</span> <span class="title">addAlerts</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> alerts []*types.Alert</span><br><span class="line">	<span class="keyword">if</span> err := receive(r, &amp;alerts); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		respondError(w, apiError&#123;</span><br><span class="line">			typ: errorBadData,</span><br><span class="line">			err: err,</span><br><span class="line">		&#125;, <span class="literal">nil</span>)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	api.insertAlerts(w, r, alerts...)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">receive</span><span class="params">(r *http.Request, v <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	dec := json.NewDecoder(r.Body)</span><br><span class="line">	<span class="keyword">defer</span> r.Body.Close()</span><br><span class="line"></span><br><span class="line">	err := dec.Decode(v)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Debugf(<span class="string">"Decoding request failed: %v"</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>告警调度：</p>
<p>告警信息被插入AlertManager本地缓存后，会通过告警调度服务从本地缓存中获取告警信息，并将告警信息发送出去。</p>
<p>本地缓存基于内存实现，</p>
<p>告警调度服务的初始化代码在main中，reload方法完成，</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">reload := <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">		log.With(<span class="string">"file"</span>, *configFile).Infof(<span class="string">"Loading configuration file"</span>)</span><br><span class="line">		<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				log.With(<span class="string">"file"</span>, *configFile).Errorf(<span class="string">"Loading configuration file failed: %s"</span>, err)</span><br><span class="line">				configSuccess.Set(<span class="number">0</span>)</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				configSuccess.Set(<span class="number">1</span>)</span><br><span class="line">				configSuccessTime.Set(<span class="keyword">float64</span>(time.Now().Unix()))</span><br><span class="line">				configHash.Set(hash)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;()</span><br><span class="line"></span><br><span class="line">		conf, plainCfg, err := config.LoadFile(*configFile)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		hash = md5HashAsMetricValue(plainCfg)</span><br><span class="line"></span><br><span class="line">		err = apiv.Update(conf, time.Duration(conf.Global.ResolveTimeout))</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		tmpl, err = template.FromGlobs(conf.Templates...)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">		tmpl.ExternalURL = amURL</span><br><span class="line"></span><br><span class="line">		inhibitor.Stop()</span><br><span class="line">		disp.Stop()</span><br><span class="line"></span><br><span class="line">		inhibitor = inhibit.NewInhibitor(alerts, conf.InhibitRules, marker)</span><br><span class="line">		pipeline = notify.BuildPipeline(</span><br><span class="line">			conf.Receivers,</span><br><span class="line">			tmpl,</span><br><span class="line">			waitFunc,</span><br><span class="line">			inhibitor,</span><br><span class="line">			silences,</span><br><span class="line">			notificationLog,</span><br><span class="line">			marker,</span><br><span class="line">		)</span><br><span class="line">		disp = dispatch.NewDispatcher(alerts, dispatch.NewRoute(conf.Route, <span class="literal">nil</span>), pipeline, marker, timeoutFunc)</span><br><span class="line"></span><br><span class="line">		<span class="keyword">go</span> disp.Run()</span><br><span class="line">		<span class="keyword">go</span> inhibitor.Run()</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>Run方法具体实现如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// Run starts dispatching alerts incoming via the updates channel.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *Dispatcher)</span> <span class="title">Run</span><span class="params">()</span></span> &#123;</span><br><span class="line">	d.done = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"></span><br><span class="line">	d.mtx.Lock()</span><br><span class="line">	d.aggrGroups = <span class="keyword">map</span>[*Route]<span class="keyword">map</span>[model.Fingerprint]*aggrGroup&#123;&#125;</span><br><span class="line">	d.mtx.Unlock()</span><br><span class="line"></span><br><span class="line">	d.ctx, d.cancel = context.WithCancel(context.Background())</span><br><span class="line"></span><br><span class="line">	d.run(d.alerts.Subscribe())</span><br><span class="line">	<span class="built_in">close</span>(d.done)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Subscribe方法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// Subscribe returns an iterator over active alerts that have not been</span></span><br><span class="line"><span class="comment">// resolved and successfully notified about.</span></span><br><span class="line"><span class="comment">// They are not guaranteed to be in chronological order.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *Alerts)</span> <span class="title">Subscribe</span><span class="params">()</span> <span class="title">provider</span>.<span class="title">AlertIterator</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> (</span><br><span class="line">		ch   = <span class="built_in">make</span>(<span class="keyword">chan</span> *types.Alert, <span class="number">200</span>)</span><br><span class="line">		done = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">	)</span><br><span class="line">	alerts, err := a.getPending()</span><br><span class="line"></span><br><span class="line">	a.mtx.Lock()</span><br><span class="line">	i := a.next</span><br><span class="line">	a.next++</span><br><span class="line">	a.listeners[i] = ch</span><br><span class="line">	a.mtx.Unlock()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			a.mtx.Lock()</span><br><span class="line">			<span class="built_in">delete</span>(a.listeners, i)</span><br><span class="line">			<span class="built_in">close</span>(ch)</span><br><span class="line">			a.mtx.Unlock()</span><br><span class="line">		&#125;()</span><br><span class="line">		<span class="comment">//遍历告警列表</span></span><br><span class="line">		<span class="keyword">for</span> _, a := <span class="keyword">range</span> alerts &#123;</span><br><span class="line">			<span class="keyword">select</span> &#123;</span><br><span class="line">                <span class="comment">//将告警信息放入通道ch中</span></span><br><span class="line">			<span class="keyword">case</span> ch &lt;- a:</span><br><span class="line">			<span class="keyword">case</span> &lt;-done:</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		&lt;-done</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="comment">//构建告警信息迭代器</span></span><br><span class="line">	<span class="keyword">return</span> provider.NewAlertIterator(ch, done, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewAlertIterator returns a new AlertIterator based on the generic alertIterator type</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewAlertIterator</span><span class="params">(ch &lt;-<span class="keyword">chan</span> *types.Alert, done <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, err error)</span> <span class="title">AlertIterator</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;alertIterator&#123;</span><br><span class="line">		ch:   ch,</span><br><span class="line">		done: done,</span><br><span class="line">		err:  err,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>run方法中，对告警信息的处理分为4步：获取告警信息，告警路由匹配，告警信息处理，清除告警信息为空的aggrGroup。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *Dispatcher)</span> <span class="title">run</span><span class="params">(it provider.AlertIterator)</span></span> &#123;</span><br><span class="line">	cleanup := time.NewTicker(<span class="number">30</span> * time.Second)</span><br><span class="line">	<span class="keyword">defer</span> cleanup.Stop()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">defer</span> it.Close()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> alert, ok := &lt;-it.Next():</span><br><span class="line">			<span class="keyword">if</span> !ok &#123;</span><br><span class="line">				<span class="comment">// Iterator exhausted for some reason.</span></span><br><span class="line">				<span class="keyword">if</span> err := it.Err(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">					log.Errorf(<span class="string">"Error on alert update: %s"</span>, err)</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			d.log.With(<span class="string">"alert"</span>, alert).Debug(<span class="string">"Received alert"</span>)</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Log errors but keep trying.</span></span><br><span class="line">			<span class="keyword">if</span> err := it.Err(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">				log.Errorf(<span class="string">"Error on alert update: %s"</span>, err)</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//告警信息路由匹配</span></span><br><span class="line">			<span class="keyword">for</span> _, r := <span class="keyword">range</span> d.route.Match(alert.Labels) &#123;</span><br><span class="line">				d.processAlert(alert, r)</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> &lt;-cleanup.C:</span><br><span class="line">			d.mtx.Lock()</span><br><span class="line">			<span class="comment">//每隔30s清除为空的告警组</span></span><br><span class="line">			<span class="keyword">for</span> _, groups := <span class="keyword">range</span> d.aggrGroups &#123;</span><br><span class="line">				<span class="keyword">for</span> _, ag := <span class="keyword">range</span> groups &#123;</span><br><span class="line">					<span class="keyword">if</span> ag.empty() &#123;</span><br><span class="line">						ag.stop()</span><br><span class="line">						<span class="built_in">delete</span>(groups, ag.fingerprint())</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			d.mtx.Unlock()</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> &lt;-d.ctx.Done():</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>流程：</p>
<p><img src="/images/1572418287763.png" alt="1572418287763"></p>
<p>告警匹配：</p>
<p>AlertManager以路由匹配方式实现了告警分组，不同分组下的告警可以使用各不同的告警接受方式，告警组等待时间，告警组发送间隔，重复告警发送间隔。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Match does a depth-first left-to-right search through the route tree</span></span><br><span class="line"><span class="comment">// and returns the matching routing nodes.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Route)</span> <span class="title">Match</span><span class="params">(lset model.LabelSet)</span> []*<span class="title">Route</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> !r.Matchers.Match(lset) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> all []*Route</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> _, cr := <span class="keyword">range</span> r.Routes &#123;</span><br><span class="line">		matches := cr.Match(lset)</span><br><span class="line"></span><br><span class="line">		all = <span class="built_in">append</span>(all, matches...)</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> matches != <span class="literal">nil</span> &amp;&amp; !cr.Continue &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// If no child nodes were matches, the current node itself is a match.</span></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(all) == <span class="number">0</span> &#123;</span><br><span class="line">		all = <span class="built_in">append</span>(all, r)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> all</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>告警处理：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// processAlert determines in which aggregation group the alert falls</span></span><br><span class="line"><span class="comment">// and insert it.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *Dispatcher)</span> <span class="title">processAlert</span><span class="params">(alert *types.Alert, route *Route)</span></span> &#123;</span><br><span class="line">	group := model.LabelSet&#123;&#125;</span><br><span class="line">	<span class="comment">//获取分组的维度和纬度值</span></span><br><span class="line">	<span class="keyword">for</span> ln, lv := <span class="keyword">range</span> alert.Labels &#123;</span><br><span class="line">		<span class="keyword">if</span> _, ok := route.RouteOpts.GroupBy[ln]; ok &#123;</span><br><span class="line">			group[ln] = lv</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fp := group.Fingerprint()</span><br><span class="line"></span><br><span class="line">	d.mtx.Lock()</span><br><span class="line">	groups, ok := d.aggrGroups[route]</span><br><span class="line">    <span class="comment">//判断是否需要新建告警组</span></span><br><span class="line">	<span class="keyword">if</span> !ok &#123;</span><br><span class="line">		groups = <span class="keyword">map</span>[model.Fingerprint]*aggrGroup&#123;&#125;</span><br><span class="line">		d.aggrGroups[route] = groups</span><br><span class="line">	&#125;</span><br><span class="line">	d.mtx.Unlock()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// If the group does not exist, create it.</span></span><br><span class="line">	ag, ok := groups[fp]</span><br><span class="line">    <span class="comment">//判断是否新建路由组</span></span><br><span class="line">	<span class="keyword">if</span> !ok &#123;</span><br><span class="line">		ag = newAggrGroup(d.ctx, group, route, d.timeout)</span><br><span class="line">		groups[fp] = ag</span><br><span class="line">		<span class="comment">//启动告警组</span></span><br><span class="line">		<span class="keyword">go</span> ag.run(<span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context, alerts ...*types.Alert)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">			_, _, err := d.stage.Exec(ctx, alerts...)</span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				log.Errorf(<span class="string">"Notify for %d alerts failed: %s"</span>, <span class="built_in">len</span>(alerts), err)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> err == <span class="literal">nil</span></span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ag.insert(alert)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>run方法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ag *aggrGroup)</span> <span class="title">run</span><span class="params">(nf notifyFunc)</span></span> &#123;</span><br><span class="line">	ag.done = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">defer</span> <span class="built_in">close</span>(ag.done)</span><br><span class="line">	<span class="keyword">defer</span> ag.next.Stop()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> now := &lt;-ag.next.C:</span><br><span class="line">			<span class="comment">// Give the notifcations time until the next flush to</span></span><br><span class="line">			<span class="comment">// finish before terminating them.</span></span><br><span class="line">			ctx, cancel := context.WithTimeout(ag.ctx, ag.timeout(ag.opts.GroupInterval))</span><br><span class="line"></span><br><span class="line">			<span class="comment">// The now time we retrieve from the ticker is the only reliable</span></span><br><span class="line">			<span class="comment">// point of time reference for the subsequent notification pipeline.</span></span><br><span class="line">			<span class="comment">// Calculating the current time directly is prone to flaky behavior,</span></span><br><span class="line">			<span class="comment">// which usually only becomes apparent in tests.</span></span><br><span class="line">            <span class="comment">//记录告警开始时间</span></span><br><span class="line">			ctx = notify.WithNow(ctx, now)</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Populate context with information needed along the pipeline.</span></span><br><span class="line">			ctx = notify.WithGroupKey(ctx, ag.GroupKey())</span><br><span class="line">			ctx = notify.WithGroupLabels(ctx, ag.labels)</span><br><span class="line">			ctx = notify.WithReceiverName(ctx, ag.opts.Receiver)</span><br><span class="line">			ctx = notify.WithRepeatInterval(ctx, ag.opts.RepeatInterval)</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Wait the configured interval before calling flush again.</span></span><br><span class="line">			ag.mtx.Lock()</span><br><span class="line">			ag.next.Reset(ag.opts.GroupInterval)</span><br><span class="line">			ag.mtx.Unlock()</span><br><span class="line"></span><br><span class="line">			ag.flush(<span class="function"><span class="keyword">func</span><span class="params">(alerts ...*types.Alert)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">				<span class="keyword">return</span> nf(ctx, alerts...)</span><br><span class="line">			&#125;)</span><br><span class="line"></span><br><span class="line">			cancel()</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> &lt;-ag.ctx.Done():</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>flush方法中对告警信息进行两次复制，并分别将其缓存到alerts和alertsSlice中，告警信息通过传入的参数notify再次告警通知，之后再告警列表中删除过期的告警。</p>
<p>flush方法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// flush sends notifications for all new alerts.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ag *aggrGroup)</span> <span class="title">flush</span><span class="params">(notify <span class="keyword">func</span>(...*types.Alert)</span> <span class="title">bool</span>)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> ag.empty() &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	ag.mtx.Lock()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> (</span><br><span class="line">		alerts      = <span class="built_in">make</span>(<span class="keyword">map</span>[model.Fingerprint]*types.Alert, <span class="built_in">len</span>(ag.alerts))</span><br><span class="line">		alertsSlice = <span class="built_in">make</span>([]*types.Alert, <span class="number">0</span>, <span class="built_in">len</span>(ag.alerts))</span><br><span class="line">	)</span><br><span class="line">	<span class="keyword">for</span> fp, alert := <span class="keyword">range</span> ag.alerts &#123;</span><br><span class="line">		alerts[fp] = alert</span><br><span class="line">		alertsSlice = <span class="built_in">append</span>(alertsSlice, alert)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ag.mtx.Unlock()</span><br><span class="line"></span><br><span class="line">	ag.log.Debugln(<span class="string">"flushing"</span>, alertsSlice)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> notify(alertsSlice...) &#123;</span><br><span class="line">		ag.mtx.Lock()</span><br><span class="line">		<span class="keyword">for</span> fp, a := <span class="keyword">range</span> alerts &#123;</span><br><span class="line">			<span class="comment">// Only delete if the fingerprint has not been inserted</span></span><br><span class="line">			<span class="comment">// again since we notified about it.</span></span><br><span class="line">			<span class="keyword">if</span> a.Resolved() &amp;&amp; ag.alerts[fp] == a &#123;</span><br><span class="line">				<span class="built_in">delete</span>(ag.alerts, fp)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		ag.hasSent = <span class="literal">true</span></span><br><span class="line">		ag.mtx.Unlock()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>告警的过期时间由alertmanager.yml配置文件中的resolve_timeout配置项指定，默认5m.</p>
<p>flush方法的notify参数为func(…*types.Alert) bool类型，而notify方法最终会调用d.stage.Exec进行告警处理。</p>
<p>主要流程：</p>
<p><img src="/images/1572418713584.png" alt="1572418713584"></p>
<p>告警通知：</p>
<p>主要流程：</p>
<p>1）main方法中调用notify.BuildPipeline方法生成RoutingStage，并作为参数传递到dispatcher的NewDispatcher方法中，从而完成调度器Dispatcher的构建，并将RoutingStage赋值给调度器成stage.</p>
<p>2）processAlerts定义匿名回调方法func(ctx context.Context, alerts … *types.Alert) bool 再匿名方法的实现调用d.stage.Exec(ctx, alerts…)发送告警。</p>
<p>BuildPipeline构建一个执行的调用链，该链有RoutingStage，MultiStage,FanoutStage, inhibitStage, SilenceStage, WaitStage, DehupStage等多阶段。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// BuildPipeline builds a map of receivers to Stages.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BuildPipeline</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">	confs []*config.Receiver,</span></span></span><br><span class="line"><span class="function"><span class="params">	tmpl *template.Template,</span></span></span><br><span class="line"><span class="function"><span class="params">	wait <span class="keyword">func</span>()</span> <span class="title">time</span>.<span class="title">Duration</span>,</span></span><br><span class="line">	inhibitor *inhibit.Inhibitor,</span><br><span class="line">	silences *silence.Silences,</span><br><span class="line">	notificationLog nflog.Log,</span><br><span class="line">	marker types.Marker,</span><br><span class="line">) RoutingStage &#123;</span><br><span class="line">	rs := RoutingStage&#123;&#125;</span><br><span class="line"></span><br><span class="line">	is := NewInhibitStage(inhibitor, marker)</span><br><span class="line">	ss := NewSilenceStage(silences, marker)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> _, rc := <span class="keyword">range</span> confs &#123;</span><br><span class="line">		rs[rc.Name] = MultiStage&#123;is, ss, createStage(rc, tmpl, wait, notificationLog)&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> rs</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>createStage方法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// createStage creates a pipeline of stages for a receiver.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">createStage</span><span class="params">(rc *config.Receiver, tmpl *template.Template, wait <span class="keyword">func</span>()</span> <span class="title">time</span>.<span class="title">Duration</span>, <span class="title">notificationLog</span> <span class="title">nflog</span>.<span class="title">Log</span>) <span class="title">Stage</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> fs FanoutStage</span><br><span class="line">	<span class="keyword">for</span> _, i := <span class="keyword">range</span> BuildReceiverIntegrations(rc, tmpl) &#123;</span><br><span class="line">		recv := &amp;nflogpb.Receiver&#123;</span><br><span class="line">			GroupName:   rc.Name,</span><br><span class="line">			Integration: i.name,</span><br><span class="line">			Idx:         <span class="keyword">uint32</span>(i.idx),</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">var</span> s MultiStage</span><br><span class="line">		s = <span class="built_in">append</span>(s, NewWaitStage(wait))</span><br><span class="line">		s = <span class="built_in">append</span>(s, NewDedupStage(notificationLog, recv, i.conf.SendResolved()))</span><br><span class="line">		s = <span class="built_in">append</span>(s, NewRetryStage(i))</span><br><span class="line">		s = <span class="built_in">append</span>(s, NewSetNotifiesStage(notificationLog, recv))</span><br><span class="line"></span><br><span class="line">		fs = <span class="built_in">append</span>(fs, s)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> fs</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>BuildReceiverIntegrations方法主要用于构建告警接收器对应的Notifier，兵器再alertmanager.yml配置文件中的每种告警接收器，可以定义多种Notifier。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// BuildReceiverIntegrations builds a list of integration notifiers off of a</span></span><br><span class="line"><span class="comment">// receivers config.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BuildReceiverIntegrations</span><span class="params">(nc *config.Receiver, tmpl *template.Template)</span> []<span class="title">Integration</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> (</span><br><span class="line">		integrations []Integration</span><br><span class="line">		add          = <span class="function"><span class="keyword">func</span><span class="params">(name <span class="keyword">string</span>, i <span class="keyword">int</span>, n Notifier, nc notifierConfig)</span></span> &#123;</span><br><span class="line">			integrations = <span class="built_in">append</span>(integrations, Integration&#123;</span><br><span class="line">				notifier: n,</span><br><span class="line">				conf:     nc,</span><br><span class="line">				name:     name,</span><br><span class="line">				idx:      i,</span><br><span class="line">			&#125;)</span><br><span class="line">		&#125;</span><br><span class="line">	)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i, c := <span class="keyword">range</span> nc.WebhookConfigs &#123;</span><br><span class="line">		n := NewWebhook(c, tmpl)</span><br><span class="line">		add(<span class="string">"webhook"</span>, i, n, c)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> i, c := <span class="keyword">range</span> nc.EmailConfigs &#123;</span><br><span class="line">		n := NewEmail(c, tmpl)</span><br><span class="line">		add(<span class="string">"email"</span>, i, n, c)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> i, c := <span class="keyword">range</span> nc.PagerdutyConfigs &#123;</span><br><span class="line">		n := NewPagerDuty(c, tmpl)</span><br><span class="line">		add(<span class="string">"pagerduty"</span>, i, n, c)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> i, c := <span class="keyword">range</span> nc.OpsGenieConfigs &#123;</span><br><span class="line">		n := NewOpsGenie(c, tmpl)</span><br><span class="line">		add(<span class="string">"opsgenie"</span>, i, n, c)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> i, c := <span class="keyword">range</span> nc.SlackConfigs &#123;</span><br><span class="line">		n := NewSlack(c, tmpl)</span><br><span class="line">		add(<span class="string">"slack"</span>, i, n, c)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> i, c := <span class="keyword">range</span> nc.HipchatConfigs &#123;</span><br><span class="line">		n := NewHipchat(c, tmpl)</span><br><span class="line">		add(<span class="string">"hipchat"</span>, i, n, c)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> i, c := <span class="keyword">range</span> nc.VictorOpsConfigs &#123;</span><br><span class="line">		n := NewVictorOps(c, tmpl)</span><br><span class="line">		add(<span class="string">"victorops"</span>, i, n, c)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> i, c := <span class="keyword">range</span> nc.PushoverConfigs &#123;</span><br><span class="line">		n := NewPushover(c, tmpl)</span><br><span class="line">		add(<span class="string">"pushover"</span>, i, n, c)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> integrations</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以webhook类型Notifier为列，数据格式化之后，以post方式发送告警信息。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Notify implements the Notifier interface.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *Webhook)</span> <span class="title">Notify</span><span class="params">(ctx context.Context, alerts ...*types.Alert)</span> <span class="params">(<span class="keyword">bool</span>, error)</span></span> &#123;</span><br><span class="line">	data := w.tmpl.Data(receiverName(ctx), groupLabels(ctx), alerts...)</span><br><span class="line"></span><br><span class="line">	groupKey, ok := GroupKey(ctx)</span><br><span class="line">	<span class="keyword">if</span> !ok &#123;</span><br><span class="line">		log.Errorf(<span class="string">"group key missing"</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	msg := &amp;WebhookMessage&#123;</span><br><span class="line">		Version:  <span class="string">"4"</span>,</span><br><span class="line">		Data:     data,</span><br><span class="line">		GroupKey: groupKey,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> buf bytes.Buffer</span><br><span class="line">	<span class="keyword">if</span> err := json.NewEncoder(&amp;buf).Encode(msg); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	req, err := http.NewRequest(<span class="string">"POST"</span>, w.URL, &amp;buf)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	req.Header.Set(<span class="string">"Content-Type"</span>, contentTypeJSON)</span><br><span class="line">	req.Header.Set(<span class="string">"User-Agent"</span>, userAgentHeader)</span><br><span class="line"></span><br><span class="line">	resp, err := ctxhttp.Do(ctx, http.DefaultClient, req)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	resp.Body.Close()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> w.retry(resp.StatusCode)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用链的执行流程：</p>
<p><img src="/images/1572419260049.png" alt="1572419260049"></p>
<p>RoutingStage阶段的Exec方法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Exec implements the Stage interface.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rs RoutingStage)</span> <span class="title">Exec</span><span class="params">(ctx context.Context, alerts ...*types.Alert)</span> <span class="params">(context.Context, []*types.Alert, error)</span></span> &#123;</span><br><span class="line">	receiver, ok := ReceiverName(ctx)</span><br><span class="line">	<span class="keyword">if</span> !ok &#123;</span><br><span class="line">		<span class="keyword">return</span> ctx, <span class="literal">nil</span>, fmt.Errorf(<span class="string">"receiver missing"</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	s, ok := rs[receiver]</span><br><span class="line">	<span class="keyword">if</span> !ok &#123;</span><br><span class="line">		<span class="keyword">return</span> ctx, <span class="literal">nil</span>, fmt.Errorf(<span class="string">"stage for receiver missing"</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> s.Exec(ctx, alerts...)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Exec attempts to execute all stages concurrently and discards the results.</span></span><br><span class="line"><span class="comment">// It returns its input alerts and a types.MultiError if one or more stages fail.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(fs FanoutStage)</span> <span class="title">Exec</span><span class="params">(ctx context.Context, alerts ...*types.Alert)</span> <span class="params">(context.Context, []*types.Alert, error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> (</span><br><span class="line">		wg sync.WaitGroup</span><br><span class="line">		me types.MultiError</span><br><span class="line">	)</span><br><span class="line">	wg.Add(<span class="built_in">len</span>(fs))</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> _, s := <span class="keyword">range</span> fs &#123;</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(s Stage)</span></span> &#123;</span><br><span class="line">			<span class="keyword">if</span> _, _, err := s.Exec(ctx, alerts...); err != <span class="literal">nil</span> &#123;</span><br><span class="line">				me.Add(err)</span><br><span class="line">				log.Errorf(<span class="string">"Error on notify: %s"</span>, err)</span><br><span class="line">			&#125;</span><br><span class="line">			wg.Done()</span><br><span class="line">		&#125;(s)</span><br><span class="line">	&#125;</span><br><span class="line">	wg.Wait()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> me.Len() &gt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> ctx, alerts, &amp;me</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ctx, alerts, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Exec implements the Stage interface.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ms MultiStage)</span> <span class="title">Exec</span><span class="params">(ctx context.Context, alerts ...*types.Alert)</span> <span class="params">(context.Context, []*types.Alert, error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> err error</span><br><span class="line">	<span class="keyword">for</span> _, s := <span class="keyword">range</span> ms &#123;</span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(alerts) == <span class="number">0</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> ctx, <span class="literal">nil</span>, <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		ctx, alerts, err = s.Exec(ctx, alerts...)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> ctx, <span class="literal">nil</span>, err</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ctx, alerts, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>告警抑制的配置，inhibit_rules配置项目：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Exec implements the Stage interface.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *InhibitStage)</span> <span class="title">Exec</span><span class="params">(ctx context.Context, alerts ...*types.Alert)</span> <span class="params">(context.Context, []*types.Alert, error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> filtered []*types.Alert</span><br><span class="line">	<span class="keyword">for</span> _, a := <span class="keyword">range</span> alerts &#123;</span><br><span class="line">		_, ok := n.marker.Inhibited(a.Fingerprint())</span><br><span class="line">		<span class="comment">// TODO(fabxc): increment total alerts counter.</span></span><br><span class="line">		<span class="comment">// Do not send the alert if the silencer mutes it.</span></span><br><span class="line">		<span class="keyword">if</span> !n.muter.Mutes(a.Labels) &#123;</span><br><span class="line">			<span class="comment">// TODO(fabxc): increment muted alerts counter.</span></span><br><span class="line">			filtered = <span class="built_in">append</span>(filtered, a)</span><br><span class="line">			<span class="comment">// Store whether a previously inhibited alert is firing again.</span></span><br><span class="line">			a.WasInhibited = ok</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ctx, filtered, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>告警静音：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Exec implements the Stage interface.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *SilenceStage)</span> <span class="title">Exec</span><span class="params">(ctx context.Context, alerts ...*types.Alert)</span> <span class="params">(context.Context, []*types.Alert, error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> filtered []*types.Alert</span><br><span class="line">	<span class="keyword">for</span> _, a := <span class="keyword">range</span> alerts &#123;</span><br><span class="line">		_, ok := n.marker.Silenced(a.Fingerprint())</span><br><span class="line">		<span class="comment">// TODO(fabxc): increment total alerts counter.</span></span><br><span class="line">		<span class="comment">// Do not send the alert if the silencer mutes it.</span></span><br><span class="line">		sils, err := n.silences.Query(</span><br><span class="line">			silence.QState(silence.StateActive),</span><br><span class="line">			silence.QMatches(a.Labels),</span><br><span class="line">		)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			log.Errorf(<span class="string">"Querying silences failed: %s"</span>, err)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(sils) == <span class="number">0</span> &#123;</span><br><span class="line">			<span class="comment">// TODO(fabxc): increment muted alerts counter.</span></span><br><span class="line">			filtered = <span class="built_in">append</span>(filtered, a)</span><br><span class="line">			n.marker.SetSilenced(a.Labels.Fingerprint())</span><br><span class="line">			<span class="comment">// Store whether a previously silenced alert is firing again.</span></span><br><span class="line">			a.WasSilenced = ok</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			ids := <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="built_in">len</span>(sils))</span><br><span class="line">			<span class="keyword">for</span> i, s := <span class="keyword">range</span> sils &#123;</span><br><span class="line">				ids[i] = s.Id</span><br><span class="line">			&#125;</span><br><span class="line">			n.marker.SetSilenced(a.Labels.Fingerprint(), ids...)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ctx, filtered, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Pushgateway"><a href="#Pushgateway" class="headerlink" title="Pushgateway"></a>Pushgateway</h2><p>pushgateway主要作用是允许临时任务和批作业向prometheus公开指标数据。主要用于短期的 jobs。由于这类 jobs 存在时间较短，可能在 Prometheus 来 pull 之前就消失了。为此，这次 jobs 可以直接向 Prometheus server 端推送它们的 metrics。这种方式主要用于服务层面的 metrics，对于机器层面的 metrices，需要使用 node exporter。</p>
<p>push gateway的代码逻辑都再main函数里面：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> (</span><br><span class="line">		app = kingpin.New(filepath.Base(os.Args[<span class="number">0</span>]), <span class="string">"The Pushgateway"</span>)</span><br><span class="line"></span><br><span class="line">		listenAddress       = app.Flag(<span class="string">"web.listen-address"</span>, <span class="string">"Address to listen on for the web interface, API, and telemetry."</span>).Default(<span class="string">":9091"</span>).String()</span><br><span class="line">		metricsPath         = app.Flag(<span class="string">"web.telemetry-path"</span>, <span class="string">"Path under which to expose metrics."</span>).Default(<span class="string">"/metrics"</span>).String()</span><br><span class="line">		externalURL         = app.Flag(<span class="string">"web.external-url"</span>, <span class="string">"The URL under which the Pushgateway is externally reachable."</span>).Default(<span class="string">""</span>).URL()</span><br><span class="line">		routePrefix         = app.Flag(<span class="string">"web.route-prefix"</span>, <span class="string">"Prefix for the internal routes of web endpoints. Defaults to the path of --web.external-url."</span>).Default(<span class="string">""</span>).String()</span><br><span class="line">		enableLifeCycle     = app.Flag(<span class="string">"web.enable-lifecycle"</span>, <span class="string">"Enable shutdown via HTTP request."</span>).Default(<span class="string">"false"</span>).Bool()</span><br><span class="line">		enableAdminAPI      = app.Flag(<span class="string">"web.enable-admin-api"</span>, <span class="string">"Enable API endpoints for admin control actions."</span>).Default(<span class="string">"false"</span>).Bool()</span><br><span class="line">		persistenceFile     = app.Flag(<span class="string">"persistence.file"</span>, <span class="string">"File to persist metrics. If empty, metrics are only kept in memory."</span>).Default(<span class="string">""</span>).String()</span><br><span class="line">		persistenceInterval = app.Flag(<span class="string">"persistence.interval"</span>, <span class="string">"The minimum interval at which to write out the persistence file."</span>).Default(<span class="string">"5m"</span>).Duration()</span><br><span class="line">		promlogConfig       = promlog.Config&#123;&#125;</span><br><span class="line">	)</span><br><span class="line">	promlogflag.AddFlags(app, &amp;promlogConfig)</span><br><span class="line">	app.Version(version.Print(<span class="string">"pushgateway"</span>))</span><br><span class="line">	app.HelpFlag.Short(<span class="string">'h'</span>)</span><br><span class="line">	kingpin.MustParse(app.Parse(os.Args[<span class="number">1</span>:]))</span><br><span class="line">	logger := promlog.New(&amp;promlogConfig)</span><br><span class="line"></span><br><span class="line">	*routePrefix = computeRoutePrefix(*routePrefix, *externalURL)</span><br><span class="line">	externalPathPrefix := computeRoutePrefix(<span class="string">""</span>, *externalURL)</span><br><span class="line"></span><br><span class="line">	level.Info(logger).Log(<span class="string">"msg"</span>, <span class="string">"starting pushgateway"</span>, <span class="string">"version"</span>, version.Info())</span><br><span class="line">	level.Info(logger).Log(<span class="string">"build_context"</span>, version.BuildContext())</span><br><span class="line">	level.Debug(logger).Log(<span class="string">"msg"</span>, <span class="string">"external URL"</span>, <span class="string">"url"</span>, *externalURL)</span><br><span class="line">	level.Debug(logger).Log(<span class="string">"msg"</span>, <span class="string">"path prefix used externally"</span>, <span class="string">"path"</span>, externalPathPrefix)</span><br><span class="line">	level.Debug(logger).Log(<span class="string">"msg"</span>, <span class="string">"path prefix for internal routing"</span>, <span class="string">"path"</span>, *routePrefix)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// flags is used to show command line flags on the status page.</span></span><br><span class="line">	<span class="comment">// Kingpin default flags are excluded as they would be confusing.</span></span><br><span class="line">	flags := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;&#125;</span><br><span class="line">	boilerplateFlags := kingpin.New(<span class="string">""</span>, <span class="string">""</span>).Version(<span class="string">""</span>)</span><br><span class="line">	<span class="keyword">for</span> _, f := <span class="keyword">range</span> app.Model().Flags &#123;</span><br><span class="line">		<span class="keyword">if</span> boilerplateFlags.GetFlag(f.Name) == <span class="literal">nil</span> &#123;</span><br><span class="line">			flags[f.Name] = f.Value.String()</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ms := storage.NewDiskMetricStore(*persistenceFile, *persistenceInterval, prometheus.DefaultGatherer, logger)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Create a Gatherer combining the DefaultGatherer and the metrics from the metric store.</span></span><br><span class="line">	g := prometheus.Gatherers&#123;</span><br><span class="line">		prometheus.DefaultGatherer,</span><br><span class="line">		prometheus.GathererFunc(<span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="params">([]*dto.MetricFamily, error)</span></span> &#123; <span class="keyword">return</span> ms.GetMetricFamilies(), <span class="literal">nil</span> &#125;),</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	r := httprouter.New()</span><br><span class="line">	r.Handler(<span class="string">"GET"</span>, *routePrefix+<span class="string">"/-/healthy"</span>, handler.Healthy(ms))</span><br><span class="line">	r.Handler(<span class="string">"GET"</span>, *routePrefix+<span class="string">"/-/ready"</span>, handler.Ready(ms))</span><br><span class="line">	r.Handler(</span><br><span class="line">		<span class="string">"GET"</span>, path.Join(*routePrefix, *metricsPath),</span><br><span class="line">		promhttp.HandlerFor(g, promhttp.HandlerOpts&#123;</span><br><span class="line">			ErrorLog: logFunc(level.Error(logger).Log),</span><br><span class="line">		&#125;),</span><br><span class="line">	)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> *enableAdminAPI &#123;</span><br><span class="line">		<span class="comment">// To be consistent with Prometheus codebase and provide endpoint versioning, we use the same path</span></span><br><span class="line">		<span class="comment">// as Prometheus for its admin endpoints, even if this may feel excesive for just one simple endpoint</span></span><br><span class="line">		<span class="comment">// this will likely change over time.</span></span><br><span class="line">		r.Handler(<span class="string">"PUT"</span>, *routePrefix+<span class="string">"/api/v1/admin/wipe"</span>, handler.WipeMetricStore(ms, logger))</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Handlers for pushing and deleting metrics.</span></span><br><span class="line">	pushAPIPath := *routePrefix + <span class="string">"/metrics"</span></span><br><span class="line">	<span class="keyword">for</span> _, suffix := <span class="keyword">range</span> []<span class="keyword">string</span>&#123;<span class="string">""</span>, handler.Base64Suffix&#125; &#123;</span><br><span class="line">		jobBase64Encoded := suffix == handler.Base64Suffix</span><br><span class="line">		r.PUT(pushAPIPath+<span class="string">"/job"</span>+suffix+<span class="string">"/:job/*labels"</span>, handler.Push(ms, <span class="literal">true</span>, jobBase64Encoded, logger))</span><br><span class="line">		r.POST(pushAPIPath+<span class="string">"/job"</span>+suffix+<span class="string">"/:job/*labels"</span>, handler.Push(ms, <span class="literal">false</span>, jobBase64Encoded, logger))</span><br><span class="line">		r.DELETE(pushAPIPath+<span class="string">"/job"</span>+suffix+<span class="string">"/:job/*labels"</span>, handler.Delete(ms, jobBase64Encoded, logger))</span><br><span class="line">		r.PUT(pushAPIPath+<span class="string">"/job"</span>+suffix+<span class="string">"/:job"</span>, handler.Push(ms, <span class="literal">true</span>, jobBase64Encoded, logger))</span><br><span class="line">		r.POST(pushAPIPath+<span class="string">"/job"</span>+suffix+<span class="string">"/:job"</span>, handler.Push(ms, <span class="literal">false</span>, jobBase64Encoded, logger))</span><br><span class="line">		r.DELETE(pushAPIPath+<span class="string">"/job"</span>+suffix+<span class="string">"/:job"</span>, handler.Delete(ms, jobBase64Encoded, logger))</span><br><span class="line">	&#125;</span><br><span class="line">	r.Handler(<span class="string">"GET"</span>, *routePrefix+<span class="string">"/static/*filepath"</span>, handler.Static(asset.Assets, *routePrefix))</span><br><span class="line"></span><br><span class="line">	statusHandler := handler.Status(ms, asset.Assets, flags, externalPathPrefix, logger)</span><br><span class="line">	r.Handler(<span class="string">"GET"</span>, *routePrefix+<span class="string">"/status"</span>, statusHandler)</span><br><span class="line">	r.Handler(<span class="string">"GET"</span>, *routePrefix+<span class="string">"/"</span>, statusHandler)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Re-enable pprof.</span></span><br><span class="line">	r.GET(*routePrefix+<span class="string">"/debug/pprof/*pprof"</span>, handlePprof)</span><br><span class="line"></span><br><span class="line">	level.Info(logger).Log(<span class="string">"listen_address"</span>, *listenAddress)</span><br><span class="line">	l, err := net.Listen(<span class="string">"tcp"</span>, *listenAddress)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		level.Error(logger).Log(<span class="string">"err"</span>, err)</span><br><span class="line">		os.Exit(<span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	quitCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">	quitHandler := http.HandlerFunc(<span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">		fmt.Fprintf(w, <span class="string">"Requesting termination... Goodbye!"</span>)</span><br><span class="line">		<span class="built_in">close</span>(quitCh)</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	forbiddenAPINotEnabled := http.HandlerFunc(<span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, _ *http.Request)</span></span> &#123;</span><br><span class="line">		w.WriteHeader(http.StatusForbidden)</span><br><span class="line">		w.Write([]<span class="keyword">byte</span>(<span class="string">"Lifecycle API is not enabled."</span>))</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> *enableLifeCycle &#123;</span><br><span class="line">		r.Handler(<span class="string">"PUT"</span>, *routePrefix+<span class="string">"/-/quit"</span>, quitHandler)</span><br><span class="line">		r.Handler(<span class="string">"POST"</span>, *routePrefix+<span class="string">"/-/quit"</span>, quitHandler)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		r.Handler(<span class="string">"PUT"</span>, *routePrefix+<span class="string">"/-/quit"</span>, forbiddenAPINotEnabled)</span><br><span class="line">		r.Handler(<span class="string">"POST"</span>, *routePrefix+<span class="string">"/-/quit"</span>, forbiddenAPINotEnabled)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	r.Handler(<span class="string">"GET"</span>, <span class="string">"/-/quit"</span>, http.HandlerFunc(<span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, _ *http.Request)</span></span> &#123;</span><br><span class="line">		w.WriteHeader(http.StatusMethodNotAllowed)</span><br><span class="line">		w.Write([]<span class="keyword">byte</span>(<span class="string">"Only POST or PUT requests allowed."</span>))</span><br><span class="line">	&#125;))</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> closeListenerOnQuit(l, quitCh, logger)</span><br><span class="line">	err = (&amp;http.Server&#123;Addr: *listenAddress, Handler: r&#125;).Serve(l)</span><br><span class="line">	level.Error(logger).Log(<span class="string">"msg"</span>, <span class="string">"HTTP server stopped"</span>, <span class="string">"err"</span>, err)</span><br><span class="line">	<span class="comment">// To give running connections a chance to submit their payload, we wait</span></span><br><span class="line">	<span class="comment">// for 1sec, but we don't want to wait long (e.g. until all connections</span></span><br><span class="line">	<span class="comment">// are done) to not delay the shutdown.</span></span><br><span class="line">	time.Sleep(time.Second)</span><br><span class="line">	<span class="keyword">if</span> err := ms.Shutdown(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		level.Error(logger).Log(<span class="string">"msg"</span>, <span class="string">"problem shutting down metric storage"</span>, <span class="string">"err"</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过push到接口metric传递数据到prometheus，push接口调用push函数去使用。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Push returns an http.Handler which accepts samples over HTTP and stores them</span></span><br><span class="line"><span class="comment">// in the MetricStore. If replace is true, all metrics for the job and instance</span></span><br><span class="line"><span class="comment">// given by the request are deleted before new ones are stored.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The returned handler is already instrumented for Prometheus.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Push</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">	ms storage.MetricStore, replace <span class="keyword">bool</span>, jobBase64Encoded <span class="keyword">bool</span>, logger log.Logger,</span></span></span><br><span class="line"><span class="function"><span class="params">)</span> <span class="title">func</span><span class="params">(http.ResponseWriter, *http.Request, httprouter.Params)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> ps httprouter.Params</span><br><span class="line">	<span class="keyword">var</span> mtx sync.Mutex <span class="comment">// Protects ps.</span></span><br><span class="line"></span><br><span class="line">	handler := http.HandlerFunc(<span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">		job := ps.ByName(<span class="string">"job"</span>)</span><br><span class="line">		<span class="keyword">if</span> jobBase64Encoded &#123;</span><br><span class="line">			<span class="keyword">var</span> err error</span><br><span class="line">			<span class="keyword">if</span> job, err = decodeBase64(job); err != <span class="literal">nil</span> &#123;</span><br><span class="line">				http.Error(w, fmt.Sprintf(<span class="string">"invalid base64 encoding in job name %q: %v"</span>, ps.ByName(<span class="string">"job"</span>), err), http.StatusBadRequest)</span><br><span class="line">				level.Debug(logger).Log(<span class="string">"msg"</span>, <span class="string">"invalid base64 encoding in job name"</span>, <span class="string">"job"</span>, ps.ByName(<span class="string">"job"</span>), <span class="string">"err"</span>, err.Error())</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		labelsString := ps.ByName(<span class="string">"labels"</span>)</span><br><span class="line">		mtx.Unlock()</span><br><span class="line"></span><br><span class="line">		labels, err := splitLabels(labelsString)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			http.Error(w, err.Error(), http.StatusBadRequest)</span><br><span class="line">			level.Debug(logger).Log(<span class="string">"msg"</span>, <span class="string">"failed to parse URL"</span>, <span class="string">"url"</span>, labelsString, <span class="string">"err"</span>, err.Error())</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> job == <span class="string">""</span> &#123;</span><br><span class="line">			http.Error(w, <span class="string">"job name is required"</span>, http.StatusBadRequest)</span><br><span class="line">			level.Debug(logger).Log(<span class="string">"msg"</span>, <span class="string">"job name is required"</span>)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		labels[<span class="string">"job"</span>] = job</span><br><span class="line"></span><br><span class="line">		<span class="keyword">var</span> metricFamilies <span class="keyword">map</span>[<span class="keyword">string</span>]*dto.MetricFamily</span><br><span class="line">		ctMediatype, ctParams, ctErr := mime.ParseMediaType(r.Header.Get(<span class="string">"Content-Type"</span>))</span><br><span class="line">		<span class="keyword">if</span> ctErr == <span class="literal">nil</span> &amp;&amp; ctMediatype == <span class="string">"application/vnd.google.protobuf"</span> &amp;&amp;</span><br><span class="line">			ctParams[<span class="string">"encoding"</span>] == <span class="string">"delimited"</span> &amp;&amp;</span><br><span class="line">			ctParams[<span class="string">"proto"</span>] == <span class="string">"io.prometheus.client.MetricFamily"</span> &#123;</span><br><span class="line">			metricFamilies = <span class="keyword">map</span>[<span class="keyword">string</span>]*dto.MetricFamily&#123;&#125;</span><br><span class="line">			<span class="keyword">for</span> &#123;</span><br><span class="line">				mf := &amp;dto.MetricFamily&#123;&#125;</span><br><span class="line">				<span class="keyword">if</span> _, err = pbutil.ReadDelimited(r.Body, mf); err != <span class="literal">nil</span> &#123;</span><br><span class="line">					<span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">						err = <span class="literal">nil</span></span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">break</span></span><br><span class="line">				&#125;</span><br><span class="line">				metricFamilies[mf.GetName()] = mf</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// We could do further content-type checks here, but the</span></span><br><span class="line">			<span class="comment">// fallback for now will anyway be the text format</span></span><br><span class="line">			<span class="comment">// version 0.0.4, so just go for it and see if it works.</span></span><br><span class="line">			<span class="keyword">var</span> parser expfmt.TextParser</span><br><span class="line">			metricFamilies, err = parser.TextToMetricFamilies(r.Body)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			http.Error(w, err.Error(), http.StatusBadRequest)</span><br><span class="line">			level.Debug(logger).Log(<span class="string">"msg"</span>, <span class="string">"failed to parse text"</span>, <span class="string">"err"</span>, err.Error())</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		now := time.Now()</span><br><span class="line">		errCh := <span class="built_in">make</span>(<span class="keyword">chan</span> error, <span class="number">1</span>)</span><br><span class="line">		errReceived := <span class="literal">false</span></span><br><span class="line">		ms.SubmitWriteRequest(storage.WriteRequest&#123;</span><br><span class="line">			Labels:         labels,</span><br><span class="line">			Timestamp:      now,</span><br><span class="line">			MetricFamilies: metricFamilies,</span><br><span class="line">			Replace:        replace,</span><br><span class="line">			Done:           errCh,</span><br><span class="line">		&#125;)</span><br><span class="line">		<span class="keyword">for</span> err := <span class="keyword">range</span> errCh &#123;</span><br><span class="line">			<span class="comment">// Send only first error via HTTP, but log all of them.</span></span><br><span class="line">			<span class="comment">// TODO(beorn): Consider sending all errors once we</span></span><br><span class="line">			<span class="comment">// have a use case. (Currently, at most one error is</span></span><br><span class="line">			<span class="comment">// produced.)</span></span><br><span class="line">			<span class="keyword">if</span> !errReceived &#123;</span><br><span class="line">				http.Error(</span><br><span class="line">					w,</span><br><span class="line">					fmt.Sprintf(<span class="string">"pushed metrics are invalid or inconsistent with existing metrics: %v"</span>, err),</span><br><span class="line">					http.StatusBadRequest,</span><br><span class="line">				)</span><br><span class="line">			&#125;</span><br><span class="line">			level.Error(logger).Log(</span><br><span class="line">				<span class="string">"msg"</span>, <span class="string">"pushed metrics are invalid or inconsistent with existing metrics"</span>,</span><br><span class="line">				<span class="string">"method"</span>, r.Method,</span><br><span class="line">				<span class="string">"source"</span>, r.RemoteAddr,</span><br><span class="line">				<span class="string">"err"</span>, err.Error(),</span><br><span class="line">			)</span><br><span class="line">			errReceived = <span class="literal">true</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	instrumentedHandler := promhttp.InstrumentHandlerRequestSize(</span><br><span class="line">		httpPushSize, promhttp.InstrumentHandlerDuration(</span><br><span class="line">			httpPushDuration, promhttp.InstrumentHandlerCounter(</span><br><span class="line">				httpCnt.MustCurryWith(prometheus.Labels&#123;<span class="string">"handler"</span>: <span class="string">"push"</span>&#125;),</span><br><span class="line">				handler,</span><br><span class="line">			)))</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request, params httprouter.Params)</span></span> &#123;</span><br><span class="line">		mtx.Lock()</span><br><span class="line">		ps = params</span><br><span class="line">		instrumentedHandler.ServeHTTP(w, r)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>数据push完会放入pushgateway的缓存队列中存储，prometheus通过配置，采用pull的方式拉取数据获取指标。</p>
<h2 id="relabel"><a href="#relabel" class="headerlink" title="relabel"></a>relabel</h2><p>relabel功能主要是用于实现多数据中心的监控数据聚合。Relabel可以在Prometheus采集数据之前，通过Target实例的Metadata信息，动态重新写入Label的值。relabel可以对Target实例进行过滤和选择。</p>
<p>relabel实现过程：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Process returns a relabeled copy of the given label set. The relabel configurations</span></span><br><span class="line"><span class="comment">// are applied in order of input.</span></span><br><span class="line"><span class="comment">// If a label set is dropped, nil is returned.</span></span><br><span class="line"><span class="comment">// May return the input labelSet modified.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Process</span><span class="params">(labels model.LabelSet, cfgs ...*config.RelabelConfig)</span> <span class="title">model</span>.<span class="title">LabelSet</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> _, cfg := <span class="keyword">range</span> cfgs &#123;</span><br><span class="line">		labels = relabel(labels, cfg)</span><br><span class="line">		<span class="keyword">if</span> labels == <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> labels</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用process函数来处理，针对每个配置进行relabel操作。</p>
<p>relabel函数实现，relabel的类型有：RelabelDrop， RelabelKeep，RelabelReplace，RelabelLabelMap，RelabelLabelDrop，RelabelLabelKeep，RelabelHashMod</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">relabel</span><span class="params">(labels model.LabelSet, cfg *config.RelabelConfig)</span> <span class="title">model</span>.<span class="title">LabelSet</span></span> &#123;</span><br><span class="line">	values := <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="number">0</span>, <span class="built_in">len</span>(cfg.SourceLabels))</span><br><span class="line">	<span class="keyword">for</span> _, ln := <span class="keyword">range</span> cfg.SourceLabels &#123;</span><br><span class="line">		values = <span class="built_in">append</span>(values, <span class="keyword">string</span>(labels[ln]))</span><br><span class="line">	&#125;</span><br><span class="line">	val := strings.Join(values, cfg.Separator)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> cfg.Action &#123;</span><br><span class="line">	<span class="keyword">case</span> config.RelabelDrop:</span><br><span class="line">		<span class="keyword">if</span> cfg.Regex.MatchString(val) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">case</span> config.RelabelKeep:</span><br><span class="line">		<span class="keyword">if</span> !cfg.Regex.MatchString(val) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">case</span> config.RelabelReplace:</span><br><span class="line">		indexes := cfg.Regex.FindStringSubmatchIndex(val)</span><br><span class="line">		<span class="comment">// If there is no match no replacement must take place.</span></span><br><span class="line">		<span class="keyword">if</span> indexes == <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		target := model.LabelName(cfg.Regex.ExpandString([]<span class="keyword">byte</span>&#123;&#125;, cfg.TargetLabel, val, indexes))</span><br><span class="line">		<span class="keyword">if</span> !target.IsValid() &#123;</span><br><span class="line">			<span class="built_in">delete</span>(labels, model.LabelName(cfg.TargetLabel))</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		res := cfg.Regex.ExpandString([]<span class="keyword">byte</span>&#123;&#125;, cfg.Replacement, val, indexes)</span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(res) == <span class="number">0</span> &#123;</span><br><span class="line">			<span class="built_in">delete</span>(labels, model.LabelName(cfg.TargetLabel))</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		labels[target] = model.LabelValue(res)</span><br><span class="line">	<span class="keyword">case</span> config.RelabelHashMod:</span><br><span class="line">		mod := sum64(md5.Sum([]<span class="keyword">byte</span>(val))) % cfg.Modulus</span><br><span class="line">		labels[model.LabelName(cfg.TargetLabel)] = model.LabelValue(fmt.Sprintf(<span class="string">"%d"</span>, mod))</span><br><span class="line">	<span class="keyword">case</span> config.RelabelLabelMap:</span><br><span class="line">		out := <span class="built_in">make</span>(model.LabelSet, <span class="built_in">len</span>(labels))</span><br><span class="line">		<span class="comment">// Take a copy to avoid infinite loops.</span></span><br><span class="line">		<span class="keyword">for</span> ln, lv := <span class="keyword">range</span> labels &#123;</span><br><span class="line">			out[ln] = lv</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> ln, lv := <span class="keyword">range</span> labels &#123;</span><br><span class="line">			<span class="keyword">if</span> cfg.Regex.MatchString(<span class="keyword">string</span>(ln)) &#123;</span><br><span class="line">				res := cfg.Regex.ReplaceAllString(<span class="keyword">string</span>(ln), cfg.Replacement)</span><br><span class="line">				out[model.LabelName(res)] = lv</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		labels = out</span><br><span class="line">	<span class="keyword">case</span> config.RelabelLabelDrop:</span><br><span class="line">		<span class="keyword">for</span> ln := <span class="keyword">range</span> labels &#123;</span><br><span class="line">			<span class="keyword">if</span> cfg.Regex.MatchString(<span class="keyword">string</span>(ln)) &#123;</span><br><span class="line">				<span class="built_in">delete</span>(labels, ln)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">case</span> config.RelabelLabelKeep:</span><br><span class="line">		<span class="keyword">for</span> ln := <span class="keyword">range</span> labels &#123;</span><br><span class="line">			<span class="keyword">if</span> !cfg.Regex.MatchString(<span class="keyword">string</span>(ln)) &#123;</span><br><span class="line">				<span class="built_in">delete</span>(labels, ln)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="built_in">panic</span>(fmt.Errorf(<span class="string">"retrieval.relabel: unknown relabel action type %q"</span>, cfg.Action))</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> labels</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>action=keep, 丢弃指定源标签的标签值没有匹配到regex的target</p>
<p>action=drop，丢弃指定源标签的标签值匹配到regex的target</p>
<p>action=labeldrop，丢弃匹配到regex 的标签</p>
<p>action=labelkeep，丢弃没有匹配到regex 的标签</p>
<p>action=replace，更改标签名、更改标签值、合并标签</p>
<p>action=hashmod，将多个源标签的值进行hash，作为target标签的值</p>
<p>action=labelmap，Regex匹配名-&gt;replacement用原标签名的部分来替换名</p>
<p><strong>replace是缺省action，可以不配置action</strong></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.jianshu.com/p/c21d399c140a" target="_blank" rel="noopener">https://www.jianshu.com/p/c21d399c140a</a></p>
<p><a href="https://blog.csdn.net/luanpeng825485697/article/details/82318204" target="_blank" rel="noopener">https://blog.csdn.net/luanpeng825485697/article/details/82318204</a></p>

      </div>
      
      
        <br>
        


  <section class='meta' id="footer-meta">
    <div class='new-meta-box'>
      
        
          <div class="new-meta-item date" itemprop="dateUpdated" datetime="2020-02-18T01:29:10+00:00">
  <a class='notlink'>
    <i class="fas fa-clock" aria-hidden="true"></i>
    <p>更新于 2020年2月18日</p>
  </a>
</div>

        
      
        
          
  
  <div class="new-meta-item meta-tags"><a class="tag" href="/tags/monitor/" rel="nofollow"><i class="fas fa-tag" aria-hidden="true"></i><p>monitor</p></a></div>


        
      
        
          

        
      
    </div>
  </section>


      
      
          <div class="prev-next">
              
                  <section class="prev">
                      <span class="art-item-left">
                          <h6><i class="fas fa-chevron-left" aria-hidden="true"></i>&nbsp;上一页</h6>
                          <h4>
                              <a href="/2020/02/26/es%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90/" rel="prev" title="ES过程分析">
                                
                                    ES过程分析
                                
                              </a>
                          </h4>
                          
                              
                              <h6 class="tags">
                                  <a class="tag" href="/tags/ElasticSearch/"><i class="fas fa-tag fa-fw" aria-hidden="true"></i> ElasticSearch</a>
                              </h6>
                          
                      </span>
                  </section>
              
              
                  <section class="next">
                      <span class="art-item-right" aria-hidden="true">
                          <h6>下一页&nbsp;<i class="fas fa-chevron-right" aria-hidden="true"></i></h6>
                          <h4>
                              <a href="/2020/02/17/influxdb%20%E9%9B%86%E7%BE%A4%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/" rel="prev" title="influxdb集群代码分析">
                                  
                                      influxdb集群代码分析
                                  
                              </a>
                          </h4>
                          
                              
                              <h6 class="tags">
                                  <a class="tag" href="/tags/influxdb/"><i class="fas fa-tag fa-fw" aria-hidden="true"></i> influxdb</a>
                              </h6>
                          
                      </span>
                  </section>
              
          </div>
      
    </section>
  </article>



  <!-- 显示推荐文章和评论 -->



  






<!-- 根据页面mathjax变量决定是否加载MathJax数学公式js -->



  <script>
    window.subData = {
      title: 'Prometheus 架构和源码学习',
      tools: true
    }
  </script>


</div>
<aside class='l_side'>
  
    
    
      
      
        
          
          
            
              <section class='widget author'>
  <div class='content material'>
    
      <div class='avatar'>
        <img class='avatar' src='/images/avatar.jpg'/>
      </div>
    
    
      <div class='text'>
        
        
        
          <p><span id="jinrishici-sentence">Saar's Blog</span></p>
          <script src="https://sdk.jinrishici.com/v2/browser/jinrishici.js" charset="utf-8"></script>
        
      </div>
    
    
      <div class="social-wrapper">
        
          
            <a href="/atom.xml"
              class="social fas fa-rss flat-btn"
              target="_blank"
              rel="external nofollow noopener noreferrer">
            </a>
          
        
          
            <a href="https://github.com/fu4ck"
              class="social fab fa-github flat-btn"
              target="_blank"
              rel="external nofollow noopener noreferrer">
            </a>
          
        
      </div>
    
  </div>
</section>

            
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
      
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
      
        
          
          
        
          
          
            
              
  <section class='widget toc-wrapper'>
    
<header class='material'>
  <div><i class="fas fa-list fa-fw" aria-hidden="true"></i>&nbsp;&nbsp;本文目录</div>
  
    <!-- <div class='wrapper'><a class="s-toc rightBtn" rel="external nofollow noopener noreferrer" href="javascript:void(0)"><i class="fas fa-thumbtack fa-fw"></i></a></div> -->
  
</header>

    <div class='content material'>
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Prometheus-架构和源码"><span class="toc-text">Prometheus 架构和源码</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Prometheus架构"><span class="toc-text">Prometheus架构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#构成部分"><span class="toc-text">构成部分</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Notifier"><span class="toc-text">Notifier</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RuleManager"><span class="toc-text">RuleManager</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#QueryEngine"><span class="toc-text">QueryEngine</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Web"><span class="toc-text">Web</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DiscoveryManager"><span class="toc-text">DiscoveryManager</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ScrapeManager"><span class="toc-text">ScrapeManager</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LocalStorage-RemoteStorage"><span class="toc-text">LocalStorage&#x2F;RemoteStorage</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#AlertManager"><span class="toc-text">AlertManager</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Pushgateway"><span class="toc-text">Pushgateway</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#relabel"><span class="toc-text">relabel</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#参考资料"><span class="toc-text">参考资料</span></a></li></ol></li></ol>
    </div>
  </section>


            
          
        
          
          
        
          
          
        
          
          
        
          
          
        
      
        
          
          
        
          
          
        
          
          
            
              <section class='widget grid'>
  
<header class='material'>
  <div><i class="fas fa-map-signs fa-fw" aria-hidden="true"></i>&nbsp;&nbsp;站内导航</div>
  
</header>

  <div class='content material'>
    <ul class="grid navgation">
      
        <li><a class="flat-box" title="/" href="/"
          
          
          id="home">
          
            <i class="fas fa-clock fa-fw" aria-hidden="true"></i>
          
          近期文章
        </a></li>
      
        <li><a class="flat-box" title="/categories/" href="/categories/"
          
            rel="nofollow"
          
          
          id="categories">
          
            <i class="fas fa-archive fa-fw" aria-hidden="true"></i>
          
          文章归档
        </a></li>
      
    </ul>
  </div>
</section>

            
          
        
          
          
        
          
          
        
          
          
        
      
        
          
          
        
          
          
        
          
          
        
          
          
            
              
  <section class='widget category'>
    
<header class='material'>
  <div><i class="fas fa-folder-open fa-fw" aria-hidden="true"></i>&nbsp;&nbsp;文章分类</div>
  
    <a class="rightBtn"
    
      rel="nofollow"
    
    
    href="/categories/"
    title="/categories/">
    <i class="fas fa-expand-arrows-alt fa-fw"></i></a>
  
</header>

    <div class='content material'>
      <ul class="entry">
        
          <li><a class="flat-box" title="/categories/ElasticSearch/" href="/categories/ElasticSearch/"><div class='name'>ElasticSearch</div><div class='badge'>(2)</div></a></li>
        
          <li><a class="flat-box" title="/categories/ctf/" href="/categories/ctf/"><div class='name'>ctf</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box" title="/categories/docker/" href="/categories/docker/"><div class='name'>docker</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box" title="/categories/golang/" href="/categories/golang/"><div class='name'>golang</div><div class='badge'>(2)</div></a></li>
        
          <li><a class="flat-box" title="/categories/influxdb/" href="/categories/influxdb/"><div class='name'>influxdb</div><div class='badge'>(2)</div></a></li>
        
          <li><a class="flat-box" title="/categories/k8s/" href="/categories/k8s/"><div class='name'>k8s</div><div class='badge'>(3)</div></a></li>
        
          <li><a class="flat-box" title="/categories/malloc/" href="/categories/malloc/"><div class='name'>malloc</div><div class='badge'>(2)</div></a></li>
        
          <li><a class="flat-box" title="/categories/monitor/" href="/categories/monitor/"><div class='name'>monitor</div><div class='badge'>(10)</div></a></li>
        
          <li><a class="flat-box" title="/categories/mysql/" href="/categories/mysql/"><div class='name'>mysql</div><div class='badge'>(2)</div></a></li>
        
          <li><a class="flat-box" title="/categories/prometheus/" href="/categories/prometheus/"><div class='name'>prometheus</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box" title="/categories/pwn/" href="/categories/pwn/"><div class='name'>pwn</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box" title="/categories/rabbitmq/" href="/categories/rabbitmq/"><div class='name'>rabbitmq</div><div class='badge'>(2)</div></a></li>
        
          <li><a class="flat-box" title="/categories/redis/" href="/categories/redis/"><div class='name'>redis</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box" title="/categories/tsdb/" href="/categories/tsdb/"><div class='name'>tsdb</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box" title="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/" href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"><div class='name'>分布式</div><div class='badge'>(2)</div></a></li>
        
          <li><a class="flat-box" title="/categories/%E5%BF%83%E7%81%B5%E9%B8%A1%E6%B1%A4/" href="/categories/%E5%BF%83%E7%81%B5%E9%B8%A1%E6%B1%A4/"><div class='name'>心灵鸡汤</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box" title="/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/" href="/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"><div class='name'>深度学习</div><div class='badge'>(2)</div></a></li>
        
      </ul>
    </div>
  </section>


            
          
        
          
          
        
          
          
        
      
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
            
              
  <section class='widget tagcloud'>
    
<header class='material'>
  <div><i class="fas fa-tags fa-fw" aria-hidden="true"></i>&nbsp;&nbsp;热门标签</div>
  
    <a class="rightBtn"
    
      rel="nofollow"
    
    
    href="/tags/"
    title="/tags/">
    <i class="fas fa-expand-arrows-alt fa-fw"></i></a>
  
</header>

    <div class='content material'>
      <a href="/tags/ElasticSearch/" style="font-size: 17.33px; color: #828282">ElasticSearch</a> <a href="/tags/ctf/" style="font-size: 14px; color: #999">ctf</a> <a href="/tags/galera/" style="font-size: 14px; color: #999">galera</a> <a href="/tags/golang/" style="font-size: 17.33px; color: #828282">golang</a> <a href="/tags/influxdb/" style="font-size: 17.33px; color: #828282">influxdb</a> <a href="/tags/k8s/" style="font-size: 20.67px; color: #6c6c6c">k8s</a> <a href="/tags/malloc/" style="font-size: 17.33px; color: #828282">malloc</a> <a href="/tags/monitor/" style="font-size: 24px; color: #555">monitor</a> <a href="/tags/mysql/" style="font-size: 14px; color: #999">mysql</a> <a href="/tags/pwn/" style="font-size: 14px; color: #999">pwn</a> <a href="/tags/rabbitmq/" style="font-size: 17.33px; color: #828282">rabbitmq</a> <a href="/tags/redis/" style="font-size: 14px; color: #999">redis</a> <a href="/tags/runc/" style="font-size: 14px; color: #999">runc</a> <a href="/tags/tsdb/" style="font-size: 14px; color: #999">tsdb</a> <a href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F/" style="font-size: 17.33px; color: #828282">分布式</a> <a href="/tags/%E5%BF%83%E7%81%B5%E9%B8%A1%E6%B1%A4/" style="font-size: 14px; color: #999">心灵鸡汤</a> <a href="/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/" style="font-size: 17.33px; color: #828282">深度学习</a>
    </div>
  </section>


            
          
        
          
          
        
      
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
      
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
      
    

  
</aside>

<footer id="footer" class="clearfix">
  
  
    <div class="social-wrapper">
      
        
          <a href="/atom.xml"
            class="social fas fa-rss flat-btn"
            target="_blank"
            rel="external nofollow noopener noreferrer">
          </a>
        
      
        
          <a href="https://github.com/fu4ck"
            class="social fab fa-github flat-btn"
            target="_blank"
            rel="external nofollow noopener noreferrer">
          </a>
        
      
    </div>
  
  <br>
  <div><p>博客内容遵循 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="noopener">署名-非商业性使用-相同方式共享 4.0 国际 (CC BY-NC-SA 4.0) 协议</a></p>
</div>
  <div>
    本站使用
    <a href="https://xaoxuu.com/wiki/material-x/" target="_blank" class="codename">Material X</a>
    作为主题
    
      ，
      总访问量为
      <span id="busuanzi_value_site_pv"><i class="fas fa-spinner fa-spin fa-fw" aria-hidden="true"></i></span>
      次
    
    。
  </div>
</footer>
<script>setLoadingBarProgress(80);</script>


      <script>setLoadingBarProgress(60);</script>
    </div>
    <a class="s-top fas fa-arrow-up fa-fw" href='javascript:void(0)'></a>
  </div>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script>

  <script>
    var GOOGLE_CUSTOM_SEARCH_API_KEY = "";
    var GOOGLE_CUSTOM_SEARCH_ENGINE_ID = "";
    var ALGOLIA_API_KEY = "";
    var ALGOLIA_APP_ID = "";
    var ALGOLIA_INDEX_NAME = "";
    var AZURE_SERVICE_NAME = "";
    var AZURE_INDEX_NAME = "";
    var AZURE_QUERY_KEY = "";
    var BAIDU_API_ID = "";
    var SEARCH_SERVICE = "hexo" || "hexo";
    var ROOT = "/"||"/";
    if(!ROOT.endsWith('/'))ROOT += '/';
  </script>

<script src="//instant.page/1.2.2" type="module" integrity="sha384-2xV8M5griQmzyiY3CDqh1dn4z3llDVqZDqzjzcY+jCBCk/a5fXJmuZ/40JJAPeoU"></script>


  <script async src="https://cdn.jsdelivr.net/npm/scrollreveal@4.0.5/dist/scrollreveal.min.js"></script>
  <script type="text/javascript">
    $(function() {
      const $reveal = $('.reveal');
      if ($reveal.length === 0) return;
      const sr = ScrollReveal({ distance: 0 });
      sr.reveal('.reveal');
    });
  </script>


  <script src="https://cdn.jsdelivr.net/npm/node-waves@0.7.6/dist/waves.min.js"></script>
  <script type="text/javascript">
    $(function() {
      Waves.attach('.flat-btn', ['waves-button']);
      Waves.attach('.float-btn', ['waves-button', 'waves-float']);
      Waves.attach('.float-btn-light', ['waves-button', 'waves-float', 'waves-light']);
      Waves.attach('.flat-box', ['waves-block']);
      Waves.attach('.float-box', ['waves-block', 'waves-float']);
      Waves.attach('.waves-image');
      Waves.init();
    });
  </script>


  <script async src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-busuanzi@2.3/js/busuanzi.pure.mini.js"></script>




  
  
  
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery-backstretch/2.0.4/jquery.backstretch.min.js"></script>
    <script type="text/javascript">
      $(function(){
        if ('') {
          $('').backstretch(
          ["https://img.xjh.me/desktop/bg/nature/65253358_p0.jpg", "http://img.xjh.me/desktop/bg/nature/56245464_p0.jpg", "http://img.xjh.me/desktop/bg/nature/63606459_p0.jpg", "http://img.xjh.me/desktop/bg/nature/63190697_p0.jpg", "http://img.xjh.me/desktop/bg/nature/59322814_p0.jpg"],
          {
            duration: "6000",
            fade: "2500"
          });
        } else {
          $.backstretch(
          ["https://img.xjh.me/desktop/bg/nature/65253358_p0.jpg", "http://img.xjh.me/desktop/bg/nature/56245464_p0.jpg", "http://img.xjh.me/desktop/bg/nature/63606459_p0.jpg", "http://img.xjh.me/desktop/bg/nature/63190697_p0.jpg", "http://img.xjh.me/desktop/bg/nature/59322814_p0.jpg"],
          {
            duration: "6000",
            fade: "2500"
          });
        }
      });
    </script>
  











  
<script src="/js/app.js"></script>



  
<script src="/js/search.js"></script>





<!-- 复制 -->
<script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script>
<script>
  let COPY_SUCCESS = "复制成功";
  let COPY_FAILURE = "复制失败";
  /*页面载入完成后，创建复制按钮*/
  !function (e, t, a) {
    /* code */
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '  <i class="fa fa-copy"></i><span>复制</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });

      clipboard.on('success', function(e) {
        //您可以加入成功提示
        console.info('Action:', e.action);
        console.info('Text:', e.text);
        console.info('Trigger:', e.trigger);
        success_prompt(COPY_SUCCESS);
        e.clearSelection();
      });
      clipboard.on('error', function(e) {
        //您可以加入失败提示
        console.error('Action:', e.action);
        console.error('Trigger:', e.trigger);
        fail_prompt(COPY_FAILURE);
      });
    }
    initCopyCode();

  }(window, document);

  /**
   * 弹出式提示框，默认1.5秒自动消失
   * @param message 提示信息
   * @param style 提示样式，有alert-success、alert-danger、alert-warning、alert-info
   * @param time 消失时间
   */
  var prompt = function (message, style, time)
  {
      style = (style === undefined) ? 'alert-success' : style;
      time = (time === undefined) ? 1500 : time*1000;
      $('<div>')
          .appendTo('body')
          .addClass('alert ' + style)
          .html(message)
          .show()
          .delay(time)
          .fadeOut();
  };

  // 成功提示
  var success_prompt = function(message, time)
  {
      prompt(message, 'alert-success', time);
  };

  // 失败提示
  var fail_prompt = function(message, time)
  {
      prompt(message, 'alert-danger', time);
  };

  // 提醒
  var warning_prompt = function(message, time)
  {
      prompt(message, 'alert-warning', time);
  };

  // 信息提示
  var info_prompt = function(message, time)
  {
      prompt(message, 'alert-info', time);
  };

</script>


<!-- fancybox -->
<script src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script>
<script>
  let LAZY_LOAD_IMAGE = "";
  $(".article-entry").find("fancybox").find("img").each(function () {
      var element = document.createElement("a");
      $(element).attr("data-fancybox", "gallery");
      $(element).attr("href", $(this).attr("src"));
      /* 图片采用懒加载处理时,
       * 一般图片标签内会有个属性名来存放图片的真实地址，比如 data-original,
       * 那么此处将原本的属性名src替换为对应属性名data-original,
       * 修改如下
       */
       if (LAZY_LOAD_IMAGE) {
         $(element).attr("href", $(this).attr("data-original"));
       }
      $(this).wrap(element);
  });
</script>





  <script>setLoadingBarProgress(100);</script>
</body>
</html>
