<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  
  <title>tsdb源码学习 | Saar&#39;s Blog</title>
  
  

  
  <link rel="alternate" href="/atom.xml" title="Saar's Blog">
  

  <meta name="HandheldFriendly" content="True" />
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <!-- meta -->
  

  <!-- link -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
  
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-waves@0.7.6/dist/waves.min.css">
  
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.10.1/css/all.min.css">
  

  <!--自定义看板娘-->
  <script src="https://cdn.jsdelivr.net/npm/jquery/dist/jquery.min.js"></script>
  <script src="/live2d-widget/autoload.js"></script>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome/css/font-awesome.min.css"/>

  

  
    
<link rel="stylesheet" href="/style.css">

  

  <script>
    function setLoadingBarProgress(num) {
      document.getElementById('loading-bar').style.width=num+"%";
    }
  </script>

  
  
<meta name="generator" content="Hexo 4.2.0"><link rel="alternate" href="/atom.xml" title="Saar's Blog" type="application/atom+xml">
</head>

<body>
  
  
  <div class="cover-wrapper">
    <cover class='cover post half'>
      
        
  <h1 class='title'>Saar's Blog</h1>


  <div class="m_search">
    <form name="searchform" class="form u-search-form">
      <input type="text" class="input u-search-input" placeholder="" />
      <i class="icon fas fa-search fa-fw"></i>
    </form>
  </div>

<div class='menu navgation'>
  <ul class='h-list'>
    
      
        <li>
          <a class="nav home" href="/"
            
            
            id="home">
            <i class='fas fa-rss fa-fw'></i>&nbsp;博文
          </a>
        </li>
      
    
  </ul>
</div>

      
    </cover>
    <header class="l_header material">
  <div id="loading-bar-wrapper">
    <div id="loading-bar" class="material"></div>
  </div>

	<div class='wrapper'>
		<div class="nav-main container container--flex">
      <a class="logo flat-box" href='/' >
        
          Saar's Blog
        
      </a>
			<div class='menu navgation'>
				<ul class='h-list'>
          
  					
  						<li>
								<a class="nav flat-box" href="/"
                  
                  
                  id="home">
									<i class='fas fa-grin fa-fw'></i>&nbsp;首页
								</a>
							</li>
      			
      		
				</ul>
			</div>

			
				<div class="m_search">
					<form name="searchform" class="form u-search-form">
						<input type="text" class="input u-search-input" placeholder="搜索" />
						<i class="icon fas fa-search fa-fw"></i>
					</form>
				</div>
			
			<ul class='switcher h-list'>
				
					<li class='s-search'><a class="fas fa-search fa-fw" href='javascript:void(0)'></a></li>
				
				<li class='s-menu'><a class="fas fa-bars fa-fw" href='javascript:void(0)'></a></li>
			</ul>
		</div>

		<div class='nav-sub container container--flex'>
			<a class="logo flat-box"></a>
			<ul class='switcher h-list'>
				<li class='s-comment'><a class="flat-btn fas fa-comments fa-fw" href='javascript:void(0)'></a></li>
        
          <li class='s-toc'><a class="flat-btn fas fa-list fa-fw" href='javascript:void(0)'></a></li>
        
			</ul>
		</div>
	</div>
</header>
	<aside class="menu-phone">
    <header>
		<nav class="menu navgation">
      <ul>
        
          
            <li>
							<a class="nav flat-box" href="/"
                
                
                id="home">
								<i class='fas fa-clock fa-fw'></i>&nbsp;近期文章
							</a>
            </li>
          
       
      </ul>
		</nav>
    </header>
	</aside>
<script>setLoadingBarProgress(40);</script>

  </div>


  <div class="l_body">
    <div class='body-wrapper'>
      <div class='l_main'>
  

  <article id="post" class="post white-box article-type-post" itemscope itemprop="blogPost">
    


  <section class='meta'>
    
    
    <div class="meta" id="header-meta">
      
        
  
    <h1 class="title">
      <a href="/2020/10/10/tsdb%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/">
        tsdb源码学习
      </a>
    </h1>
  


      
      <div class='new-meta-box'>
        
          
        
          
            
  <div class='new-meta-item author'>
    
      <a href="http://www.yorzorzy.xyz" rel="nofollow">
        
          <i class="fas fa-user" aria-hidden="true"></i>
        
        <p>Saar</p>
      </a>
    
  </div>


          
        
          
            <div class="new-meta-item date">
  <a class='notlink'>
    <i class="fas fa-calendar-alt" aria-hidden="true"></i>
    <p>2020-10-10</p>
  </a>
</div>

          
        
          
            
  
  <div class='new-meta-item category'>
    <a href='/categories/tsdb/' rel="nofollow">
      <i class="fas fa-folder-open" aria-hidden="true"></i>
      <p>tsdb</p>
    </a>
  </div>


          
        
          
            
  
    <div class="new-meta-item browse busuanzi">
      <a class='notlink'>
        <i class="fas fa-eye" aria-hidden="true"></i>
        <p>
          <span id="busuanzi_value_page_pv">
            <i class="fas fa-spinner fa-spin fa-fw" aria-hidden="true"></i>
          </span>
        </p>
      </a>
    </div>
  


          
        
          
            
  

          
        
          
            

          
        
      </div>
      
        <hr>
      
    </div>
  </section>


    <section class="article typo">
      <div class="article-entry" itemprop="articleBody">
        <h1 id="tsdb源码学习"><a href="#tsdb源码学习" class="headerlink" title="tsdb源码学习"></a>tsdb源码学习</h1><p>tsdb项目结构：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">├── Documentation</span><br><span class="line">│   └── format</span><br><span class="line">│       ├── chunks.md</span><br><span class="line">│       ├── index.md</span><br><span class="line">│       └── tombstones.md</span><br><span class="line">├── LICENSE</span><br><span class="line">├── README.md</span><br><span class="line">├── block.go</span><br><span class="line">├── block_test.go</span><br><span class="line">├── chunkenc</span><br><span class="line">│   ├── bstream.go</span><br><span class="line">│   ├── chunk.go</span><br><span class="line">│   ├── chunk_test.go</span><br><span class="line">│   └── xor.go</span><br><span class="line">├── chunks</span><br><span class="line">│   └── chunks.go</span><br><span class="line">├── cmd</span><br><span class="line">│   └── tsdb</span><br><span class="line">│       ├── Makefile</span><br><span class="line">│       ├── README.md</span><br><span class="line">│       └── main.go</span><br><span class="line">├── compact.go</span><br><span class="line">├── compact_test.go</span><br><span class="line">├── db.go</span><br><span class="line">├── db_test.go</span><br><span class="line">├── encoding_helpers.go</span><br><span class="line">├── fileutil</span><br><span class="line">│   ├── dir_unix.go</span><br><span class="line">│   ├── dir_windows.go</span><br><span class="line">│   ├── fileutil.go</span><br><span class="line">│   ├── mmap.go</span><br><span class="line">│   ├── mmap_unix.go</span><br><span class="line">│   ├── mmap_windows.go</span><br><span class="line">│   ├── preallocate.go</span><br><span class="line">│   ├── preallocate_darwin.go</span><br><span class="line">│   ├── preallocate_linux.go</span><br><span class="line">│   ├── preallocate_other.go</span><br><span class="line">│   ├── sync.go</span><br><span class="line">│   ├── sync_darwin.go</span><br><span class="line">│   └── sync_linux.go</span><br><span class="line">├── head.go</span><br><span class="line">├── head_test.go</span><br><span class="line">├── index</span><br><span class="line">│   ├── encoding_helpers.go</span><br><span class="line">│   ├── index.go</span><br><span class="line">│   ├── index_test.go</span><br><span class="line">│   ├── postings.go</span><br><span class="line">│   └── postings_test.go</span><br><span class="line">├── labels</span><br><span class="line">│   ├── labels.go</span><br><span class="line">│   ├── labels_test.go</span><br><span class="line">│   └── selector.go</span><br><span class="line">├── querier.go</span><br><span class="line">├── querier_test.go</span><br><span class="line">├── test</span><br><span class="line">│   ├── conv_test.go</span><br><span class="line">│   ├── hash_test.go</span><br><span class="line">│   └── labels_test.go</span><br><span class="line">├── testdata</span><br><span class="line">│   └── 20kseries.json</span><br><span class="line">├── testutil</span><br><span class="line">│   └── testutil.go</span><br><span class="line">├── tombstones.go</span><br><span class="line">├── tombstones_test.go</span><br><span class="line">├── tsdbutil</span><br><span class="line">│   ├── buffer.go</span><br><span class="line">│   └── buffer_test.go</span><br><span class="line">├── wal.go</span><br><span class="line">└── wal_test.go</span><br></pre></td></tr></table></figure>

<h2 id="bstream"><a href="#bstream" class="headerlink" title="bstream"></a>bstream</h2><p>bstream结构体就是Prometheus TSDB中的基础组件之一，它是对 byte切片的封装，提供了读写bit位的功能，主要用于读写时序数据。bstream结构体其核心字段定义如下：</p>
<ul>
<li><strong>stream（[]byte类型）</strong>：用于记录数据的byte切片。</li>
<li><strong>count（uint8类型）</strong>：在写入数据的时候，是逐个byte进行操作的，count字段用来记录当前byte中有多少个bit位是可以写入的，在读取数据的时候，表示当前byte中有多少个bit位是可读的。也就是说，count字段类似于控制写入/读取位置的下标。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bstream is a stream of bits.</span></span><br><span class="line"><span class="keyword">type</span> bstream <span class="keyword">struct</span> &#123;</span><br><span class="line">	stream []<span class="keyword">byte</span> <span class="comment">// the data stream</span></span><br><span class="line">	count  <span class="keyword">uint8</span>  <span class="comment">// how many bits are valid in current byte</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先是writeByte()方法，它提供了写入一个byte的功能，其工作原理如图2-2所示。在图2-3（a）中每次正好写入stream切片的一个元素。需要注意图2-3（b）中展示的这种场景，待写入byte值的高位（10）会写入到bstream.stream切片中的第二个byte元素中，低位（100101）会写入到第三个byte元素中。</p>
<p><img src="https://pic4.zhimg.com/80/v2-84d3210214a9b2aea184bc6c7c2c7dcf_hd.jpg" alt="img"></p>
<p>bstream.writeByte()方法的具体实现如下。注意，在通过writeByte()方法写入byte之后，bstream.count字段的值是不需要改变的。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *bstream)</span> <span class="title">writeByte</span><span class="params">(byt <span class="keyword">byte</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> b.count == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">//当前bstream已经完整写完了一个byte, 需要向stream切片中追加一个新的byte元素来完成此次写入</span></span><br><span class="line">		b.stream = <span class="built_in">append</span>(b.stream, <span class="number">0</span>)</span><br><span class="line">		b.count = <span class="number">8</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	i := <span class="built_in">len</span>(b.stream) - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 再stream切片末尾写入byt</span></span><br><span class="line">	<span class="comment">// fill up b.b with b.count bits from byt</span></span><br><span class="line">	b.stream[i] |= byt &gt;&gt; (<span class="number">8</span> - b.count)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果stream切片中最后一个byte元素剩余的bit位不足8，则需要追加一个byte写入byt剩余的bit位</span></span><br><span class="line">	b.stream = <span class="built_in">append</span>(b.stream, <span class="number">0</span>)</span><br><span class="line">	i++</span><br><span class="line">	b.stream[i] = byt &lt;&lt; b.count</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>bstream.writeBit()方法负责完成一个bit的写入，同时也会更新bstream.count字段，具体实现如下所示：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *bstream)</span> <span class="title">writeBit</span><span class="params">(bit bit)</span></span> &#123;</span><br><span class="line"> <span class="keyword">if</span> b.count == <span class="number">0</span> &#123;</span><br><span class="line"> <span class="comment">// 当前bstream已经完整写完一个byte，需要向stream切片中追加新的byte元素来完成此次写入</span></span><br><span class="line"> b.stream = <span class="built_in">append</span>(b.stream, <span class="number">0</span>)</span><br><span class="line"> b.count = <span class="number">8</span></span><br><span class="line"> &#125;</span><br><span class="line"> i := <span class="built_in">len</span>(b.stream) - <span class="number">1</span> <span class="comment">// 最后一个byte元素的下标</span></span><br><span class="line"> <span class="keyword">if</span> bit &#123; <span class="comment">// 如果bit为1，则需要将该byte元素中对应的位设置为1，如果为0，则不需要设置</span></span><br><span class="line"> b.stream[i] |= <span class="number">1</span> &lt;&lt; (b.count - <span class="number">1</span>)</span><br><span class="line"> &#125;</span><br><span class="line"> b.count-- <span class="comment">// 写入一个bit之后，更新当前byte可用位的数量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外，writeBits()方法实现了写入一个uint64值的功能，当该值所占的bit位数超过8个时，会首先调用writeByte()方法，按照每8位一个byte的方式写入，然后再调用writeBit()方法写入剩余不足8位的bit值，其实现比较简单，这里不再展开详细介绍。</p>
<p>介绍完bstream中提供的写入方法之后，下面继续分析bstream中读取相关的方法。首先是readByte()方法，该方法负责读取一个8位的byte，其大致原理如图2-4所示：</p>
<p><img src="https://pic1.zhimg.com/80/v2-70afd99abb582636ac6466d9d888a91c_hd.jpg" alt="img"></p>
<p>bstream.readByte()方法实现如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *bstream)</span> <span class="title">readByte</span><span class="params">()</span> <span class="params">(<span class="keyword">byte</span>, error)</span></span> &#123;</span><br><span class="line"> <span class="comment">// 检测当前stream切片是否为空(略)</span></span><br><span class="line"> <span class="comment">// 读取数据时会首先将bstream.count初始化为8，所以会先读取stream切片中的第一个元素</span></span><br><span class="line"> <span class="keyword">if</span> b.count == <span class="number">8</span> &#123; </span><br><span class="line"> b.count = <span class="number">0</span> <span class="comment">// 将count更新为0</span></span><br><span class="line"> <span class="keyword">return</span> b.stream[<span class="number">0</span>], <span class="literal">nil</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> b.count == <span class="number">0</span> &#123; <span class="comment">// count为0表示当前stream切片中的第一个元素已经被读取完毕</span></span><br><span class="line"> b.stream = b.stream[<span class="number">1</span>:] <span class="comment">// 截掉stream切片中第一个byte元素</span></span><br><span class="line"> <span class="comment">// 重新检测stream切片是否为空(略)</span></span><br><span class="line"> <span class="keyword">return</span> b.stream[<span class="number">0</span>], <span class="literal">nil</span> <span class="comment">// 返回stream切片中的第一个byte元素</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 如果count不等于0或8，则此次读取的8个bit需要跨两个byte元素</span></span><br><span class="line"> byt := b.stream[<span class="number">0</span>] &lt;&lt; (<span class="number">8</span> - b.count) <span class="comment">// 从第一个byte元素中读取剩余可读取的bit</span></span><br><span class="line"> b.stream = b.stream[<span class="number">1</span>:] <span class="comment">// 截掉stream切片中的第一个byte元素</span></span><br><span class="line"> <span class="comment">// 检测stream切片是否为空(略)</span></span><br><span class="line"> <span class="comment">// 截断之后，再次读取stream中第一个byte元素，凑齐8个bit</span></span><br><span class="line"> byt |= b.stream[<span class="number">0</span>] &gt;&gt; b.count</span><br><span class="line"> <span class="keyword">return</span> byt, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再来看bstream.readBit()方法，它主要实现了读取单个bit位的功能，具体实现如下所示：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *bstream)</span> <span class="title">readBit</span><span class="params">()</span> <span class="params">(bit, error)</span></span> &#123;</span><br><span class="line"> <span class="keyword">if</span> <span class="built_in">len</span>(b.stream) == <span class="number">0</span> &#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="literal">false</span>, io.EOF</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">// 检测当前stream切片是否为空(略)</span></span><br><span class="line"> <span class="keyword">if</span> b.count == <span class="number">0</span> &#123; <span class="comment">// count为0表示stream切片中的第一个byte元素已读取完毕</span></span><br><span class="line"> b.stream = b.stream[<span class="number">1</span>:] <span class="comment">// 截掉第一个byte元素</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> <span class="built_in">len</span>(b.stream) == <span class="number">0</span> &#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="literal">false</span>, io.EOF</span><br><span class="line"> &#125;</span><br><span class="line"> b.count = <span class="number">8</span> <span class="comment">// 将count字段重置为8</span></span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">// 读取第一个bit位</span></span><br><span class="line"> d := (b.stream[<span class="number">0</span>] &lt;&lt; (<span class="number">8</span> - b.count)) &amp; <span class="number">0x80</span></span><br><span class="line"> b.count-- <span class="comment">// 递减count字段，表示该byte中剩余可读取的bit数</span></span><br><span class="line"> <span class="keyword">return</span> d != <span class="number">0</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外，与writeBits()方法对应的是readBits()方法，它实现了一次读取多个bit位的功能，当读取的bit个数超过8个，则首先通过readByte()方法按照byte进行读取，之后当需要读取的bit个数不足8个时，则会调用readBit()方法逐个读取bit值，其实现比较简单，这里不再展开详细介绍。</p>
<h2 id="Chunk接口"><a href="#Chunk接口" class="headerlink" title="Chunk接口"></a>Chunk接口</h2><p>在上一篇文章中提到，在磁盘存储中每个block中的时序数据存储在chunk文件中。Prometheus TSDB中对应的抽象是Chunk接口，它表示一组时序点的集合，其定义如下所示。Chunk接口有两个紧密相关的接口：Append接口和Iterator接口，我们可以通过该Append接口向Chunk中追加时序点，也可以通过Iterator接口迭代Chunk中存储的时序点。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Chunk <span class="keyword">interface</span> &#123;</span><br><span class="line"> Bytes() []<span class="keyword">byte</span> <span class="comment">// 存储时序点的byte切片，通过前面介绍的bstream完成读写</span></span><br><span class="line"> Encoding() Encoding <span class="comment">// 编码类型，目前只有XOR这一种编码类型</span></span><br><span class="line"> Appender() (Appender, error) <span class="comment">// 返回该Chunk关联的Appender实例 </span></span><br><span class="line"> Iterator() Iterator <span class="comment">// 返回该Chunk关联的Iterator实例</span></span><br><span class="line"> NumSamples() <span class="keyword">int</span> <span class="comment">// 返回该Chunk中保存时序点的个数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的Append接口和Iterator接口的定义都比较简单，如下所示。Append接口中只有一个Append()方法，用于向Chunk实例中追加一个时序点，其接收的参数分别是时序点的timestamp和value值。Iterator与我们常见的迭代器类似。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Appender <span class="keyword">interface</span> &#123;</span><br><span class="line"> Append(<span class="keyword">int64</span>, <span class="keyword">float64</span>)  <span class="comment">// 每个时序点都是有对应的timestamp和value值组成的</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Iterator <span class="keyword">interface</span> &#123;</span><br><span class="line"> At() (<span class="keyword">int64</span>, <span class="keyword">float64</span>) <span class="comment">// 返回当前时序点的timestamp和value值</span></span><br><span class="line"> Err() error <span class="comment">// 返回迭代过程中发生的异常</span></span><br><span class="line"> Next() <span class="keyword">bool</span> <span class="comment">// 检测后续是否有时序点可以继续迭代</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="XORChunk实现"><a href="#XORChunk实现" class="headerlink" title="XORChunk实现"></a>XORChunk实现</h2><p>XORChunk是Prometheus TSDB实现中Chunk接口的唯一实现，它只有b（*bstream类型）一个字段，主要用于存储时序数据。XORChunk关联的Appender接口实现为xorAppender，其核心字段如下：</p>
<ul>
<li><strong>b（*bstream）</strong>：bstream实例，存储写入的时序点的数据。</li>
<li><strong>t（int64类型）</strong>：记录上次写入时序点对应的timestamp。</li>
<li><strong>v（float64类型）</strong>：记录上次写入时序点对应的value值。</li>
<li><strong>tDelta（uint64类型）：</strong>记录当前点与前一个点的timestamp差值。</li>
<li><strong>leading（uint8）：</strong>记录当前XOR运算结果中前置”0”的个数。</li>
<li><strong>trailing</strong>（<strong>uint8</strong>）：记录当前XOR运算结果中后置”0”的个数。</li>
</ul>
<p>XORChunk中只有两个方法需要介绍，一个是XORChunk.iterator()方法，用于创建xorIterator实例，xorIterator实例用于迭代XORChunk中的时序点，iterator()方法的具体实现如下所示：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *XORChunk)</span> <span class="title">iterator</span><span class="params">()</span> *<span class="title">xorIterator</span></span> &#123;</span><br><span class="line"> <span class="keyword">return</span> &amp;xorIterator&#123;</span><br><span class="line"> <span class="comment">// bstream中前两个byte元素存储的是XORChunk中时序点的个数，所以这里要跳过</span></span><br><span class="line"> br: newBReader(c.b.bytes()[<span class="number">2</span>:]),</span><br><span class="line"> <span class="comment">// 读取bstream中前两个byte元素，获取XORChunk实例中存储的时序点的个数</span></span><br><span class="line"> numTotal: binary.BigEndian.Uint16(c.b.bytes()),</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另一个方法是XORChunk.Appender()方法，用于创建xorAppender实例，xorAppender负责向该XORChunk实例中追加时序点，Appender()方法的具体实现如下所示：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *XORChunk)</span> <span class="title">Appender</span><span class="params">()</span> <span class="params">(Appender, error)</span></span> &#123;</span><br><span class="line"> it := c.iterator() <span class="comment">// 创建xorIterator迭代器</span></span><br><span class="line"> <span class="keyword">for</span> it.Next() &#123; <span class="comment">// 迭代XORChunk中已有的全部时序点，直至结束，这样才能得到可以写入的正确状态</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> a := &amp;xorAppender&#123; <span class="comment">// 根据xorIterator迭代器的状态创建xorAppender实例</span></span><br><span class="line"> b: c.b,</span><br><span class="line"> t: it.t,</span><br><span class="line"> v: it.val,</span><br><span class="line"> tDelta: it.tDelta,</span><br><span class="line"> leading: it.leading,</span><br><span class="line">  trailing: it.trailing,</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">if</span> binary.BigEndian.Uint16(a.b.bytes()) == <span class="number">0</span> &#123;<span class="comment">// 如果是空XORChunk会初始化leading</span></span><br><span class="line"> a.leading = <span class="number">0xff</span></span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> a, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="xorAppender"><a href="#xorAppender" class="headerlink" title="xorAppender"></a><strong>xorAppender</strong></h2><p>下面来看xorAppender.Append()方法的具体实现，其参数是待写入时序点的timestamp和value值，这里会按照前面介绍的delta-of-delta时间戳压缩方式存储timestamp，按照XOR压缩方式存储value值。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *xorAppender)</span> <span class="title">Append</span><span class="params">(t <span class="keyword">int64</span>, v <span class="keyword">float64</span>)</span></span> &#123;</span><br><span class="line"> <span class="keyword">var</span> tDelta <span class="keyword">uint64</span></span><br><span class="line"> <span class="comment">// XORChunk会使用bstream中前两个byte记录已写入的时序点的个数，这里就是读取该值</span></span><br><span class="line"> num := binary.BigEndian.Uint16(a.b.bytes())</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> num == <span class="number">0</span> &#123; <span class="comment">// 每个XORChunk中需要完整记录第一个点的timestamp和value值</span></span><br><span class="line"> buf := <span class="built_in">make</span>([]<span class="keyword">byte</span>, binary.MaxVarintLen64) <span class="comment">// 创建一个足够存储timestamp的byte切片</span></span><br><span class="line"> </span><br><span class="line"> <span class="keyword">for</span> _, b := <span class="keyword">range</span> buf[:binary.PutVarint(buf, t)] &#123;<span class="comment">// 将timestamp完整写入到bstream中</span></span><br><span class="line"> a.b.writeByte(b)</span><br><span class="line"> &#125;</span><br><span class="line"> a.b.writeBits(math.Float64bits(v), <span class="number">64</span>) <span class="comment">// 将第一个时序点的value值写入到bstream中</span></span><br><span class="line"> &#125; <span class="keyword">else</span> <span class="keyword">if</span> num == <span class="number">1</span> &#123; <span class="comment">// 根据num判断，此次写入的是第二个时序点</span></span><br><span class="line"> tDelta = <span class="keyword">uint64</span>(t - a.t) <span class="comment">// 计算该点与前一个时序点的timestamp差值</span></span><br><span class="line"> <span class="comment">// 下面将当前时序点与前一个时序点的timestamp差值写入到bstream中</span></span><br><span class="line"> buf := <span class="built_in">make</span>([]<span class="keyword">byte</span>, binary.MaxVarintLen64)</span><br><span class="line"> <span class="keyword">for</span> _, b := <span class="keyword">range</span> buf[:binary.PutUvarint(buf, tDelta)] &#123;</span><br><span class="line">  a.b.writeByte(b)</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">// 计算该时序点与前一个时序点value值的XOR值，并按照前面介绍的压缩方式记录到bstream中，</span></span><br><span class="line"> <span class="comment">// xorAppender.writeVDelta()方法的具体实现在后面进行详细介绍</span></span><br><span class="line"> a.writeVDelta(v) </span><br><span class="line"> &#125; <span class="keyword">else</span> &#123; <span class="comment">// 根据num判断，写入第三个以及之后的时序点</span></span><br><span class="line"> tDelta = <span class="keyword">uint64</span>(t - a.t) <span class="comment">// 计算该时序点与前一个时序点的timestamp差值</span></span><br><span class="line"> dod := <span class="keyword">int64</span>(tDelta - a.tDelta) <span class="comment">// 计算两个timestamp的dod（delta-of-delta）值</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">switch</span> &#123;</span><br><span class="line"> <span class="keyword">case</span> dod == <span class="number">0</span>: <span class="comment">// 如果dod差值为0，则只需要记录一个值为"0"的bit值</span></span><br><span class="line"> a.b.writeBit(zero)</span><br><span class="line"> <span class="keyword">case</span> bitRange(dod, <span class="number">14</span>): </span><br><span class="line"> <span class="comment">// 如果dod值在[-8191, 8192]范围中，则使用"10"作为标识，然后使用14个bit位存储dod值</span></span><br><span class="line"> a.b.writeBits(<span class="number">0x02</span>, <span class="number">2</span>)</span><br><span class="line"> a.b.writeBits(<span class="keyword">uint64</span>(dod), <span class="number">14</span>)</span><br><span class="line"> <span class="keyword">case</span> bitRange(dod, <span class="number">17</span>):</span><br><span class="line"> <span class="comment">// 如果dod值在[-65535, 65536]范围中，则使用"110"作为标识，然后使用17个bit位存储dod值</span></span><br><span class="line"> a.b.writeBits(<span class="number">0x06</span>, <span class="number">3</span>) </span><br><span class="line"> a.b.writeBits(<span class="keyword">uint64</span>(dod), <span class="number">17</span>)</span><br><span class="line"> <span class="keyword">case</span> bitRange(dod, <span class="number">20</span>):</span><br><span class="line"> <span class="comment">// 如果dod值在[-524287, 524288]范围中，则使用"1110"作为标识，然后使用20位存储dod值</span></span><br><span class="line"> a.b.writeBits(<span class="number">0x0e</span>, <span class="number">4</span>)</span><br><span class="line"> a.b.writeBits(<span class="keyword">uint64</span>(dod), <span class="number">20</span>)</span><br><span class="line"> <span class="keyword">default</span>: <span class="comment">// 如果dod值超出了上述返回，则使用"1111"作为标识，然后使用64个bit位存储dod值</span></span><br><span class="line"> a.b.writeBits(<span class="number">0x0f</span>, <span class="number">4</span>)</span><br><span class="line"> a.b.writeBits(<span class="keyword">uint64</span>(dod), <span class="number">64</span>)</span><br><span class="line">  &#125;</span><br><span class="line"> a.writeVDelta(v) <span class="comment">// 计算当前时序点与前一个时序点value值的XOR，并记录到bstream中</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> a.t = t <span class="comment">// 更新t、v字段，记录当前时序点的时间戳和value值，为下一个时序点的写入做准备</span></span><br><span class="line"> a.v = v</span><br><span class="line"> binary.BigEndian.PutUint16(a.b.bytes(), num + <span class="number">1</span>) <span class="comment">// 更新该XORChunk已写入的点的个数</span></span><br><span class="line"> a.tDelta = tDelta <span class="comment">// 记录当前时序点和前一个时序点的timestamp差值，为下次计算dod值做准备</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过对xorAppender.Append()方法的分析，我们了解了Prometheus TSDB对timestamp压缩的具体实现。接下来深入分析xorAppender.writeVDelta()方法，看Prometheus TSDB如何实现对value值的压缩。在writeVDelta()方法中，会计算当前时序点的value值与前一时序点的value值的XOR值，并根据XOR运算结果值中前置“0”和后置“0”的个数进行相应的压缩存储，具体的压缩规则在上一节已经介绍过了，这里重点看一下writeVDelta()方法对该压缩方式的实现。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *xorAppender)</span> <span class="title">writeVDelta</span><span class="params">(v <span class="keyword">float64</span>)</span></span> &#123;</span><br><span class="line"> <span class="comment">// 计算当前时序点的value值与前一个时序点的value值之间的XOR值</span></span><br><span class="line"> vDelta := math.Float64bits(v) ^ math.Float64bits(a.v)</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> vDelta == <span class="number">0</span> &#123; <span class="comment">// 如果两个时序点的value值相同，则只写入一个值为"0"的bit位</span></span><br><span class="line"> a.b.writeBit(zero)</span><br><span class="line"> <span class="keyword">return</span></span><br><span class="line"> &#125;</span><br><span class="line"> a.b.writeBit(one) <span class="comment">// 写入控制位的第一个bit位，该位的值为"1"</span></span><br><span class="line"> leading := <span class="keyword">uint8</span>(bits.LeadingZeros64(vDelta)) <span class="comment">// 返回vDelta中前置"0"的个数</span></span><br><span class="line"> trailing := <span class="keyword">uint8</span>(bits.TrailingZeros64(vDelta)) <span class="comment">// 返回vDelta中后置"0"的个数</span></span><br><span class="line"> <span class="keyword">if</span> a.leading != <span class="number">0xff</span> &amp;&amp; leading &gt;= a.leading &amp;&amp; trailing &gt;= a.trailing &#123;</span><br><span class="line"> <span class="comment">// 该vDelta值的前置"0"和后置"0"的个数都比上一次写入得到XOR值多</span></span><br><span class="line"> a.b.writeBit(zero) <span class="comment">// 写入控制位的第二个bit位，该位的值为"0"</span></span><br><span class="line"> <span class="comment">// 这里只需要记录除去前置"0"和后置"0"的部分即可</span></span><br><span class="line"> a.b.writeBits(vDelta&gt;&gt;a.trailing, <span class="number">64</span>-<span class="keyword">int</span>(a.leading)-<span class="keyword">int</span>(a.trailing))</span><br><span class="line"> &#125; <span class="keyword">else</span> &#123; <span class="comment">// 该vDelta值的前置"0"或是后置"0"比上一次写入得到的XOR值少</span></span><br><span class="line"> <span class="comment">// 更新xorAppender的leading和trailing的字段，分别记录此次写入时得到的XOR值中前置"0"</span></span><br><span class="line"> <span class="comment">// 和后置"0"个数，这主要是为下一个时序点的写入做准备</span></span><br><span class="line"> a.leading, a.trailing = leading, trailing </span><br><span class="line"> a.b.writeBit(one) <span class="comment">// 写入控制位的第二个bit位，该位的值为"1"</span></span><br><span class="line"> a.b.writeBits(<span class="keyword">uint64</span>(leading), <span class="number">5</span>) <span class="comment">// 用5个bit位来存储XOR值中前置0的数量</span></span><br><span class="line"> sigbits := <span class="number">64</span> - leading - trailing</span><br><span class="line"> a.b.writeBits(<span class="keyword">uint64</span>(sigbits), <span class="number">6</span>) <span class="comment">// 用6个bit位来存储XOR值中间非0位的长度</span></span><br><span class="line"> a.b.writeBits(vDelta&gt;&gt;trailing, <span class="keyword">int</span>(sigbits)) <span class="comment">// 存储中间非0位的值</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>xorIterator</strong></p>
<p>到此为止，时序点的写入到Chunk实例的具体实现就分析完了。接下来要看的是xorIterator结构体，它是上一小节提到的Iterator接口的唯一实现，主要负责从Chunk中读取时序点，其核心字段如下所示：</p>
<ul>
<li><strong>br（*bstream类型）</strong>：关联XORChunk实例中的b字段，存储了XORChunk实例中的时序数据。</li>
<li><strong>numTotal（uint16类型）</strong>：关联XORChunk中存储的时序点的个数</li>
<li><strong>numRead（uint16类型）</strong>：通过该xorIterator实例读取的时序点的个数。</li>
<li><strong>t（int64类型）</strong>：当前读取的时序点的timestamp。</li>
<li><strong>val（float64类型）</strong>：当前读取的时序点的value值。</li>
<li><strong>leading（uint8类型）</strong>：当前读取到的XOR值的前置”0”个数。</li>
<li><strong>trailing（uint8类型）</strong>：当前读取到的XOR值的后置”0”个数。</li>
<li><strong>tDelta（uint64类型）</strong>：记录当前时序点与前一个时序点的timestamp的差值。</li>
</ul>
<p>Next()方法是xorIterator的核心方法之一，它会根据当前读取的是第几个时序点决定如何返回正确的timestamp和value值，先来看timestamp的读取过程如下：</p>
<ul>
<li>如果读取的是第一个时序点，则其timestamp和value值没有被压缩，直接读取即可。</li>
<li>如果读取的是第二个时序点，则需要第二个时序点与第一个时序点的timestamp差值，然后根据第一个点的timestamp以及timestamp差值，计算得出第二个时序点的timestamp。</li>
<li>如果读取的是第三个以及之后的时序点，则需要读取dod（delta-of-delta）值，然后根据前两个时序点的timestamp差值以及dod值，得出该时序点的timestamp。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(it *xorIterator)</span> <span class="title">Next</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"> <span class="comment">// 检测迭代过程中是否出现异常，则返回false，停止整个迭代过程(略)</span></span><br><span class="line"> <span class="comment">// 检测numRead字段值，如果该xorIterator已经读取完全部的时序点，也会返回false(略)</span></span><br><span class="line"> <span class="keyword">if</span> it.numRead == <span class="number">0</span> &#123; <span class="comment">// 读取XORChunk实例中第一个时序点</span></span><br><span class="line"> t, err := binary.ReadVarint(it.br) <span class="comment">// 从bstream中读取第一个时序点的完整timestamp</span></span><br><span class="line"> v, err := it.br.readBits(<span class="number">64</span>) <span class="comment">// 从bstream中读取第一个时序点完整的value值</span></span><br><span class="line"> it.t = t <span class="comment">// 更新t、val字段，记录当前时序点的timestamp和value值，在At()方法中会返回这两个值</span></span><br><span class="line"> it.val = math.Float64frombits(v)</span><br><span class="line"> it.numRead++ <span class="comment">// 递增已读取的点的个数</span></span><br><span class="line"> <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">if</span> it.numRead == <span class="number">1</span> &#123; <span class="comment">// 读取XORChunk中第二个时序点</span></span><br><span class="line">  <span class="comment">// 从bstream中读取第二个点与第一个点的timestamp差值</span></span><br><span class="line"> tDelta, err := binary.ReadUvarint(it.br)</span><br><span class="line"> it.tDelta = tDelta <span class="comment">// 更新tDelta字段，记录timestamp差值</span></span><br><span class="line"> it.t = it.t + <span class="keyword">int64</span>(it.tDelta) <span class="comment">// 计算第二个时序点对应的timestamp</span></span><br><span class="line"> <span class="comment">// 读取第二个时序点的value值，xorIterator.readValue()方法的具体内容在后面详细介绍</span></span><br><span class="line"> <span class="keyword">return</span> it.readValue()</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">// 在读取XORChunk中第三个时序点以及之后的时序点时，会执行下面的逻辑</span></span><br><span class="line"> <span class="keyword">var</span> d <span class="keyword">byte</span></span><br><span class="line"> <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">4</span>; i++ &#123; <span class="comment">// 首先读取标识位</span></span><br><span class="line"> d &lt;&lt;= <span class="number">1</span> <span class="comment">// 将d左移一位，为读取下一位做准备</span></span><br><span class="line"> bit, err := it.br.readBit()</span><br><span class="line"> <span class="keyword">if</span> bit == zero &#123; <span class="comment">// 在读取标识位的过程中遇到"0"位，则表示标识位已经读取结束</span></span><br><span class="line">  <span class="keyword">break</span></span><br><span class="line"> &#125;</span><br><span class="line"> d |= <span class="number">1</span> <span class="comment">// 该bit位不为"0"，则将对应bit位设置为1</span></span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">var</span> sz <span class="keyword">uint8</span> <span class="comment">// 后续需要读取多少个bit位，才能得到dod(delta-of-delta)值</span></span><br><span class="line"> <span class="keyword">var</span> dod <span class="keyword">int64</span></span><br><span class="line"> <span class="keyword">switch</span> d &#123; <span class="comment">// 如果标识位为"0"，则表示时间戳的dod(delta-of-delta)值为0</span></span><br><span class="line"> <span class="keyword">case</span> <span class="number">0x00</span>:</span><br><span class="line"> <span class="comment">// dod == 0</span></span><br><span class="line"> <span class="keyword">case</span> <span class="number">0x02</span>: <span class="comment">// 如果标识位为"10"，则表示时间戳的dod值在[-8191, 8192]范围中，需要读取14个bit位</span></span><br><span class="line"> sz = <span class="number">14</span></span><br><span class="line"> <span class="keyword">case</span> <span class="number">0x06</span>: </span><br><span class="line"> <span class="comment">// 如果标识位为"110"，则表示时间戳的dod值在[-65535, 65536]范围中，需要读取17个bit位</span></span><br><span class="line"> sz = <span class="number">17</span> </span><br><span class="line"> <span class="keyword">case</span> <span class="number">0x0e</span>: </span><br><span class="line"> <span class="comment">// 如果标识位为"1110"，则表示时间戳的dod值在[-524287, 524288]范围中，需要读取20个bit位</span></span><br><span class="line"> sz = <span class="number">20</span></span><br><span class="line"> <span class="keyword">case</span> <span class="number">0x0f</span>: <span class="comment">// 如果标识位为"1111"，则表示时间戳的dod值超出了上述范围，需要读取64个bit位</span></span><br><span class="line"> bits, err := it.br.readBits(<span class="number">64</span>)</span><br><span class="line"> dod = <span class="keyword">int64</span>(bits)</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> sz != <span class="number">0</span> &#123; <span class="comment">// 标识位为"10"、"110"、"1110"，则读取指定的数量的bit位，获得dod值</span></span><br><span class="line"> bits, err := it.br.readBits(<span class="keyword">int</span>(sz))</span><br><span class="line"> dod = <span class="keyword">int64</span>(bits)</span><br><span class="line"> &#125;</span><br><span class="line">  it.tDelta = <span class="keyword">uint64</span>(<span class="keyword">int64</span>(it.tDelta) + dod) <span class="comment">// 计算两个点的时间戳的差值</span></span><br><span class="line"> it.t = it.t + <span class="keyword">int64</span>(it.tDelta) <span class="comment">// 根据上一点的时间戳计算当前点的时间戳</span></span><br><span class="line"> <span class="keyword">return</span> it.readValue() <span class="comment">// readValue()方法的具体内容在后面详细介绍</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在xorIterator.Next()方法读取timestamp的同时，还会调用readValue()方法读取时序点的value值。在readValue()方法中首先会读取控制位，然后根据控制位确定value值，其具体步骤如下所示：</p>
<ol>
<li>如果控制位的第一个bit位为“0”，则表示当前时序点的value值与前一个value值相同，后续无需进行任何读取操作。否则，读取控制位的第二个bit位。</li>
<li>如果控制位的第二个bit位为“0”，则表示当前XOR结果的前置“0”和后置“0”与前一个XOR结果的个数相同，后续直接读取当前XOR结果中间非零部分即可。</li>
<li>如果控制位的第二个bit位为“1”，则需要先读取当前XOR结果中前置“0”的个数，然后读取XOR结果中间非零部分的长度，最后读取中间非零部分的值。</li>
<li>最后根据前一个点的value值以及XOR运算结果，得到当前点的value值。</li>
</ol>
<p>下面是xorIterator.readValue()方法的具体实现分析：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(it *xorIterator)</span> <span class="title">readValue</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"> bit, err := it.br.readBit() <span class="comment">// 读取控制位的第一个bit位</span></span><br><span class="line"> <span class="keyword">if</span> bit == zero &#123; </span><br><span class="line"> <span class="comment">// 如果控制位第一个bit位为"0"，则表示当前时序点的value值与前一个点的value值相同</span></span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"> bit, err := it.br.readBit() <span class="comment">// 如果控制位第一个bit位为"1"，则需要读取第二个控制位</span></span><br><span class="line"> <span class="keyword">if</span> bit == zero &#123; </span><br><span class="line"> <span class="comment">// 控制位为"10"，则表示可以直接读取XOR值的中间非0部分(因为其前置"0"和后置"0"与前一个</span></span><br><span class="line">  <span class="comment">// XOR结果的个数相同)</span></span><br><span class="line"> &#125; <span class="keyword">else</span> &#123; <span class="comment">// 控制位为"11"，则表示XOR结果中前置"0"和后置"0"与前一个XOR值的个数相同</span></span><br><span class="line"> bits, err := it.br.readBits(<span class="number">5</span>) <span class="comment">// 读取XOR结果中前置"0"的个数(5个bit位)</span></span><br><span class="line"> it.leading = <span class="keyword">uint8</span>(bits) <span class="comment">// 更新leading字段，记录前置"0"的个数</span></span><br><span class="line"> bits, err = it.br.readBits(<span class="number">6</span>) <span class="comment">// 读取XOR结果中非0部分的长度(6个bit位)</span></span><br><span class="line"> mbits := <span class="keyword">uint8</span>(bits)</span><br><span class="line"> <span class="keyword">if</span> mbits == <span class="number">0</span> &#123;</span><br><span class="line"> mbits = <span class="number">64</span></span><br><span class="line"> &#125;</span><br><span class="line"> it.trailing = <span class="number">64</span> - it.leading - mbits <span class="comment">// 计算XOR结果中后置"0"的个数</span></span><br><span class="line"> &#125;</span><br><span class="line"> mbits := <span class="keyword">int</span>(<span class="number">64</span> - it.leading - it.trailing) <span class="comment">// 计算XOR值中非0部分的位数</span></span><br><span class="line"> bits, err := it.br.readBits(mbits) <span class="comment">// 读取XOR结果中非0部分</span></span><br><span class="line"> <span class="comment">// 根据前一个时序点的value值以及XOR值，得到当前点的value值</span></span><br><span class="line"> vbits := math.Float64bits(it.val) </span><br><span class="line"> vbits ^= (bits &lt;&lt; it.trailing)</span><br><span class="line"> it.val = math.Float64frombits(vbits) <span class="comment">// 更新val字段</span></span><br><span class="line"> &#125;</span><br><span class="line"> it.numRead++ <span class="comment">// 此次读取完成，递增numRead字段</span></span><br><span class="line"> <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从前面对xorIterator.Next()方法以及readValue()方法的分析我们可以看到，xorIterator在迭代过程中始终使用t和val字段记录当前时序点的timestamp和value值，在xorIterator.At()方法中也是始终返回这两个字段值，其实现比较简单，这里不再展开介绍。</p>
<h3 id="Pool"><a href="#Pool" class="headerlink" title="Pool"></a>Pool</h3><p>结构体pool是一个内存中的XORChunk实例池，其底层是基于sync.Pool实现的。这里简单介绍一下Golang中的sync.Pool，Golang除了像JVM那样提供了一些垃圾回收的机制，还提供了很多避免产生垃圾对象的机制，例如这里介绍的池化技术。</p>
<p>在Golang标准库的很多包中，都使用了对象池来避免产生过多的垃圾对象，例如我们经常使用的fmt包、regexp包等，都各自实现了对象池，且它们的实现都很类似。另外，这种对象池的实现都不会释放内存，这就会与垃圾收集器的思想产生冲突，在某些场景中导致内存使用过高。</p>
<p>就上述问题，曾有人建议在sync包里加入一个公开的池类型供大家复用。当然，这也面临很多问题，例如，这个池类型应该放到标准库中吗？如果放到标准库中，应该公开吗？这个池类型的实现应该释放内存吗？如果需要释放内存，那在什么时机释放？这个新增的类型应该叫做Cache还是Pool？</p>
<p>这里可以先简单区分一下Cache和Pool的区别。读者可以将Cache理解成一个全局的Map，我们可以根据不同的Key获取到不同的Value，而Pool中的存储的元素完全一样，与刚初始化完成的实例完全一样。另外，Cache会使用不同的过期算法进行清理，例如LRU、LFU、LIRS等等。</p>
<p>大家特别关心另一个点是Pool在何时释放内存。有人建议在GC之前进行释放，也有人建议在在GC之后进行释放，还有人提出基于过期时间或者使用弱引用的方式。虽然这些建议都有自己的理由，但同时也都有一些弊端。最终，Golang官方决定在垃圾收集时释放Pool占用的内存空间，也就是说，Pool中的对象是在两次垃圾收集之间进行重用的。而且，这也突出了Pool的目的是让垃圾回收变得更加高效，而不是避免垃圾回收。</p>
<p>大致了解了sync.pool的设计初衷和目标之后，我们来看Prometheus TSDB中Pool接口的定义，如下所示：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Pool <span class="keyword">interface</span> &#123;</span><br><span class="line"> Put(Chunk) error <span class="comment">// 将Chunk实例放回到池中</span></span><br><span class="line"> Get(e Encoding, b []<span class="keyword">byte</span>) (Chunk, error) <span class="comment">// 根据指定的Encoding从池中获取Chunk实例</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在Prometheus TSDB中提供了该Pool接口的唯一实现——结构体pool，其底层依赖Golang sync.Pool实现，其NewPool()方法实际上就是初始化sync.Pool实例，如下所示：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewPool</span><span class="params">()</span> <span class="title">Pool</span></span> &#123;</span><br><span class="line"> <span class="keyword">return</span> &amp;pool&#123;</span><br><span class="line"> xor: sync.Pool&#123;</span><br><span class="line"> <span class="comment">// 如果调用Pool.Get()方法从池中获取对象时没有可用的Chunk实例，则会通过该函数</span></span><br><span class="line"> <span class="comment">// 创建新的XORChunk实例返回</span></span><br><span class="line"> New: <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125; &#123; <span class="keyword">return</span> &amp;XORChunk&#123;b: &amp;bstream&#123;&#125;&#125; &#125;,</span><br><span class="line"> &#125;,</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结构体pool的Get()方法和Put()方法会先检测Chunk实例的类型，然后调用sync.Pool实现从池中读取Chunk实例以及向池中放回Chunk实例的功能，大致实现如下所示：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *pool)</span> <span class="title">Get</span><span class="params">(e Encoding, b []<span class="keyword">byte</span>)</span> <span class="params">(Chunk, error)</span></span> &#123;</span><br><span class="line"> <span class="keyword">switch</span> e &#123;</span><br><span class="line">  <span class="keyword">case</span> EncXOR:</span><br><span class="line"> c := p.xor.Get().(*XORChunk) <span class="comment">// 从Pool中获取XORChunk实例</span></span><br><span class="line"> c.b.stream = b <span class="comment">// 填充bstream</span></span><br><span class="line"> c.b.count = <span class="number">0</span></span><br><span class="line"> <span class="keyword">return</span> c, <span class="literal">nil</span></span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> <span class="literal">nil</span>, errors.Errorf(<span class="string">"invalid encoding %q"</span>, e)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *pool)</span> <span class="title">Put</span><span class="params">(c Chunk)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"> <span class="keyword">switch</span> c.Encoding() &#123;</span><br><span class="line"> <span class="keyword">case</span> EncXOR:</span><br><span class="line"> xc, ok := c.(*XORChunk) <span class="comment">// 检测传入的Chunk实例的实际类型</span></span><br><span class="line"> xc.b.stream = <span class="literal">nil</span> <span class="comment">// 清空XORChunk底层的bstream</span></span><br><span class="line"> xc.b.count = <span class="number">0</span></span><br><span class="line"> p.xor.Put(c) <span class="comment">// 将XORChunk实例放入到Pool中</span></span><br><span class="line"> <span class="keyword">default</span>:</span><br><span class="line"> <span class="keyword">return</span> errors.Errorf(<span class="string">"invalid encoding %q"</span>, c.Encoding())</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Meta元数据"><a href="#Meta元数据" class="headerlink" title="Meta元数据"></a>Meta元数据</h3><p>通过上一小节的介绍，我们了解到Chunk中存储的都是时序数据，每个Chunk实例都有一些关联的元数据信息，例如Chunk实例所覆盖的时间范围，这些元数据记录到了Meta实例中。结构体Meta的核心字段如下：</p>
<ul>
<li><strong>Ref（uint64类型）</strong>：Ref字段记录了关联Chunk在磁盘上的位置信息，主要用于读取。</li>
<li><strong>Chunk（chunkenc.Chunk类型）</strong>：指向XORChunk实例。在后面介绍ChunkWriter时会看到，在将Chunk中时序数据持久化到文件时，该字段必须有值。</li>
<li><strong>MinTime、MaxTime（int64类型）</strong>：MinTime和MaxTime两个字段记录了Chunk实例所覆盖的时间范围。</li>
</ul>
<p>Meta结构体中提供了两个辅助方法，一个是writeHash()方法，它负责为关联的Chunk计算Hash值。另一个方法是OverlapsClosedInterval()方法，该方法用于确定给定的时间范围是与关联Chunk实例所覆盖的时间范围有重合。如图2-5所示，三种场景下，给定的时间范围都与Chunk有重合。</p>
<p><img src="https://pic3.zhimg.com/80/v2-dbbb8ff29b8dacff29e341677ea5fcea_hd.jpg" alt="img"></p>
<p>Meta结构体中的这两个方法的实现比较简单，这里不再粘贴代码。</p>
<h3 id="ChunkWriter"><a href="#ChunkWriter" class="headerlink" title="ChunkWriter"></a>ChunkWriter</h3><p>通过前面小节的介绍，我们了解到Prometheus TSDB是如何在内存中组织时序数据的，那么这些内存中的时序数据是如何持久化到磁盘上呢？时序数据在磁盘上的组织方式又是什么样子的呢？本小节将通过对ChunkWriter 接口及其实现的分析来解答这些问题。</p>
<p>ChunkWriter是Prometheus TSDB中负责时序数据持久化的接口之一，通过该接口的定义（如下）可以看到其最核心的方法是WriteChunks()，该方法的主要功能就是持久化多个Chunk实例中的时序数据。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ChunkWriter <span class="keyword">interface</span> &#123;</span><br><span class="line"> WriteChunks(chunks ...chunks.Meta) error</span><br><span class="line"> Close() error <span class="comment">// 关闭底层关联的文件资源</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里注意WriteChunks()方法的参数，传入的是多个Meta实例，WriteChunks()方法要求每个Meta实例的Chunk字段必须有值。在完成写入之后，Meta实例的Ref字段也会被自动赋值，用于后面进行读取操作。</p>
<p>chunks.Writer结构体实现了上述ChunkWriter接口，在开始分析chunks.Writer持久化时序数据的实现之前，先回顾一下Prometheus TSDB在磁盘上的目录以及文件结构，如图2-6所示。首先来看目录结构，Prometheus在data目录中维护了多个block目录，这些block目录都是以“b-”开头的，以递增编号结尾，每个block目录维护了一个时间段的时序数据以及相关的元数据。在每个block目录下都有一个index文件，其中维护了索引的相关内容，还有一个meta.json文件，其中维护了block目录相关的元数据，这两个文件的内容在后面详细分析。这里重点来看chunks目录，顾名思义，其中存储的就是前面介绍的Chunk实例中存储的时序数据，chunks目录下的每个文件的大小都有上限（defaultChunkSegmentSize），到达上限之后会切换到新文件继续写入时序数据。为了便于描述，笔者将chunks目录下的文件称为“segment文件”，每个segment文件的名称都是以递增序号进行命名的。</p>
<p><img src="https://pic2.zhimg.com/80/v2-2c1185d7638acd6d5bb341e969ace755_hd.jpg" alt="img"></p>
<p>了解了Prometheus TSDB在磁盘上大致的目录结构之后，再来深入到segment文件中分析一下其存储格式。如图2-7所示，在创建segment文件时，首先会写入一个8字节的文件头，之后才会开始写入Chunk数据。在持久化一个Chunk的时候，会先写入该Chunk中时序数据所占的字节数，然后才写入该Chunk中记录的时序数据，最后计算该Chunk对应的CRC32循环校验码并写入到segment文件中。</p>
<p><img src="https://pic1.zhimg.com/80/v2-177127f2b230e3c88913e7ee9785f7b8_hd.png" alt="img"></p>
<p>了解了Prometheus TSDB存储时序数据的目录结构和文件格式之后，下面正式开始分析chunks.Writer结构体，其核心字段如下所示：</p>
<ul>
<li><strong>dirFile（*os.File类型）</strong>：磁盘上存储时序数据的目录。</li>
<li><strong>files（[]*os.File类型）</strong>：dirFile目录下存储时序数据的segment文件集合，其中只有最后一个segment文件是当前有效的，即当前可以写入数据数据的segment文件，之前的segment文件不可写。</li>
<li><strong>wbuf（*bufio.Writer类型）</strong>：用于写文件的bufio.Writer，该Writer是带缓冲区的。</li>
<li><strong>n（int64类型）</strong>：当前分段已经写入的字节数。</li>
<li><strong>crc32（hash.Hash类型）</strong>：crc32校验码，每一个写入的Chunk都会生成一个校验码。</li>
<li><strong>segmentSize（int64类型）</strong>：每个分段文件的大小上限，默认是512 * 1024 * 1024</li>
</ul>
<p>Prometheus TSDB通过NewWriter()函数创建Writer实例，其中同时还会创建存放segment文件的目录并赋予足够的操作权限，具体实现如下所示：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewWriter</span><span class="params">(dir <span class="keyword">string</span>)</span> <span class="params">(*Writer, error)</span></span> &#123;</span><br><span class="line"> <span class="comment">// 创建dir参数指定的目录，并给予足够的权限(略)</span></span><br><span class="line"> dirFile, err := fileutil.OpenDir(dir) <span class="comment">// 打开该目录</span></span><br><span class="line"> cw := &amp;Writer&#123; <span class="comment">// 初始化Writer实例</span></span><br><span class="line"> dirFile: dirFile,</span><br><span class="line"> n: <span class="number">0</span>,</span><br><span class="line"> crc32: newCRC32(), <span class="comment">// 创建复用的CRC32循环校验码</span></span><br><span class="line"> segmentSize: defaultChunkSegmentSize,</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> cw, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>完成Writer实例的初始化之后，就可以调用其WriteChunks()方法批量写入Chunk数据了。在该方法中，首先会根据此次写入的数据量以及当前segment文件的大小，决定是否要创建并切换到新的segment文件上完成此次写入，之后会按照前面介绍的segment文件的格式，逐个写入Chunk实例中的时序数据。WriteChunks()方法的具体实现如下所示：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *Writer)</span> <span class="title">WriteChunks</span><span class="params">(chks ...Meta)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"> maxLen := <span class="keyword">int64</span>(binary.MaxVarintLen32) <span class="comment">// 计算此次待写入的所有Chunk实例的字节总数</span></span><br><span class="line"> <span class="keyword">for</span> _, c := <span class="keyword">range</span> chks &#123;</span><br><span class="line"> maxLen += binary.MaxVarintLen32 + <span class="number">1</span> </span><br><span class="line"> maxLen += <span class="keyword">int64</span>(<span class="built_in">len</span>(c.Chunk.Bytes()))</span><br><span class="line"> &#125;</span><br><span class="line"> newsz := w.n + maxLen <span class="comment">// 计算写入传入Chunk集合之后，当前segment文件所占的字节数</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">// 如果满足下述三个条件中的任意一个，则会通过cut()方法新建segment文件，此次传入的Chunk集合</span></span><br><span class="line"> <span class="comment">// 将全部写入到新建segment文件中:</span></span><br><span class="line"> <span class="comment">// 1、该chunks.Writer实例第一次写入</span></span><br><span class="line"> <span class="comment">// 2、写入之前，当前segment文件大小已经达到切分的阈值</span></span><br><span class="line"> <span class="comment">// 3、如果将传入Chunk集合写入之后，当前segment文件大小已经达到切分的阈值</span></span><br><span class="line"> <span class="keyword">if</span> w.wbuf == <span class="literal">nil</span> || w.n &gt; w.segmentSize || </span><br><span class="line"> newsz &gt; w.segmentSize &amp;&amp; maxLen &lt;= w.segmentSize &#123;</span><br><span class="line"> <span class="keyword">if</span> err := w.cut(); ... <span class="comment">// 省略错误处理的代码</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">var</span> (</span><br><span class="line"> b = [binary.MaxVarintLen32]<span class="keyword">byte</span>&#123;&#125;</span><br><span class="line"> <span class="comment">// 将当前segment文件在Writer.files集合中的下标，记录到seq变量的高32位中</span></span><br><span class="line"> seq = <span class="keyword">uint64</span>(w.seq()) &lt;&lt; <span class="number">32</span> </span><br><span class="line"> )</span><br><span class="line"> <span class="keyword">for</span> i := <span class="keyword">range</span> chks &#123; <span class="comment">// 将Chunk逐个写入到当前segment文件中</span></span><br><span class="line"> chk := &amp;chks[i]</span><br><span class="line"> <span class="comment">// 更新Ref字段，其中高32位明确了该Chunk在哪个segment文件中，低32位记录了该Chunk</span></span><br><span class="line"> <span class="comment">// 在该segment文件中的字节偏移量。在后面介绍读取过程时，还会看到Ref字段的作用</span></span><br><span class="line"> chk.Ref = seq | <span class="keyword">uint64</span>(w.n)</span><br><span class="line"> <span class="comment">// 统计该Chunk的字节数，并记录到segment文件中</span></span><br><span class="line"> n := binary.PutUvarint(b[:], <span class="keyword">uint64</span>(<span class="built_in">len</span>(chk.Chunk.Bytes())))</span><br><span class="line"> <span class="keyword">if</span> err := w.write(b[:n]); ...</span><br><span class="line"></span><br><span class="line"> b[<span class="number">0</span>] = <span class="keyword">byte</span>(chk.Chunk.Encoding()) <span class="comment">// 将Chunk的编码类型写入到segment文件中</span></span><br><span class="line"> <span class="keyword">if</span> err := w.write(b[:<span class="number">1</span>]); ... <span class="comment">// 省略错误处理的代码</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">// 将Chunk中记录的时序数据写入到segment文件中</span></span><br><span class="line"> <span class="keyword">if</span> err := w.write(chk.Chunk.Bytes()); ... <span class="comment">// 省略错误处理的代码</span></span><br><span class="line">  <span class="comment">// 计算该Chunk的CRC32校验码并写入到segment文件中</span></span><br><span class="line"> w.crc32.Reset()</span><br><span class="line"> <span class="keyword">if</span> err := chk.writeHash(w.crc32); ... <span class="comment">// 省略错误处理的代码</span></span><br><span class="line"> <span class="keyword">if</span> err := w.write(w.crc32.Sum(b[:<span class="number">0</span>])); ... <span class="comment">// 省略错误处理的代码</span></span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在WriteChunks()方法中我们看到，无论是首次写入还是达到segment文件大小上限值，都会调用cut()方法。在cut()方法中会按序完成下列操作，实现segment文件的切换：</p>
<ol>
<li>调用finalizeTail()方法结束当前文件的写入。</li>
<li>获取新segment文件的名称，并创建对应的新segment文件。在新segment文件名的计算方式大致是：先获取当前目录下全部segment文件名并进行排序，正如前面在目录结构中介绍的那样，segment文件名中都是包含数字编号的，新segment文件名称就是当前最大的编号+1。该过程在nextSequenceFile()方法中实现，感兴趣的读者可以参考其代码进行学习，这里不再展开分析。</li>
<li>按照segmentSize字段指定的大小为新segment文件预分配空间。</li>
<li>向新segment文件写入8字节的文件头。</li>
<li>将新segment文件记录到Writer.files切片的末尾。</li>
</ol>
<p>Writer.cut()方法具体实现如下所示：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *Writer)</span> <span class="title">cut</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line"> <span class="comment">// 通过finalizeTail()方法完成当前文件的写入，其具体实现在后面详细介绍</span></span><br><span class="line"> <span class="keyword">if</span> err := w.finalizeTail(); ... </span><br><span class="line"> p, _, err := nextSequenceFile(w.dirFile.Name()) <span class="comment">// 计算下一个写入的新segment文件的名称</span></span><br><span class="line"></span><br><span class="line"> f, err := os.OpenFile(p, os.O_WRONLY|os.O_CREATE, <span class="number">0666</span>) <span class="comment">// 创建新segment文件</span></span><br><span class="line"> <span class="comment">// 按照segment文件大小的上限进行预分配</span></span><br><span class="line"> <span class="keyword">if</span> err = fileutil.Preallocate(f, w.segmentSize, <span class="literal">true</span>); ...</span><br><span class="line"> <span class="keyword">if</span> err = w.dirFile.Sync();... <span class="comment">// 将上述segment文件创建以及预分配操作同步到磁盘</span></span><br><span class="line"></span><br><span class="line"> metab := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">8</span>) <span class="comment">// 创建文件头，共占8个字节</span></span><br><span class="line"> binary.BigEndian.PutUint32(metab[:<span class="number">4</span>], MagicChunks) <span class="comment">// 前4个字节写入固定头信息</span></span><br><span class="line"> metab[<span class="number">4</span>] = chunksFormatV1 <span class="comment">// 写入版本信息</span></span><br><span class="line"> <span class="keyword">if</span> _, err := f.Write(metab); ... <span class="comment">// 将8字节文件头写入到segment文件中</span></span><br><span class="line"> w.files = <span class="built_in">append</span>(w.files, f) <span class="comment">// 将新建的segment文件记录到Writer.files集合中</span></span><br><span class="line"> <span class="keyword">if</span> w.wbuf != <span class="literal">nil</span> &#123;</span><br><span class="line"> w.wbuf.Reset(f) <span class="comment">// 将wbuf从上一个文件指向新建的文件</span></span><br><span class="line"> &#125; <span class="keyword">else</span> &#123; <span class="comment">// 第一次写入时会初始化wbuf字段，其缓冲区为8M</span></span><br><span class="line"> w.wbuf = bufio.NewWriterSize(f, <span class="number">8</span>*<span class="number">1024</span>*<span class="number">1024</span>)</span><br><span class="line"> &#125;</span><br><span class="line"> w.n = <span class="number">8</span> <span class="comment">// 已写入文件头，占用8个字节</span></span><br><span class="line"> <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Writer.finalizeTail()方法主要完成了两件事，一是将已写入当前segment文件的时序数据刷新到磁盘中，二是对当前segment文件中预分配但是未使用的部分进行截断，最后关闭文件，其具体实现如下所示：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *Writer)</span> <span class="title">finalizeTail</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line"> tf := w.tail() <span class="comment">// 获取files集合中最后一个文件，即当前有效的写入文件</span></span><br><span class="line"> <span class="comment">// 调用wbuf字段(bufio.Writer)的Flush()方法将数据刷新到磁盘中(略)</span></span><br><span class="line"> <span class="keyword">if</span> err := w.wbuf.Flush();...<span class="comment">// 省略异常处理的相关代码</span></span><br><span class="line"> <span class="keyword">if</span> err := fileutil.Fsync(tf);... <span class="comment">// 省略异常处理的相关代码</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">// 前面在创建文件时会进行预分配，这里获取当前写入的位置，并调用Truncate()方法进行截断，</span></span><br><span class="line"> <span class="comment">// 将该文件中off之后的预分配的内容删掉</span></span><br><span class="line"> off, err := tf.Seek(<span class="number">0</span>, io.SeekCurrent)</span><br><span class="line"> <span class="keyword">if</span> err := tf.Truncate(off);...</span><br><span class="line"> <span class="keyword">return</span> tf.Close() <span class="comment">// 关闭当前文件</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到此为止，ChunkWriter接口及其具体实现的内容就全部介绍完了。</p>
<h3 id="ChunkReader"><a href="#ChunkReader" class="headerlink" title="ChunkReader"></a>ChunkReader</h3><p>介绍完Prometheus TSDB持久化时序数据的相关实现之后，我们继续分析Prometheus TSDB如何将持久化的时序数据读取到内存中，并封装到相应的Chunk实例中。</p>
<p>首先来看读取时序数据的核心接口——ChunkReader，该接口的Chunk()方法会根据ref参数读取对应的Chunk并返回，这里的ref参数就是前面在写入Chunk实例时为其填充的Ref字段。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ChunkReader <span class="keyword">interface</span> &#123;</span><br><span class="line"> Chunk(ref <span class="keyword">uint64</span>) (chunkenc.Chunk, error) <span class="comment">// 根据ref参数读取相应的Chunk实例</span></span><br><span class="line"> Close() error <span class="comment">// 关闭当前ChunkReader并释放所有资源</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Prometheus TSDB中有多个 ChunkReader接口的实现，如图2-8所示，本小节主要介绍的是其中chunks.Reader实现，剩余两个实现在后面涉及到时再做描述。</p>
<p><img src="https://pic2.zhimg.com/80/v2-4b293fb68fc8c594597ff334ffa82985_hd.jpg" alt="img"></p>
<p>chunks.Reader结构体中的核心字段如下：</p>
<ul>
<li><strong>bs（[]ByteSlice类型）</strong>：ByteSlice接口是对byte切片的抽象，它提供了两个方法，一个是Len()方法，用于返回底层byte切片的长度，另一个方法是Range()方法，用于返回底层byte切片在指定区间内的数据。ByteSlice接口的实现是realByteSlice，realByteSlice则是[]byte的类型别名。bs字段存储的是时序数据，其中每个ByteSlice实例都对应一个segment文件的数据。</li>
<li><strong>cs（[]io.Closer类型）</strong>：当前Reader实例能够读取的文件集合，其中每个元素都对应一个segment文件。</li>
<li><strong>pool（chunkenc.Pool类型）</strong>：用于存储可重用的Chunk实例。</li>
</ul>
<p>在开始介绍chunks.Reader如何读取segment文件之前，我们先来简单介绍mmap相关的基础知识。</p>
<p><strong>mmap简介</strong></p>
<p>从Linux系统的角度来看，操作系统的内存空间被分为两大部分，分别是：内核空间、用户空间，其中“用户空间”和“内核空间”的空间大小、操作权限以及核心功能都是不尽相同。这里的“内核空间”是操作系统本身使用的内存空间，而“用户空间”则是提供给各个进程使用的内存空间。用户进程不具有访问内核资源的权限，例如访问硬件资源，因此一个用户进程需要使用内核资源的时候，就需要通过系统调用来完成。图2-9以读写磁盘文件为例，展示了用户进程进行系统调用的整个过程：</p>
<ol>
<li>首先是读取文件的过程，用户进程发出read()系统调用之后，会完成从用户态到内核态的上下文切换。之后会通过DMA将文件中的数据从磁盘拷贝到内核空间的缓冲区中。</li>
<li>将内核空间缓冲区的数据拷贝到用户空间的缓冲区中，然后read()系统调用返回，此时会完成从内核态到用户态的上下文切换，整个读取文件的过程结束。</li>
<li>之后是写入文件的过程，用户进程发出write()系统调用之后，会完成用户态到内核态的上下文切换。将数据从用户空间缓冲区拷贝到内核空间缓冲区。</li>
<li>最后，write()系统调用返回，同时进程会从内核态切换到用户态。而数据则将从内核缓冲区写入磁盘。到此为止，整个写入文件的过程结束。</li>
</ol>
<p><img src="https://pic1.zhimg.com/80/v2-56ad08b8c2261392a38d8ca51ee9e150_hd.jpg" alt="img"></p>
<p>所以一次文件读取过程涉及两次数据拷贝以及两次上下文切换，同理，一次文件写入过程也会涉及两次数据拷贝以及两次上下文切换。</p>
<p>mmap是操作系统提供的内存映射机制，它可以将磁盘上一个文件中的一部分映射到一个虚拟内存区域上，这样程序就可以像操作内存一样操作文件。mmap也是实现“零拷贝”的一种方式，其大致原理如下：</p>
<ol>
<li>用户进程发出mmap()系统调用之后，会完成从用户态到内核态的上下文切换。然后通过DMA将磁盘文件中的数据拷贝到内核空间的缓冲区中。</li>
<li>mmap()系统调用返回，用户进程会完成从内核态到用户态的上下文切换。接着用户空间和内核空间共享这个缓冲区，而不需要将其中的数据从内核空间拷贝到用户空间。因为用户空间和内核空间共享了这个缓冲区数据，所以用户空间就可以像在操作自己缓冲区中数据一般操作这个由内核空间共享的缓冲区。</li>
<li>在写入文件的时候，用户进程发出write()系统调用，用户进程从用户态切换到内核态，并向共享缓冲区中写入数据。</li>
<li>完成数据写入之后，write()系统调用返回，用户进程从内核态切换到用户态，同时会通过DMA将内核缓冲区中的数据刷新到磁盘中。</li>
</ol>
<p>mmap的工作原理如下图所示，其上下文切换的次数与前面介绍的传统I/O相同，在图2-10中也就没用展示，但是mmap进行内存拷贝的次数要比传统I/O的少：</p>
<p><img src="https://pic1.zhimg.com/80/v2-86e040f86279bb591fbd347490849060_hd.jpg" alt="img"></p>
<p>了解了mmap的原理之后，我们继续回到chunks.Reader进行分析。首先来看其初始化过程，该过程由chunks.NewDirReader()函数完成，该函数首先会获取指定chunks目录下的所有segment文件名并进行排序，然后通过mmap系统调用将segment文件映射到虚拟内存中，之后校验每个segment文件的内容是否合法（即segment文件开头是否为固定的MagicChunks文件头），最后创建对应的Reader实例。NewDirReader()函数的具体实现如下所示：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewDirReader</span><span class="params">(dir <span class="keyword">string</span>, pool chunkenc.Pool)</span> <span class="params">(*Reader, error)</span></span> &#123;</span><br><span class="line"> <span class="comment">// sequenceFiles()函数会读取指定chunks文件夹中的分段文件并按照文件名进行排序，这里不再展开</span></span><br><span class="line"> <span class="comment">// 介绍其具体实现，感兴趣的读者可以参考其源码进行学习</span></span><br><span class="line"> files, err := sequenceFiles(dir) </span><br><span class="line"> <span class="keyword">if</span> pool == <span class="literal">nil</span> &#123; <span class="comment">// 初始化Chunk池</span></span><br><span class="line"> pool = chunkenc.NewPool()</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">var</span> bs []ByteSlice</span><br><span class="line"> <span class="keyword">var</span> cs []io.Closer</span><br><span class="line"> <span class="keyword">for</span> _, fn := <span class="keyword">range</span> files &#123;</span><br><span class="line"> f, err := fileutil.OpenMmapFile(fn) <span class="comment">// 通过mmap系统调用将当前整个segment文件映射到内存</span></span><br><span class="line"> cs = <span class="built_in">append</span>(cs, f) <span class="comment">// 将映射得到的MmapFile实例追加到cs切片中</span></span><br><span class="line"> bs = <span class="built_in">append</span>(bs, realByteSlice(f.Bytes())) <span class="comment">// 将segment文件映射到bs切片中</span></span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> newReader(bs, cs, pool) <span class="comment">// 其中完成文件头的校验以及Reader实例的创建</span></span><br><span class="line">&#125;</span><br><span class="line">下面再来看Reader.Chunk()方法，该方法会根据传入的ref参数在当前chunks目录中查找对应Chunk数据位置，然后从Chunk池中获取一个空闲Chunk实例，最后从文件中读取时序数据填充到Chunk实例中，并将其返回。Chunk()方法的具体实现如下所示：</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Reader)</span> <span class="title">Chunk</span><span class="params">(ref <span class="keyword">uint64</span>)</span> <span class="params">(chunkenc.Chunk, error)</span></span> &#123;</span><br><span class="line"> <span class="keyword">var</span> (</span><br><span class="line"> seq = <span class="keyword">int</span>(ref &gt;&gt; <span class="number">32</span>) <span class="comment">// 从ref参数的高32位中获取对应Chunk所在的segment文件编号</span></span><br><span class="line"> <span class="comment">// 从ref参数的低32位中获取Chunk在该segment文件中的字节偏移量</span></span><br><span class="line">  off = <span class="keyword">int</span>((ref &lt;&lt; <span class="number">32</span>) &gt;&gt; <span class="number">32</span>) </span><br><span class="line"> )</span><br><span class="line"> <span class="comment">// 检测seq编号是否合法，即检测seq编号是否大于chunks目录中最大编号(略)</span></span><br><span class="line"> b := s.bs[seq]</span><br><span class="line"> <span class="comment">// 查找到正确的segment文件之后，检测off偏移量是否合法，即检测off偏移量是否超过了</span></span><br><span class="line"> <span class="comment">// 该segment文件的大小(略)</span></span><br><span class="line"> <span class="comment">// 确定该Chunk所在的segment文件以及其在segment文件中的偏移量之后，下面会读取Chunk在文件</span></span><br><span class="line"> <span class="comment">// 中所占的字节数</span></span><br><span class="line">  r := b.Range(off, off+binary.MaxVarintLen32)</span><br><span class="line"> l, n := binary.Uvarint(r)</span><br><span class="line"> <span class="keyword">if</span> n &lt;= <span class="number">0</span> &#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="literal">nil</span>, errors.Errorf(<span class="string">"reading chunk length failed with %d"</span>, n)</span><br><span class="line"> &#125;</span><br><span class="line"> r = b.Range(off+n, off+n+<span class="keyword">int</span>(l)) <span class="comment">// 获取ref对应的时序数据</span></span><br><span class="line"> <span class="comment">// 从Chunk池中获取一个空闲的Chunk实例，并将Encoding方式以及时序数据填充进去</span></span><br><span class="line"> <span class="keyword">return</span> s.pool.Get(chunkenc.Encoding(r[<span class="number">0</span>]), r[<span class="number">1</span>:<span class="number">1</span>+l])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后，Reader.Close()方法会关闭当前Reader实例底层涉及到的全部segment文件，其实现比较简单，这里不再展开分析，感兴趣的读者可以参考其代码进行学习。</p>
<p><a href="https://link.jianshu.com/?t=https%3A%2F%2Fgodoc.org%2Fgithub.com%2Fprometheus%2Ftsdb%2Ffileutil" target="_blank" rel="noopener">fileutil</a> 提供了一些操作文件/目录的函数, 处理了不同平台 (主要是 win) 的兼容性问题.</p>
<h2 id="index"><a href="#index" class="headerlink" title="index"></a>index</h2><p><a href="https://link.jianshu.com?t=https%3A%2F%2Fgodoc.org%2Fgithub.com%2Fprometheus%2Ftsdb%2Findex" target="_blank" rel="noopener">index</a> 实现针对 labels 的索引.</p>
<p>在 prometheus/tsdb 中, 认为 labels + timestamp + value 是一个完整的数据点</p>
<p>chunks 相关的代码用于存储 timestamp + value, 而 index 则是对于 labels 的处理.</p>
<h5 id="encbuf-decbuf"><a href="#encbuf-decbuf" class="headerlink" title="encbuf, decbuf"></a>encbuf, decbuf</h5><p>作为 buffer 在 index 数据编码/解码时进行 复用</p>
<p>实际上这里也定义了一些数据格式如何进行存储</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// putVarintStr writes a string to the buffer prefixed by its varint length (in bytes!).</span></span><br><span class="line"><span class="comment">// 对于字符串, 分别写入长度及字符串本身</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *encbuf)</span> <span class="title">putUvarintStr</span><span class="params">(s <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    b := *(*[]<span class="keyword">byte</span>)(unsafe.Pointer(&amp;s))</span><br><span class="line">    e.putUvarint(<span class="built_in">len</span>(b))</span><br><span class="line">    e.putString(s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 相应地, 在解码时也会先确定 str 长度, 再从整个 []byte 中取出必要的部分</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *decbuf)</span> <span class="title">uvarintStr</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    l := d.uvarint64()</span><br><span class="line">    <span class="keyword">if</span> d.e != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(d.b) &lt; <span class="keyword">int</span>(l) &#123;</span><br><span class="line">        d.e = errInvalidSize</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span></span><br><span class="line">    &#125;</span><br><span class="line">    s := <span class="keyword">string</span>(d.b[:l])</span><br><span class="line">    d.b = d.b[l:]</span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="indexWriterSeries"><a href="#indexWriterSeries" class="headerlink" title="indexWriterSeries"></a>indexWriterSeries</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> indexWriterSeries <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// labels 的实际内容, 即 kv 对</span></span><br><span class="line">    labels labels.Labels</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 这里重要的实际是 Meta.Ref, 即每个 chunk 对应的文件/起点</span></span><br><span class="line">    chunks []chunks.Meta <span class="comment">// series file offset of chunks</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 这里是 labels 数据在文件中的 offset</span></span><br><span class="line">    offset <span class="keyword">uint32</span>        <span class="comment">// index file offset of series reference</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="indexTOC"><a href="#indexTOC" class="headerlink" title="indexTOC"></a>indexTOC</h5><p>index table of contents, 记录 index 不同类型数据的位置</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> indexTOC <span class="keyword">struct</span> &#123;</span><br><span class="line">    symbols           <span class="keyword">uint64</span></span><br><span class="line">    series            <span class="keyword">uint64</span></span><br><span class="line">    labelIndices      <span class="keyword">uint64</span></span><br><span class="line">    labelIndicesTable <span class="keyword">uint64</span></span><br><span class="line">    postings          <span class="keyword">uint64</span></span><br><span class="line">    postingsTable     <span class="keyword">uint64</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Writer"><a href="#Writer" class="headerlink" title="Writer"></a>Writer</h5><p>实现 <a href="https://link.jianshu.com?t=https%3A%2F%2Fgithub.com%2Fprometheus%2Ftsdb%2Fblob%2Fd45b595a1daefad23c09a2d994bf956f8b5f15a9%2Fblock.go%23L32-L58" target="_blank" rel="noopener">IndexWriter</a> , 基于文件的 index 存储</p>
<p>index 的文件格式要比 chunk 复杂的多, 可以参考 <a href="https://link.jianshu.com?t=https%3A%2F%2Fgithub.com%2Fprometheus%2Ftsdb%2Fblob%2Fd45b595a1daefad23c09a2d994bf956f8b5f15a9%2FDocumentation%2Fformat%2Findex.md" target="_blank" rel="noopener">Documentation/format/index.md</a></p>
<p>每个 index 文件的写入分为 5 个阶段, 顺序执行.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> indexWriterStage <span class="keyword">uint8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    idxStageNone indexWriterStage = <span class="literal">iota</span></span><br><span class="line">    idxStageSymbols</span><br><span class="line">    idxStageSeries</span><br><span class="line">    idxStageLabelIndex</span><br><span class="line">    idxStagePostings</span><br><span class="line">    idxStageDone</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// ensureStage handles transitions between write stages and ensures that IndexWriter</span></span><br><span class="line"><span class="comment">// methods are called in an order valid for the implementation.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *Writer)</span> <span class="title">ensureStage</span><span class="params">(s indexWriterStage)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> w.stage == s &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 排在当前阶段之前的, 不可再执行</span></span><br><span class="line">    <span class="keyword">if</span> w.stage &gt; s &#123;</span><br><span class="line">        <span class="keyword">return</span> errors.Errorf(<span class="string">"invalid stage %q, currently at %q"</span>, s, w.stage)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Mark start of sections in table of contents.</span></span><br><span class="line">    <span class="keyword">switch</span> s &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行到完成阶段时, 自动写入必要的辅助信息</span></span><br><span class="line">    <span class="keyword">case</span> idxStageDone:</span><br><span class="line">        w.toc.labelIndicesTable = w.pos</span><br><span class="line">        <span class="keyword">if</span> err := w.writeOffsetTable(w.labelIndexes); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> err</span><br><span class="line">        &#125;</span><br><span class="line">        w.toc.postingsTable = w.pos</span><br><span class="line">        <span class="keyword">if</span> err := w.writeOffsetTable(w.postings); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> err</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> err := w.writeTOC(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> err</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    w.stage = s</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>AddSymbols</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *Writer)</span> <span class="title">AddSymbols</span><span class="params">(sym <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">struct</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> err := w.ensureStage(idxStageSymbols); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> errors.Wrap(err, <span class="string">"write symbols"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>label 中的每一个键或值都是一个 symbol.</p>
<p>通过 “使用对 symbol 的引用” 的方式, 来缩减后续索引文件中的空间占用.</p>
<p><strong>AddSeries</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *Writer)</span> <span class="title">AddSeries</span><span class="params">(ref <span class="keyword">uint64</span>, lset labels.Labels, chunks ...chunks.Meta)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> err := w.ensureStage(idxStageSeries); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> labels.Compare(lset, w.lastSeries) &lt;= <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> errors.Errorf(<span class="string">"out-of-order series added with label set %q"</span>, lset)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记录每个时间序列的位置</span></span><br><span class="line">    <span class="keyword">if</span> _, ok := w.seriesOffsets[ref]; ok &#123;</span><br><span class="line">        <span class="keyword">return</span> errors.Errorf(<span class="string">"series with reference %d already added"</span>, ref)</span><br><span class="line">    &#125;</span><br><span class="line">    w.seriesOffsets[ref] = w.pos</span><br><span class="line"></span><br><span class="line">    w.buf2.reset()</span><br><span class="line">    w.buf2.putUvarint(<span class="built_in">len</span>(lset))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对于每个 label, 分别记录 它的 name 和 value 在索引文件中的位置</span></span><br><span class="line">    <span class="keyword">for</span> _, l := <span class="keyword">range</span> lset &#123;</span><br><span class="line">        offset, ok := w.symbols[l.Name]</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">        offset, ok = w.symbols[l.Value]</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    w.buf2.putUvarint(<span class="built_in">len</span>(chunks))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对于 chunk 数据, 记录它覆盖的时间范围, 以及存储地址</span></span><br><span class="line">    <span class="comment">// 除第一个 chunk 外, 其他记录的都是变化量</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(chunks) &gt; <span class="number">0</span> &#123;</span><br><span class="line">        c := chunks[<span class="number">0</span>]</span><br><span class="line">        w.buf2.putVarint64(c.MinTime)</span><br><span class="line">        w.buf2.putUvarint64(<span class="keyword">uint64</span>(c.MaxTime - c.MinTime))</span><br><span class="line">        w.buf2.putUvarint64(c.Ref)</span><br><span class="line">        t0 := c.MaxTime</span><br><span class="line">        ref0 := <span class="keyword">int64</span>(c.Ref)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> _, c := <span class="keyword">range</span> chunks[<span class="number">1</span>:] &#123;</span><br><span class="line">            w.buf2.putUvarint64(<span class="keyword">uint64</span>(c.MinTime - t0))</span><br><span class="line">            w.buf2.putUvarint64(<span class="keyword">uint64</span>(c.MaxTime - c.MinTime))</span><br><span class="line">            t0 = c.MaxTime</span><br><span class="line"></span><br><span class="line">            w.buf2.putVarint64(<span class="keyword">int64</span>(c.Ref) - ref0)</span><br><span class="line">            ref0 = <span class="keyword">int64</span>(c.Ref)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>WriteLabelIndex</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里传入的参数可以认为是下述结构</span></span><br><span class="line"><span class="comment">// 其中每一组 value 都是 names 的一组取值组合</span></span><br><span class="line"><span class="comment">// type Label struct &#123;</span></span><br><span class="line"><span class="comment">//  names []string</span></span><br><span class="line"><span class="comment">//  valus [][]string</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *Writer)</span> <span class="title">WriteLabelIndex</span><span class="params">(names []<span class="keyword">string</span>, values []<span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(values)%<span class="built_in">len</span>(names) != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> errors.Errorf(<span class="string">"invalid value list length %d for %d names"</span>, <span class="built_in">len</span>(values), <span class="built_in">len</span>(names))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> err := w.ensureStage(idxStageLabelIndex); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> errors.Wrap(err, <span class="string">"ensure stage"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 所有 hash entry 会统一在后续阶段写入</span></span><br><span class="line">    w.labelIndexes = <span class="built_in">append</span>(w.labelIndexes, hashEntry&#123;</span><br><span class="line">        keys:   names,</span><br><span class="line">        offset: w.pos,</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对于每个 value, 都只写入引用值</span></span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> valt.s &#123;</span><br><span class="line">        offset, ok := w.symbols[v]</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    err = w.write(w.buf1.get(), w.buf2.get())</span><br><span class="line">    <span class="keyword">return</span> errors.Wrap(err, <span class="string">"write label index"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>WritePostings</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Postings 用来记录每一个 label (一对 name, value) 对应了哪些数据块, 用于检索</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *Writer)</span> <span class="title">WritePostings</span><span class="params">(name, value <span class="keyword">string</span>, it Postings)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 每一对 name-value 对应的数据位置</span></span><br><span class="line">    w.postings = <span class="built_in">append</span>(w.postings, hashEntry&#123;</span><br><span class="line">        keys:   []<span class="keyword">string</span>&#123;name, value&#125;,</span><br><span class="line">        offset: w.pos,</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Order of the references in the postings list does not imply order</span></span><br><span class="line">    <span class="comment">// of the series references within the persisted block they are mapped to.</span></span><br><span class="line">    <span class="comment">// We have to sort the new references again.</span></span><br><span class="line">    refs := w.uint32s[:<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> it.Next() &#123;</span><br><span class="line">        offset, ok := w.seriesOffsets[it.At()]</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        </span><br><span class="line">        refs = <span class="built_in">append</span>(refs, <span class="keyword">uint32</span>(offset))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> err := it.Err(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    sort.Sort(uint32slice(refs))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    err := w.write(w.buf1.get(), w.buf2.get())</span><br><span class="line">    <span class="keyword">return</span> errors.Wrap(err, <span class="string">"write postings"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Close</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *Writer)</span> <span class="title">Close</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="comment">// 这里会自动执行 labelIndexes, postings, toc 的写入</span></span><br><span class="line">    <span class="keyword">if</span> err := w.ensureStage(idxStageDone); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 文件落盘</span></span><br><span class="line">    <span class="keyword">if</span> err := w.fbuf.Flush(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> err := fileutil.Fsync(w.f); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> w.f.Close()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// writeOffsetTable writes a sequence of readable hash entries.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *Writer)</span> <span class="title">writeOffsetTable</span><span class="params">(entries []hashEntry)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    w.buf2.reset()</span><br><span class="line">    w.buf2.putBE32int(<span class="built_in">len</span>(entries))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _, e := <span class="keyword">range</span> entries &#123;</span><br><span class="line">        w.buf2.putUvarint(<span class="built_in">len</span>(e.keys))</span><br><span class="line">        <span class="keyword">for</span> _, k := <span class="keyword">range</span> e.keys &#123;</span><br><span class="line">            w.buf2.putUvarintStr(k)</span><br><span class="line">        &#125;</span><br><span class="line">        w.buf2.putUvarint64(e.offset)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    w.buf1.reset()</span><br><span class="line">    w.buf1.putBE32int(w.buf2.<span class="built_in">len</span>())</span><br><span class="line">    w.buf2.putHash(w.crc32)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> w.write(w.buf1.get(), w.buf2.get())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *Writer)</span> <span class="title">writeTOC</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    w.buf1.reset()</span><br><span class="line"></span><br><span class="line">    w.buf1.putBE64(w.toc.symbols)</span><br><span class="line">    w.buf1.putBE64(w.toc.series)</span><br><span class="line">    w.buf1.putBE64(w.toc.labelIndices)</span><br><span class="line">    w.buf1.putBE64(w.toc.labelIndicesTable)</span><br><span class="line">    w.buf1.putBE64(w.toc.postings)</span><br><span class="line">    w.buf1.putBE64(w.toc.postingsTable)</span><br><span class="line"></span><br><span class="line">    w.buf1.putHash(w.crc32)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> w.write(w.buf1.get())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Reader"><a href="#Reader" class="headerlink" title="Reader"></a>Reader</h5><p>实现了 <a href="https://link.jianshu.com/?t=https%3A%2F%2Fgithub.com%2Fprometheus%2Ftsdb%2Fblob%2Fd45b595a1daefad23c09a2d994bf956f8b5f15a9%2Fblock.go%23L61-L89" target="_blank" rel="noopener">IndexReader</a></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newReader</span><span class="params">(b ByteSlice, c io.Closer)</span> <span class="params">(*Reader, error)</span></span> &#123;</span><br><span class="line">    r := &amp;Reader&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Verify magic number.</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// toc 在文件尾部, 且长度固定, 因此可以直接读出</span></span><br><span class="line">    <span class="keyword">if</span> err := r.readTOC(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, errors.Wrap(err, <span class="string">"read TOC"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> err := r.readSymbols(<span class="keyword">int</span>(r.toc.symbols)); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, errors.Wrap(err, <span class="string">"read symbols"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> err error</span><br><span class="line"></span><br><span class="line">    err = r.readOffsetTable(r.toc.labelIndicesTable, <span class="function"><span class="keyword">func</span><span class="params">(key []<span class="keyword">string</span>, off <span class="keyword">uint32</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">        <span class="comment">// 不知道这里为什么会强制长度为 1?</span></span><br><span class="line">        <span class="comment">// 根据 Writer.WriteLabelIndex 的定义, 明显是支持多 names 的</span></span><br><span class="line">        <span class="comment">// 实际验证, 多 names 写入没有问题, 但在读取的时候会在这里报错</span></span><br><span class="line">        <span class="comment">// 等待后续看相关代码来理解吧.</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(key) != <span class="number">1</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> errors.Errorf(<span class="string">"unexpected key length %d"</span>, <span class="built_in">len</span>(key))</span><br><span class="line">        &#125;</span><br><span class="line">        r.labels[key[<span class="number">0</span>]] = off</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, errors.Wrap(err, <span class="string">"read label index table"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    err = r.readOffsetTable(r.toc.postingsTable, <span class="function"><span class="keyword">func</span><span class="params">(key []<span class="keyword">string</span>, off <span class="keyword">uint32</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, errors.Wrap(err, <span class="string">"read postings table"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    r.dec = &amp;DecoderV1&#123;symbols: r.symbols&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> r, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Postings"><a href="#Postings" class="headerlink" title="Postings"></a>Postings</h5><p>Posting 及其实现的具体作用, 待阅读剩余部分的代码后再回过头来确认.</p>
<p>这是一个 Iterator.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Postings provides iterative access over a postings list.</span></span><br><span class="line"><span class="keyword">type</span> Postings <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="comment">// Next advances the iterator and returns true if another value was found.</span></span><br><span class="line">    Next() <span class="keyword">bool</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Seek advances the iterator to value v or greater and returns</span></span><br><span class="line">    <span class="comment">// true if a value was found.</span></span><br><span class="line">    Seek(v <span class="keyword">uint64</span>) <span class="keyword">bool</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// At returns the value at the current iterator position.</span></span><br><span class="line">    At() <span class="keyword">uint64</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Err returns the last error of the iterator.</span></span><br><span class="line">    Err() error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>给出了 Posting 的交集, 并集, 以及差集实现</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Intersect returns a new postings list over the intersection of the</span></span><br><span class="line"><span class="comment">// input postings.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Intersect</span><span class="params">(its ...Postings)</span> <span class="title">Postings</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> <span class="built_in">len</span>(its) == <span class="number">0</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> emptyPostings</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> <span class="built_in">len</span>(its) == <span class="number">1</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> its[<span class="number">0</span>]</span><br><span class="line">  &#125;</span><br><span class="line">  l := <span class="built_in">len</span>(its) / <span class="number">2</span></span><br><span class="line">  <span class="keyword">return</span> newIntersectPostings(Intersect(its[:l]...), Intersect(its[l:]...))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> intersectPostings <span class="keyword">struct</span> &#123;</span><br><span class="line">  a, b     Postings</span><br><span class="line">  aok, bok <span class="keyword">bool</span></span><br><span class="line">  cur      <span class="keyword">uint64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Merge returns a new iterator over the union of the input iterators.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Merge</span><span class="params">(its ...Postings)</span> <span class="title">Postings</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> <span class="built_in">len</span>(its) == <span class="number">0</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> EmptyPostings()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> <span class="built_in">len</span>(its) == <span class="number">1</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> its[<span class="number">0</span>]</span><br><span class="line">  &#125;</span><br><span class="line">  l := <span class="built_in">len</span>(its) / <span class="number">2</span></span><br><span class="line">  <span class="keyword">return</span> newMergedPostings(Merge(its[:l]...), Merge(its[l:]...))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> mergedPostings <span class="keyword">struct</span> &#123;</span><br><span class="line">  a, b        Postings</span><br><span class="line">  initialized <span class="keyword">bool</span></span><br><span class="line">  aok, bok    <span class="keyword">bool</span></span><br><span class="line">  cur         <span class="keyword">uint64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Without returns a new postings list that contains all elements from the full list that</span></span><br><span class="line"><span class="comment">// are not in the drop list</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Without</span><span class="params">(full, drop Postings)</span> <span class="title">Postings</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> newRemovedPostings(full, drop)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> removedPostings <span class="keyword">struct</span> &#123;</span><br><span class="line">  full, remove Postings</span><br><span class="line"></span><br><span class="line">  cur <span class="keyword">uint64</span></span><br><span class="line"></span><br><span class="line">  initialized <span class="keyword">bool</span></span><br><span class="line">  fok, rok    <span class="keyword">bool</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>给出了几种特定类型的 Postings</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// EmptyPostings returns a postings list that's always empty.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">EmptyPostings</span><span class="params">()</span> <span class="title">Postings</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> emptyPostings</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ErrPostings returns new postings that immediately error.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ErrPostings</span><span class="params">(err error)</span> <span class="title">Postings</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> errPostings&#123;err&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// listPostings implements the Postings interface over a plain list.</span></span><br><span class="line"><span class="keyword">type</span> listPostings <span class="keyword">struct</span> &#123;</span><br><span class="line">  list []<span class="keyword">uint64</span></span><br><span class="line">  cur  <span class="keyword">uint64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// bigEndianPostings implements the Postings interface over a byte stream of</span></span><br><span class="line"><span class="comment">// big endian numbers.</span></span><br><span class="line"><span class="keyword">type</span> bigEndianPostings <span class="keyword">struct</span> &#123;</span><br><span class="line">  list []<span class="keyword">byte</span></span><br><span class="line">  cur  <span class="keyword">uint32</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="MemPostings"><a href="#MemPostings" class="headerlink" title="MemPostings"></a>MemPostings</h5><p>label - posting idx 的映射记录器</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MemPostings holds postings list for series ID per label pair. They may be written</span></span><br><span class="line"><span class="comment">// to out of order.</span></span><br><span class="line"><span class="comment">// ensureOrder() must be called once before any reads are done. This allows for quick</span></span><br><span class="line"><span class="comment">// unordered batch fills on startup.</span></span><br><span class="line"><span class="keyword">type</span> MemPostings <span class="keyword">struct</span> &#123;</span><br><span class="line">    mtx     sync.RWMutex</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// label 和 posting id 的关联</span></span><br><span class="line">    m       <span class="keyword">map</span>[labels.Label][]<span class="keyword">uint64</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 成功执行 EnsureOrder 之后置为 true</span></span><br><span class="line">    ordered <span class="keyword">bool</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="labels"><a href="#labels" class="headerlink" title="labels"></a>labels</h4><p><a href="https://link.jianshu.com?t=https%3A%2F%2Fgodoc.org%2Fgithub.com%2Fprometheus%2Ftsdb%2Flabels" target="_blank" rel="noopener">labels</a> 是标签, 对应 influxdb 中的 tags, 即一组键值对.</p>
<p>在 promethues/tsdb 中, timestamp 和 value 之外的所有信息都放在 labels 中</p>
<p>这个 pkg 的核心就是 Label, Labels, 以及 Labels 的 Matcher</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Label is a key/value pair of strings.</span></span><br><span class="line"><span class="keyword">type</span> Label <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name, Value <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Labels is a sorted set of labels. Order has to be guaranteed upon</span></span><br><span class="line"><span class="comment">// instantiation.</span></span><br><span class="line"><span class="keyword">type</span> Labels []Label</span><br></pre></td></tr></table></figure>

<p>在实际使用中, Labels 都应该是应该排序的. 因此 Labels 首先实现了 <code>sort.Interface</code>.</p>
<p>同时, Labels 之间也是可以进行比较的</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Compare compares the two label sets.</span></span><br><span class="line"><span class="comment">// The result will be 0 if a==b, &lt;0 if a &lt; b, and &gt;0 if a &gt; b.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Compare</span><span class="params">(a, b Labels)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    l := <span class="built_in">len</span>(a)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(b) &lt; l &#123;</span><br><span class="line">        l = <span class="built_in">len</span>(b)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 逐个 label 比较 name, value 的字母序</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; l; i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> d := strings.Compare(a[i].Name, b[i].Name); d != <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> d</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> d := strings.Compare(a[i].Value, b[i].Value); d != <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> d</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// If all labels so far were in common, the set with fewer labels comes first.</span></span><br><span class="line">    <span class="comment">// 可比较的部分无法确定顺序, 则比较两者长度</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(a) - <span class="built_in">len</span>(b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Slice"><a href="#Slice" class="headerlink" title="Slice"></a>Slice</h5><p><code>Slice</code> 是 <code>Labels</code> 的切片</p>
<p>因为 <code>Labels</code> 可比较, 因此 <code>Slice</code> 也实现了 <code>sort.Interface</code></p>
<h5 id="Matcher"><a href="#Matcher" class="headerlink" title="Matcher"></a>Matcher</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Matcher specifies a constraint for the value of a label.</span></span><br><span class="line"><span class="keyword">type</span> Matcher <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="comment">// Name returns the label name the matcher should apply to.</span></span><br><span class="line">    Name() <span class="keyword">string</span></span><br><span class="line">    <span class="comment">// Matches checks whether a value fulfills the constraints.</span></span><br><span class="line">    Matches(v <span class="keyword">string</span>) <span class="keyword">bool</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Matcher</code> 用来筛选 Labels</p>
<p>这里提供了 equal, prefix, regexp, not 四种基本的 <code>Matcher</code></p>
<h5 id="sampleRing"><a href="#sampleRing" class="headerlink" title="sampleRing"></a>sampleRing</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> sample <span class="keyword">struct</span> &#123;</span><br><span class="line">    t <span class="keyword">int64</span></span><br><span class="line">    v <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 既然是 Ring, 那么 buf 就是环装的, 因此有辅助的 i, f, l</span></span><br><span class="line"><span class="keyword">type</span> sampleRing <span class="keyword">struct</span> &#123;</span><br><span class="line">    delta <span class="keyword">int64</span></span><br><span class="line"></span><br><span class="line">    buf []sample <span class="comment">// lookback buffer</span></span><br><span class="line">    i   <span class="keyword">int</span>      <span class="comment">// position of most recent element in ring buffer</span></span><br><span class="line">    f   <span class="keyword">int</span>      <span class="comment">// position of first element in ring buffer</span></span><br><span class="line">    l   <span class="keyword">int</span>      <span class="comment">// number of elements in buffer</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>sampleRing 用来处理数据点的采样</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// add adds a sample to the ring buffer and frees all samples that fall</span></span><br><span class="line"><span class="comment">// out of the delta range.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *sampleRing)</span> <span class="title">add</span><span class="params">(t <span class="keyword">int64</span>, v <span class="keyword">float64</span>)</span></span> &#123;</span><br><span class="line">    l := <span class="built_in">len</span>(r.buf)</span><br><span class="line">    <span class="comment">// Grow the ring buffer if it fits no more elements.</span></span><br><span class="line">    <span class="keyword">if</span> l == r.l &#123;</span><br><span class="line">        <span class="comment">// ring buffer 的扩容</span></span><br><span class="line">        buf := <span class="built_in">make</span>([]sample, <span class="number">2</span>*l)</span><br><span class="line">        <span class="built_in">copy</span>(buf[l+r.f:], r.buf[r.f:])</span><br><span class="line">        <span class="built_in">copy</span>(buf, r.buf[:r.f])</span><br><span class="line"></span><br><span class="line">        r.buf = buf</span><br><span class="line">        r.i = r.f</span><br><span class="line">        r.f += l</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        r.i++</span><br><span class="line">        <span class="keyword">if</span> r.i &gt;= l &#123;</span><br><span class="line">            r.i -= l</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    r.buf[r.i] = sample&#123;t: t, v: v&#125;</span><br><span class="line">    r.l++</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Free head of the buffer of samples that just fell out of the range.</span></span><br><span class="line">    <span class="comment">// 这里认为 add 是有序的, 将头部所有早于 `t - r.delta` 的数据点移出有效区域</span></span><br><span class="line">    <span class="keyword">for</span> r.buf[r.f].t &lt; t-r.delta &#123;</span><br><span class="line">        r.f++</span><br><span class="line">        <span class="keyword">if</span> r.f &gt;= l &#123;</span><br><span class="line">            r.f -= l</span><br><span class="line">        &#125;</span><br><span class="line">        r.l--</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="sampleRingIterator"><a href="#sampleRingIterator" class="headerlink" title="sampleRingIterator"></a>sampleRingIterator</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> sampleRingIterator <span class="keyword">struct</span> &#123;</span><br><span class="line">    r *sampleRing</span><br><span class="line">    i <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>sampleRingIterator 是 <a href="https://link.jianshu.com?t=https%3A%2F%2Fgithub.com%2Fprometheus%2Ftsdb%2Fblob%2Fd45b595a1daefad23c09a2d994bf956f8b5f15a9%2Fquerier.go%23L668-L680" target="_blank" rel="noopener">SeriesIterator</a> 的实现</p>
<h5 id="BufferedSeriesIterator"><a href="#BufferedSeriesIterator" class="headerlink" title="BufferedSeriesIterator"></a>BufferedSeriesIterator</h5><p>BufferedSeriesIterator 同样也实现了 <a href="https://link.jianshu.com?t=https%3A%2F%2Fgithub.com%2Fprometheus%2Ftsdb%2Fblob%2Fd45b595a1daefad23c09a2d994bf956f8b5f15a9%2Fquerier.go%23L668-L680" target="_blank" rel="noopener">SeriesIterator</a>, 它将一段部分数据点通过 sampleRing 缓存下来, 具体效果, 待阅读其他代码.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// BufferedSeriesIterator wraps an iterator with a look-back buffer.</span></span><br><span class="line"><span class="keyword">type</span> BufferedSeriesIterator <span class="keyword">struct</span> &#123;</span><br><span class="line">    it  tsdb.SeriesIterator</span><br><span class="line">    buf *sampleRing</span><br><span class="line"></span><br><span class="line">    lastTime <span class="keyword">int64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewBuffer returns a new iterator that buffers the values within the time range</span></span><br><span class="line"><span class="comment">// of the current element and the duration of delta before.</span></span><br><span class="line"><span class="comment">// BufferedSeriesIterator 的作用是对上层 Iter 进行封装</span></span><br><span class="line"><span class="comment">// 将其中最多 delta 时间范围内的数据点通过 sampleRing 缓存下来</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewBuffer</span><span class="params">(it tsdb.SeriesIterator, delta <span class="keyword">int64</span>)</span> *<span class="title">BufferedSeriesIterator</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;BufferedSeriesIterator&#123;</span><br><span class="line">        it:       it,</span><br><span class="line">        buf:      newSampleRing(delta, <span class="number">16</span>),</span><br><span class="line">        lastTime: math.MinInt64,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Seek</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Seek advances the iterator to the element at time t or greater.</span></span><br><span class="line"><span class="comment">// 这里的 `指针` 只会向后移动, 不会向前</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *BufferedSeriesIterator)</span> <span class="title">Seek</span><span class="params">(t <span class="keyword">int64</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    t0 := t - b.buf.delta</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If the delta would cause us to seek backwards, preserve the buffer</span></span><br><span class="line">    <span class="comment">// and just continue regular advancement while filling the buffer on the way.</span></span><br><span class="line">    <span class="comment">// 此时 sampleRing 中的点都会失效, 因此直接重置</span></span><br><span class="line">    <span class="keyword">if</span> t0 &gt; b.lastTime &#123;</span><br><span class="line">        b.buf.reset()</span><br><span class="line"></span><br><span class="line">        ok := b.it.Seek(t0)</span><br><span class="line">        <span class="keyword">if</span> !ok &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        b.lastTime, _ = b.At()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> b.lastTime &gt;= t &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> b.Next() &#123;</span><br><span class="line">        <span class="keyword">if</span> b.lastTime &gt;= t &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="tombstones-go"><a href="#tombstones-go" class="headerlink" title="tombstones.go"></a>tombstones.go</h4><p>Stone:</p>
<p>Stone 是作为删除数据的标记</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Stone holds the information on the posting and time-range</span></span><br><span class="line"><span class="comment">// that is deleted.</span></span><br><span class="line"><span class="keyword">type</span> Stone <span class="keyword">struct</span> &#123;</span><br><span class="line">    ref       <span class="keyword">uint64</span></span><br><span class="line">    intervals Intervals</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Interval-Intervals"><a href="#Interval-Intervals" class="headerlink" title="Interval, Intervals"></a>Interval, Intervals</h5><p>用来记录时间段</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Interval represents a single time-interval.</span></span><br><span class="line"><span class="keyword">type</span> Interval <span class="keyword">struct</span> &#123;</span><br><span class="line">    Mint, Maxt <span class="keyword">int64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tr Interval)</span> <span class="title">inBounds</span><span class="params">(t <span class="keyword">int64</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> t &gt;= tr.Mint &amp;&amp; t &lt;= tr.Maxt</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tr Interval)</span> <span class="title">isSubrange</span><span class="params">(dranges Intervals)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> _, r := <span class="keyword">range</span> dranges &#123;</span><br><span class="line">        <span class="keyword">if</span> r.inBounds(tr.Mint) &amp;&amp; r.inBounds(tr.Maxt) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="TombstoneReader"><a href="#TombstoneReader" class="headerlink" title="TombstoneReader"></a>TombstoneReader</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TombstoneReader gives access to tombstone intervals by series reference.</span></span><br><span class="line"><span class="keyword">type</span> TombstoneReader <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="comment">// Get returns deletion intervals for the series with the given reference.</span></span><br><span class="line">    Get(ref <span class="keyword">uint64</span>) (Intervals, error)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Iter calls the given function for each encountered interval.</span></span><br><span class="line">    Iter(<span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">uint64</span>, Intervals)</span> <span class="title">error</span>) <span class="title">error</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Close any underlying resources</span></span><br><span class="line">    Close() error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>提供了一个内存版的实现</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> memTombstones <span class="keyword">map</span>[<span class="keyword">uint64</span>]Intervals</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> emptyTombstoneReader = memTombstones&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// EmptyTombstoneReader returns a TombstoneReader that is always empty.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">EmptyTombstoneReader</span><span class="params">()</span> <span class="title">TombstoneReader</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> emptyTombstoneReader</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t memTombstones)</span> <span class="title">Get</span><span class="params">(ref <span class="keyword">uint64</span>)</span> <span class="params">(Intervals, error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> t[ref], <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t memTombstones)</span> <span class="title">Iter</span><span class="params">(f <span class="keyword">func</span>(<span class="keyword">uint64</span>, Intervals)</span> <span class="title">error</span>) <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> ref, ivs := <span class="keyword">range</span> t &#123;</span><br><span class="line">        <span class="keyword">if</span> err := f(ref, ivs); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> err</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t memTombstones)</span> <span class="title">add</span><span class="params">(ref <span class="keyword">uint64</span>, itv Interval)</span></span> &#123;</span><br><span class="line">    t[ref] = t[ref].add(itv)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(memTombstones)</span> <span class="title">Close</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>TombstoneReader 的内容可以被写入文件, 也可以通过文件读出.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">writeTombstoneFile</span><span class="params">(dir <span class="keyword">string</span>, tr TombstoneReader)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    path := filepath.Join(dir, tombstoneFilename)</span><br><span class="line">    tmp := path + <span class="string">".tmp"</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> renameFile(tmp, path)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">readTombstones</span><span class="params">(dir <span class="keyword">string</span>)</span> <span class="params">(memTombstones, error)</span></span> &#123;</span><br><span class="line">    b, err := ioutil.ReadFile(filepath.Join(dir, tombstoneFilename))</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    stonesMap := memTombstones&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> d.<span class="built_in">len</span>() &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        stonesMap.add(k, Interval&#123;mint, maxt&#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> stonesMap, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="wal-go"><a href="#wal-go" class="headerlink" title="wal.go"></a>wal.go</h4><p>prometheus/tsdb 会将几类数据先写入 wal (write ahead log) 文件</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// WALEntryType indicates what data a WAL entry contains.</span></span><br><span class="line"><span class="keyword">type</span> WALEntryType <span class="keyword">uint8</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Entry types in a segment file.</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    WALEntrySymbols WALEntryType = <span class="number">1</span></span><br><span class="line">    WALEntrySeries  WALEntryType = <span class="number">2</span></span><br><span class="line">    WALEntrySamples WALEntryType = <span class="number">3</span></span><br><span class="line">    WALEntryDeletes WALEntryType = <span class="number">4</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// WAL is a write ahead log that can log new series labels and samples.</span></span><br><span class="line"><span class="comment">// It must be completely read before new entries are logged.</span></span><br><span class="line"><span class="keyword">type</span> WAL <span class="keyword">interface</span> &#123;</span><br><span class="line">    Reader() WALReader</span><br><span class="line">    LogSeries([]RefSeries) error</span><br><span class="line">    LogSamples([]RefSample) error</span><br><span class="line">    LogDeletes([]Stone) error</span><br><span class="line">    Truncate(mint <span class="keyword">int64</span>, keep <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">uint64</span>)</span> <span class="title">bool</span>) <span class="title">error</span></span></span><br><span class="line">    Close() error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// WALReader reads entries from a WAL.</span></span><br><span class="line"><span class="keyword">type</span> WALReader <span class="keyword">interface</span> &#123;</span><br><span class="line">    Read(</span><br><span class="line">        seriesf <span class="function"><span class="keyword">func</span><span class="params">([]RefSeries)</span>,</span></span><br><span class="line">        samplesf <span class="function"><span class="keyword">func</span><span class="params">([]RefSample)</span>,</span></span><br><span class="line">        deletesf <span class="function"><span class="keyword">func</span><span class="params">([]Stone)</span>,</span></span><br><span class="line">    ) error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与之相关的数据结构定义如下</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RefSeries is the series labels with the series ID.</span></span><br><span class="line"><span class="keyword">type</span> RefSeries <span class="keyword">struct</span> &#123;</span><br><span class="line">    Ref    <span class="keyword">uint64</span></span><br><span class="line">    Labels labels.Labels</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// RefSample is a timestamp/value pair associated with a reference to a series.</span></span><br><span class="line"><span class="keyword">type</span> RefSample <span class="keyword">struct</span> &#123;</span><br><span class="line">    Ref <span class="keyword">uint64</span></span><br><span class="line">    T   <span class="keyword">int64</span></span><br><span class="line">    V   <span class="keyword">float64</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 基于内存的 series 数据, 在后续的阅读中再仔细分析</span></span><br><span class="line">    series *memSeries</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="SegmentWAL"><a href="#SegmentWAL" class="headerlink" title="SegmentWAL"></a>SegmentWAL</h5><p>这是 WAL 的一个实现, 会将数据切成 256MB 一片进行存储, 切片的组织方式与 chunks 类似.</p>
<p>相应的, 操作文件的相关实现代码也很相似.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// segmentFile wraps a file object of a segment and tracks the highest timestamp</span></span><br><span class="line"><span class="comment">// it contains. During WAL truncating, all segments with no higher timestamp than</span></span><br><span class="line"><span class="comment">// the truncation threshold can be compacted.</span></span><br><span class="line"><span class="keyword">type</span> segmentFile <span class="keyword">struct</span> &#123;</span><br><span class="line">    *os.File</span><br><span class="line">    maxTime   <span class="keyword">int64</span>  <span class="comment">// highest tombstone or sample timpstamp in segment</span></span><br><span class="line">    minSeries <span class="keyword">uint64</span> <span class="comment">// lowerst series ID in segment</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SegmentWAL is a write ahead log for series data.</span></span><br><span class="line"><span class="keyword">type</span> SegmentWAL <span class="keyword">struct</span> &#123;</span><br><span class="line">    mtx     sync.Mutex</span><br><span class="line">    metrics *walMetrics</span><br><span class="line"></span><br><span class="line">    dirFile *os.File</span><br><span class="line">    files   []*segmentFile</span><br><span class="line"></span><br><span class="line">    logger        log.Logger</span><br><span class="line">    flushInterval time.Duration</span><br><span class="line">    segmentSize   <span class="keyword">int64</span></span><br><span class="line"></span><br><span class="line">    crc32 hash.Hash32</span><br><span class="line">    cur   *bufio.Writer</span><br><span class="line">    curN  <span class="keyword">int64</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 信号</span></span><br><span class="line">    stopc   <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">    donec   <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 后台执行的操作</span></span><br><span class="line">    actorc  <span class="keyword">chan</span> <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">error</span> // <span class="title">sequentialized</span> <span class="title">background</span> <span class="title">operations</span></span></span><br><span class="line">    </span><br><span class="line">    buffers sync.Pool</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="LogXXXX"><a href="#LogXXXX" class="headerlink" title="LogXXXX"></a>LogXXXX</h6><p>LogSeries, LogSamples, LogDeletes 对各自的操作数据分别编码写入 WAL.</p>
<h6 id="Truncate"><a href="#Truncate" class="headerlink" title="Truncate"></a>Truncate</h6><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Truncate deletes the values prior to mint and the series which the keep function</span></span><br><span class="line"><span class="comment">// does not indiciate to preserve.</span></span><br><span class="line"><span class="comment">// 用于清除不再需要的数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *SegmentWAL)</span> <span class="title">Truncate</span><span class="params">(mint <span class="keyword">int64</span>, keep <span class="keyword">func</span>(<span class="keyword">uint64</span>)</span> <span class="title">bool</span>) <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="run"><a href="#run" class="headerlink" title="run"></a>run</h6><p>通过 <code>OpenSegmentWAL</code> 打开一个 SegmentWAL 的时候, 会在一个独立的 goroutine 中运行 run 函数, 用来处理 <code>actorc</code> 传递的后台操作.</p>
<p>目前 <code>actorc</code> 传递的操作仅有文件的分片</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// cut finishes the currently active segments and opens the next one.</span></span><br><span class="line"><span class="comment">// The encoder is reset to point to the new segment.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *SegmentWAL)</span> <span class="title">cut</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="comment">// Sync current head to disk and close.</span></span><br><span class="line">    <span class="keyword">if</span> hf := w.head(); hf != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> err := w.flush(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> err</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Finish last segment asynchronously to not block the WAL moving along</span></span><br><span class="line">        <span class="comment">// in the new segment.</span></span><br><span class="line">        <span class="comment">// 结束当前的切片文件</span></span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            w.actorc &lt;- <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">                off, err := hf.Seek(<span class="number">0</span>, os.SEEK_CUR)</span><br><span class="line">                <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> errors.Wrapf(err, <span class="string">"finish old segment %s"</span>, hf.Name())</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> err := hf.Truncate(off); err != <span class="literal">nil</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> errors.Wrapf(err, <span class="string">"finish old segment %s"</span>, hf.Name())</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> err := hf.Sync(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> errors.Wrapf(err, <span class="string">"finish old segment %s"</span>, hf.Name())</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> err := hf.Close(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> errors.Wrapf(err, <span class="string">"finish old segment %s"</span>, hf.Name())</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化新的切片文件供写入</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="Compact-go"><a href="#Compact-go" class="headerlink" title="Compact.go"></a>Compact.go</h4><p>对底层存储的压缩相关的实现</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Compactor provides compaction against an underlying storage</span></span><br><span class="line"><span class="comment">// of time series data.</span></span><br><span class="line"><span class="keyword">type</span> Compactor <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="comment">// Plan returns a set of non-overlapping directories that can</span></span><br><span class="line">    <span class="comment">// be compacted concurrently.</span></span><br><span class="line">    <span class="comment">// Results returned when compactions are in progress are undefined.</span></span><br><span class="line">    Plan(dir <span class="keyword">string</span>) ([]<span class="keyword">string</span>, error)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Write persists a Block into a directory.</span></span><br><span class="line">    Write(dest <span class="keyword">string</span>, b BlockReader, mint, maxt <span class="keyword">int64</span>) (ulid.ULID, error)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Compact runs compaction against the provided directories. Must</span></span><br><span class="line">    <span class="comment">// only be called concurrently with results of Plan().</span></span><br><span class="line">    Compact(dest <span class="keyword">string</span>, dirs ...<span class="keyword">string</span>) (ulid.ULID, error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="LeveledCompactor"><a href="#LeveledCompactor" class="headerlink" title="LeveledCompactor"></a>LeveledCompactor</h5><p>是 Compactor 的实现</p>
<h6 id="Plan"><a href="#Plan" class="headerlink" title="Plan"></a>Plan</h6><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Plan returns a list of compactable blocks in the provided directory.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *LeveledCompactor)</span> <span class="title">Plan</span><span class="params">(dir <span class="keyword">string</span>)</span> <span class="params">([]<span class="keyword">string</span>, error)</span></span> &#123;</span><br><span class="line">    dirs, err := blockDirs(dir)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">var</span> dms []dirMeta</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _, dir := <span class="keyword">range</span> dirs &#123;</span><br><span class="line">        <span class="comment">// 读取 BlockMeta 作为判断是否可以 compact 的依据</span></span><br><span class="line">        meta, err := readMetaFile(dir)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c.plan(dms)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="populateBlock"><a href="#populateBlock" class="headerlink" title="populateBlock"></a>populateBlock</h6><p><code>LeveledCompactor.Write</code> 和 <code>LeveledCompactor.Compact</code> 两个方法中都用到 <code>LeveledCompactor.write</code>, 而 <code>LeveledCompactor.populateBlock</code> 是 write 方法的重要逻辑.</p>
<p>其作用是将一组 Block 的数据合并, 再写入 IndexWriter, ChunkWriter.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// populateBlock fills the index and chunk writers with new data gathered as the union</span></span><br><span class="line"><span class="comment">// of the provided blocks. It returns meta information for the new block.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *LeveledCompactor)</span> <span class="title">populateBlock</span><span class="params">(blocks []BlockReader, meta *BlockMeta, indexw IndexWriter, chunkw ChunkWriter)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> (</span><br><span class="line">        set        ChunkSeriesSet</span><br><span class="line">        allSymbols = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">struct</span>&#123;&#125;, <span class="number">1</span>&lt;&lt;<span class="number">16</span>)</span><br><span class="line">        closers    = []io.Closer&#123;&#125;</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; closeAll(closers...) &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历旧 block 数据</span></span><br><span class="line">    <span class="keyword">for</span> i, b := <span class="keyword">range</span> blocks &#123;</span><br><span class="line">        indexr, err := b.Index()</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">        chunkr, err := b.Chunks()</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">        tombsr, err := b.Tombstones()</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">        symbols, err := indexr.Symbols()</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">        all, err := indexr.Postings(index.AllPostingsKey())</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> err</span><br><span class="line">        &#125;</span><br><span class="line">        all = indexr.SortedPostings(all)</span><br><span class="line"></span><br><span class="line">        s := newCompactionSeriesSet(indexr, chunkr, tombsr, all)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">      </span><br><span class="line">        <span class="comment">// 与上一层并形成一个新的 merger</span></span><br><span class="line">        set, err = newCompactionMerger(set, s)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> err</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We fully rebuild the postings list index from merged series.</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历 merger</span></span><br><span class="line">    <span class="keyword">for</span> set.Next() &#123;</span><br><span class="line">        lset, chks, dranges := set.At() <span class="comment">// The chunks here are not fully deleted.</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Skip the series with all deleted chunks.</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> err := chunkw.WriteChunks(chks...); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> errors.Wrap(err, <span class="string">"write chunks"</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> err := indexw.AddSeries(i, lset, chks...); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> errors.Wrap(err, <span class="string">"add series"</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    s := <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="number">0</span>, <span class="number">256</span>)</span><br><span class="line">    <span class="keyword">for</span> n, v := <span class="keyword">range</span> values &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> err := indexw.WriteLabelIndex([]<span class="keyword">string</span>&#123;n&#125;, s); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> errors.Wrap(err, <span class="string">"write label index"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _, l := <span class="keyword">range</span> postings.SortedKeys() &#123;</span><br><span class="line">        <span class="keyword">if</span> err := indexw.WritePostings(l.Name, l.Value, postings.Get(l.Name, l.Value)); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> errors.Wrap(err, <span class="string">"write postings"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="block-go"><a href="#block-go" class="headerlink" title="block.go"></a>block.go</h4><h5 id="Block"><a href="#Block" class="headerlink" title="Block"></a>Block</h5><h6 id="Delete"><a href="#Delete" class="headerlink" title="Delete"></a>Delete</h6><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Delete matching series between mint and maxt in the block.</span></span><br><span class="line"><span class="comment">// 前面说到, Delete 的时候会暂时先标记为 Tombstone, 这里即实现部分</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pb *Block)</span> <span class="title">Delete</span><span class="params">(mint, maxt <span class="keyword">int64</span>, ms ...labels.Matcher)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    err = pb.tombstones.Iter(<span class="function"><span class="keyword">func</span><span class="params">(id <span class="keyword">uint64</span>, ivs Intervals)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> _, iv := <span class="keyword">range</span> ivs &#123;</span><br><span class="line">            stones.add(id, iv)</span><br><span class="line">            pb.meta.Stats.NumTombstones++</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    pb.tombstones = stones</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> err := writeTombstoneFile(pb.dir, pb.tombstones); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> writeMetaFile(pb.dir, &amp;pb.meta)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>CleanTombstones</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CleanTombstones will rewrite the block if there any tombstones to remove them</span></span><br><span class="line"><span class="comment">// and returns if there was a re-write.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pb *Block)</span> <span class="title">CleanTombstones</span><span class="params">(dest <span class="keyword">string</span>, c Compactor)</span> <span class="params">(<span class="keyword">bool</span>, error)</span></span> &#123;</span><br><span class="line">    numStones := <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    pb.tombstones.Iter(<span class="function"><span class="keyword">func</span><span class="params">(id <span class="keyword">uint64</span>, ivs Intervals)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> _ = <span class="keyword">range</span> ivs &#123;</span><br><span class="line">            numStones++</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> numStones == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>, <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> _, err := c.Write(dest, pb, pb.meta.MinTime, pb.meta.MaxTime); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>, err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="Snapshot"><a href="#Snapshot" class="headerlink" title="Snapshot"></a>Snapshot</h6><p>疑问, 这里仅对目标文件夹及其内部文件做了 hardlink, 怎么确保内容不变?</p>
<h4 id="head-go"><a href="#head-go" class="headerlink" title="head.go"></a>head.go</h4><h5 id="Head"><a href="#Head" class="headerlink" title="Head"></a>Head</h5><p>Head 向调用方提供, 用于某个时间段内的数据读写.</p>
<p>Head 会同时处理 WAL 内的和已经持久化的数据.</p>
<p>Head 可以认为是<code>current Block</code></p>
<p>所有 Block 不可再写入, Head 在写入有效期过后会转化为 Block 进行持久化.</p>
<h6 id="Appender"><a href="#Appender" class="headerlink" title="Appender"></a>Appender</h6><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Appender returns a new Appender on the database.</span></span><br><span class="line"><span class="comment">// 会根据具体情形决定返回的 Appender 实例</span></span><br><span class="line"><span class="comment">// Appender 实例共两类</span></span><br><span class="line"><span class="comment">// initAppender 会在接收到第一个数据点时初始化 Head 的起始时间</span></span><br><span class="line"><span class="comment">// headAppender 逻辑相对简单</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *Head)</span> <span class="title">Appender</span><span class="params">()</span> <span class="title">Appender</span></span> &#123;</span><br><span class="line">    h.metrics.activeAppenders.Inc()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The head cache might not have a starting point yet. The init appender</span></span><br><span class="line">    <span class="comment">// picks up the first appended timestamp as the base.</span></span><br><span class="line">    <span class="keyword">if</span> h.MinTime() == math.MinInt64 &#123;</span><br><span class="line">        <span class="keyword">return</span> &amp;initAppender&#123;head: h&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> h.appender()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *Head)</span> <span class="title">appender</span><span class="params">()</span> *<span class="title">headAppender</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;headAppender&#123;</span><br><span class="line">        head:          h,</span><br><span class="line">        mint:          h.MaxTime() - h.chunkRange/<span class="number">2</span>,</span><br><span class="line">        samples:       h.getAppendBuffer(),</span><br><span class="line">        highTimestamp: math.MinInt64,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="querier-go"><a href="#querier-go" class="headerlink" title="querier.go"></a>querier.go</h4><p>围绕以下三个接口, 向调用方提供查询能力.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Querier provides querying access over time series data of a fixed</span></span><br><span class="line"><span class="comment">// time range.</span></span><br><span class="line"><span class="keyword">type</span> Querier <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="comment">// Select returns a set of series that matches the given label matchers.</span></span><br><span class="line">    Select(...labels.Matcher) (SeriesSet, error)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// LabelValues returns all potential values for a label name.</span></span><br><span class="line">    LabelValues(<span class="keyword">string</span>) ([]<span class="keyword">string</span>, error)</span><br><span class="line">    <span class="comment">// LabelValuesFor returns all potential values for a label name.</span></span><br><span class="line">    <span class="comment">// under the constraint of another label.</span></span><br><span class="line">    LabelValuesFor(<span class="keyword">string</span>, labels.Label) ([]<span class="keyword">string</span>, error)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Close releases the resources of the Querier.</span></span><br><span class="line">    Close() error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Series exposes a single time series.</span></span><br><span class="line"><span class="keyword">type</span> Series <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="comment">// Labels returns the complete set of labels identifying the series.</span></span><br><span class="line">    Labels() labels.Labels</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Iterator returns a new iterator of the data of the series.</span></span><br><span class="line">    Iterator() SeriesIterator</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SeriesSet contains a set of series.</span></span><br><span class="line"><span class="keyword">type</span> SeriesSet <span class="keyword">interface</span> &#123;</span><br><span class="line">    Next() <span class="keyword">bool</span></span><br><span class="line">    At() Series</span><br><span class="line">    Err() error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="querier-blockQuerier"><a href="#querier-blockQuerier" class="headerlink" title="querier, blockQuerier"></a>querier, blockQuerier</h5><p>blockQuerier 是针对一个 block 的 Querier</p>
<p>querier 是 blockQuerier 的聚合</p>
<h4 id="db-go"><a href="#db-go" class="headerlink" title="db.go"></a>db.go</h4><h5 id="Appender-1"><a href="#Appender-1" class="headerlink" title="Appender"></a>Appender</h5><p>Appender 是写入接口, *Head 就实现了 Appender</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Appender allows appending a batch of data. It must be completed with a</span></span><br><span class="line"><span class="comment">// call to Commit or Rollback and must not be reused afterwards.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Operations on the Appender interface are not goroutine-safe.</span></span><br><span class="line"><span class="keyword">type</span> Appender <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="comment">// Add adds a sample pair for the given series. A reference number is</span></span><br><span class="line">    <span class="comment">// returned which can be used to add further samples in the same or later</span></span><br><span class="line">    <span class="comment">// transactions.</span></span><br><span class="line">    <span class="comment">// Returned reference numbers are ephemeral and may be rejected in calls</span></span><br><span class="line">    <span class="comment">// to AddFast() at any point. Adding the sample via Add() returns a new</span></span><br><span class="line">    <span class="comment">// reference number.</span></span><br><span class="line">    <span class="comment">// If the reference is the empty string it must not be used for caching.</span></span><br><span class="line">    Add(l labels.Labels, t <span class="keyword">int64</span>, v <span class="keyword">float64</span>) (<span class="keyword">uint64</span>, error)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Add adds a sample pair for the referenced series. It is generally faster</span></span><br><span class="line">    <span class="comment">// than adding a sample by providing its full label set.</span></span><br><span class="line">    AddFast(ref <span class="keyword">uint64</span>, t <span class="keyword">int64</span>, v <span class="keyword">float64</span>) error</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Commit submits the collected samples and purges the batch.</span></span><br><span class="line">    Commit() error</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Rollback rolls back all modifications made in the appender so far.</span></span><br><span class="line">    Rollback() error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="DB"><a href="#DB" class="headerlink" title="DB"></a>DB</h5><p>DB 是向调用者提供的最主要的结构体.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DB handles reads and writes of time series falling into</span></span><br><span class="line"><span class="comment">// a hashed partition of a seriedb.</span></span><br><span class="line"><span class="keyword">type</span> DB <span class="keyword">struct</span> &#123;</span><br><span class="line">    dir   <span class="keyword">string</span></span><br><span class="line">    lockf *lockfile.Lockfile</span><br><span class="line"></span><br><span class="line">    logger    log.Logger</span><br><span class="line">    metrics   *dbMetrics</span><br><span class="line">    opts      *Options</span><br><span class="line">    chunkPool chunkenc.Pool</span><br><span class="line">    compactor Compactor</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Mutex for that must be held when modifying the general block layout.</span></span><br><span class="line">    mtx    sync.RWMutex</span><br><span class="line">    blocks []*Block</span><br><span class="line"></span><br><span class="line">    head *Head</span><br><span class="line"></span><br><span class="line">    compactc <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">    donec    <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">    stopc    <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// cmtx is used to control compactions and deletions.</span></span><br><span class="line">    cmtx               sync.Mutex</span><br><span class="line">    compactionsEnabled <span class="keyword">bool</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>reload</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// reload on-disk blocks and trigger head truncation if new blocks appeared. It takes</span></span><br><span class="line"><span class="comment">// a list of block directories which should be deleted during reload.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *DB)</span> <span class="title">reload</span><span class="params">(deleteable ...<span class="keyword">string</span>)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 读取当前所有的 block 目录</span></span><br><span class="line">    dirs, err := blockDirs(db.dir)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> (</span><br><span class="line">        blocks []*Block</span><br><span class="line">        exist  = <span class="keyword">map</span>[ulid.ULID]<span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _, dir := <span class="keyword">range</span> dirs &#123;</span><br><span class="line">        meta, err := readMetaFile(dir)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 尝试获取目录对应的 Block, 先从内存, 再从硬盘</span></span><br><span class="line">        b, ok := db.getBlock(meta.ULID)</span><br><span class="line">        <span class="keyword">if</span> !ok &#123;</span><br><span class="line">            b, err = OpenBlock(dir, db.chunkPool)</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        blocks = <span class="built_in">append</span>(blocks, b)</span><br><span class="line">        exist[meta.ULID] = <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 按照 Block 覆盖的时间重新排序</span></span><br><span class="line">    <span class="keyword">if</span> err := validateBlockSequence(blocks); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> errors.Wrap(err, <span class="string">"invalid block sequence"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 清除不必要的 Block 文件</span></span><br><span class="line">    <span class="keyword">for</span> _, b := <span class="keyword">range</span> oldBlocks &#123;</span><br><span class="line">        <span class="keyword">if</span> _, ok := exist[b.Meta().ULID]; ok &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> err := b.Close(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            level.Warn(db.logger).Log(<span class="string">"msg"</span>, <span class="string">"closing block failed"</span>, <span class="string">"err"</span>, err)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> err := os.RemoveAll(b.Dir()); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            level.Warn(db.logger).Log(<span class="string">"msg"</span>, <span class="string">"deleting block failed"</span>, <span class="string">"err"</span>, err)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Garbage collect data in the head if the most recent persisted block</span></span><br><span class="line">    <span class="comment">// covers data of its current time range.</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(blocks) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    maxt := blocks[<span class="built_in">len</span>(blocks)<span class="number">-1</span>].Meta().MaxTime</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> errors.Wrap(db.head.Truncate(maxt), <span class="string">"head truncate failed"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="run-1"><a href="#run-1" class="headerlink" title="run"></a>run</h6><p>run 方法在 Open 时被调用, 在一个单独的 goroutine 中执行, 主要是定期对数据进行压缩以节省空间</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *DB)</span> <span class="title">run</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="built_in">close</span>(db.donec)</span><br><span class="line"></span><br><span class="line">    backoff := time.Duration(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> &lt;-db.stopc:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">case</span> &lt;-time.After(backoff):</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> &lt;-time.After(<span class="number">1</span> * time.Minute):</span><br><span class="line">            <span class="keyword">select</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> db.compactc &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;:</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">case</span> &lt;-db.compactc:</span><br><span class="line">            <span class="comment">// 执行压缩相关代码</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> &lt;-db.stopc:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="Appender-2"><a href="#Appender-2" class="headerlink" title="Appender"></a>Appender</h6><p>返回的是封装的结果 dbAppender, 后面专门再分析</p>
<h6 id="Qurier"><a href="#Qurier" class="headerlink" title="Qurier"></a>Qurier</h6><p>返回的是所有指定时间范围内的 Block 聚合</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Querier returns a new querier over the data partition for the given time range.</span></span><br><span class="line"><span class="comment">// A goroutine must not handle more than one open Querier.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *DB)</span> <span class="title">Querier</span><span class="params">(mint, maxt <span class="keyword">int64</span>)</span> <span class="params">(Querier, error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> blocks []BlockReader</span><br><span class="line"></span><br><span class="line">    db.mtx.RLock()</span><br><span class="line">    <span class="keyword">defer</span> db.mtx.RUnlock()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _, b := <span class="keyword">range</span> db.blocks &#123;</span><br><span class="line">        m := b.Meta()</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 找出符合时间段的 block</span></span><br><span class="line">        <span class="keyword">if</span> intervalOverlap(mint, maxt, m.MinTime, m.MaxTime) &#123;</span><br><span class="line">            blocks = <span class="built_in">append</span>(blocks, b)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 前面提到, Head 可以视作当前 Block</span></span><br><span class="line">    <span class="keyword">if</span> maxt &gt;= db.head.MinTime() &#123;</span><br><span class="line">        blocks = <span class="built_in">append</span>(blocks, db.head)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Block 的聚合</span></span><br><span class="line">    sq := &amp;querier&#123;</span><br><span class="line">        blocks: <span class="built_in">make</span>([]Querier, <span class="number">0</span>, <span class="built_in">len</span>(blocks)),</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> _, b := <span class="keyword">range</span> blocks &#123;</span><br><span class="line">        q, err := NewBlockQuerier(b, mint, maxt)</span><br><span class="line">        <span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">            sq.blocks = <span class="built_in">append</span>(sq.blocks, q)</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// If we fail, all previously opened queriers must be closed.</span></span><br><span class="line">        <span class="keyword">for</span> _, q := <span class="keyword">range</span> sq.blocks &#123;</span><br><span class="line">            q.Close()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, errors.Wrapf(err, <span class="string">"open querier for block %s"</span>, b)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sq, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="Delete-1"><a href="#Delete-1" class="headerlink" title="Delete"></a>Delete</h6><p>这边实际会将 Delete 操作分给各个受影响的 Block</p>
<h6 id="CleanTombstone"><a href="#CleanTombstone" class="headerlink" title="CleanTombstone"></a>CleanTombstone</h6><p>前面提到, 各个 Block Delete 内的逻辑实际是写 WAL 以及 Tombstone 文件</p>
<p>这里会对当前所有 Block 真正进行清理, 然后调用 <code>reload</code> 方法.</p>
<h5 id="dbAppender"><a href="#dbAppender" class="headerlink" title="dbAppender"></a>dbAppender</h5><p>是对 *headAppender 的封装, 在 Commit 的时候触发 compact</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Appender opens a new appender against the database.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *DB)</span> <span class="title">Appender</span><span class="params">()</span> <span class="title">Appender</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> dbAppender&#123;db: db, Appender: db.head.Appender()&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// dbAppender wraps the DB's head appender and triggers compactions on commit</span></span><br><span class="line"><span class="comment">// if necessary.</span></span><br><span class="line"><span class="keyword">type</span> dbAppender <span class="keyword">struct</span> &#123;</span><br><span class="line">    Appender</span><br><span class="line">    db *DB</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a dbAppender)</span> <span class="title">Commit</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    err := a.Appender.Commit()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We could just run this check every few minutes practically. But for benchmarks</span></span><br><span class="line">    <span class="comment">// and high frequency use cases this is the safer way.</span></span><br><span class="line">    <span class="keyword">if</span> a.db.head.MaxTime()-a.db.head.MinTime() &gt; a.db.head.chunkRange/<span class="number">2</span>*<span class="number">3</span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> a.db.compactc &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;:</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h4><p><code>prometheus/tsdb</code>  (下称 ptsdb ) 的结构体之间的层次大概可以这样划分:</p>
<ul>
<li><p>DB: 对外提供的核心对象</p>
<ul>
<li>Block 已经持久化的, 覆盖某个时间段的时序数据. Block 的 <ul>
<li>Index: 用于保存 labels 的索引数据</li>
<li>Chunk: 用于保存时间戳-采样值 数据</li>
</ul>
</li>
</ul>
</li>
<li><p>Head: 由于 ptsdb 规定, 数据必须增序写入, 已经持久化的 Block 不能再写入, 因此一个时刻只会有一个可供写入的 Block, 即 Head. Head 同时还承担记录删除动作的任务 </p>
<ul>
<li>WAL 增删改的动作都会先进入 WAL, 供后续恢复用</li>
<li>Tombstone: 用于标记删除动作, 被标记的数据在 compact 的时候统一清理</li>
</ul>
</li>
<li><p>Compactor: 对文件进行压缩. Block 数据的组织参考了 LSM, 因此 Compactor 的实现也和基于 LSM 的 kv db 类似.</p>
</li>
</ul>
<p>关于 ptsdb, <a href="https://link.jianshu.com?t=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F32900004" target="_blank" rel="noopener">时间序列数据的存储和计算 - 开源时序数据库解析（四）</a> 这篇文章有更宏观的阐述, 可以参考.</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://zhuanlan.zhihu.com/p/60212547" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/60212547</a></p>

      </div>
      
      
        <br>
        


  <section class='meta' id="footer-meta">
    <div class='new-meta-box'>
      
        
          <div class="new-meta-item date" itemprop="dateUpdated" datetime="2020-10-10T02:09:39+00:00">
  <a class='notlink'>
    <i class="fas fa-clock" aria-hidden="true"></i>
    <p>更新于 2020年10月10日</p>
  </a>
</div>

        
      
        
          
  
  <div class="new-meta-item meta-tags"><a class="tag" href="/tags/tsdb/" rel="nofollow"><i class="fas fa-tag" aria-hidden="true"></i><p>tsdb</p></a></div>


        
      
        
          

        
      
    </div>
  </section>


      
      
          <div class="prev-next">
              
                  <section class="prev">
                      <span class="art-item-left">
                          <h6><i class="fas fa-chevron-left" aria-hidden="true"></i>&nbsp;上一页</h6>
                          <h4>
                              <a href="/2020/11/17/rabbitmq%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/" rel="prev" title="rabbitmq源码学习一">
                                
                                    rabbitmq源码学习一
                                
                              </a>
                          </h4>
                          
                              
                              <h6 class="tags">
                                  <a class="tag" href="/tags/rabbitmq/"><i class="fas fa-tag fa-fw" aria-hidden="true"></i> rabbitmq</a>
                              </h6>
                          
                      </span>
                  </section>
              
              
                  <section class="next">
                      <span class="art-item-right" aria-hidden="true">
                          <h6>下一页&nbsp;<i class="fas fa-chevron-right" aria-hidden="true"></i></h6>
                          <h4>
                              <a href="/2020/09/29/%E5%88%86%E5%B8%83%E5%BC%8F%E9%99%90%E6%B5%81%E7%AE%97%E6%B3%95/" rel="prev" title="分布式限流算法">
                                  
                                      分布式限流算法
                                  
                              </a>
                          </h4>
                          
                              
                              <h6 class="tags">
                                  <a class="tag" href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"><i class="fas fa-tag fa-fw" aria-hidden="true"></i> 分布式</a>
                              </h6>
                          
                      </span>
                  </section>
              
          </div>
      
    </section>
  </article>



  <!-- 显示推荐文章和评论 -->



  






<!-- 根据页面mathjax变量决定是否加载MathJax数学公式js -->



  <script>
    window.subData = {
      title: 'tsdb源码学习',
      tools: true
    }
  </script>


</div>
<aside class='l_side'>
  
    
    
      
      
        
          
          
            
              <section class='widget author'>
  <div class='content material'>
    
      <div class='avatar'>
        <img class='avatar' src='/images/avatar.jpg'/>
      </div>
    
    
      <div class='text'>
        
        
        
          <p><span id="jinrishici-sentence">Saar's Blog</span></p>
          <script src="https://sdk.jinrishici.com/v2/browser/jinrishici.js" charset="utf-8"></script>
        
      </div>
    
    
      <div class="social-wrapper">
        
          
            <a href="/atom.xml"
              class="social fas fa-rss flat-btn"
              target="_blank"
              rel="external nofollow noopener noreferrer">
            </a>
          
        
          
            <a href="https://github.com/fu4ck"
              class="social fab fa-github flat-btn"
              target="_blank"
              rel="external nofollow noopener noreferrer">
            </a>
          
        
      </div>
    
  </div>
</section>

            
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
      
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
      
        
          
          
        
          
          
            
              
  <section class='widget toc-wrapper'>
    
<header class='material'>
  <div><i class="fas fa-list fa-fw" aria-hidden="true"></i>&nbsp;&nbsp;本文目录</div>
  
    <!-- <div class='wrapper'><a class="s-toc rightBtn" rel="external nofollow noopener noreferrer" href="javascript:void(0)"><i class="fas fa-thumbtack fa-fw"></i></a></div> -->
  
</header>

    <div class='content material'>
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#tsdb源码学习"><span class="toc-text">tsdb源码学习</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#bstream"><span class="toc-text">bstream</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Chunk接口"><span class="toc-text">Chunk接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#XORChunk实现"><span class="toc-text">XORChunk实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#xorAppender"><span class="toc-text">xorAppender</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Pool"><span class="toc-text">Pool</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Meta元数据"><span class="toc-text">Meta元数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ChunkWriter"><span class="toc-text">ChunkWriter</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ChunkReader"><span class="toc-text">ChunkReader</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#index"><span class="toc-text">index</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#encbuf-decbuf"><span class="toc-text">encbuf, decbuf</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#indexWriterSeries"><span class="toc-text">indexWriterSeries</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#indexTOC"><span class="toc-text">indexTOC</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Writer"><span class="toc-text">Writer</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Reader"><span class="toc-text">Reader</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Postings"><span class="toc-text">Postings</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#MemPostings"><span class="toc-text">MemPostings</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#labels"><span class="toc-text">labels</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Slice"><span class="toc-text">Slice</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Matcher"><span class="toc-text">Matcher</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#sampleRing"><span class="toc-text">sampleRing</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#sampleRingIterator"><span class="toc-text">sampleRingIterator</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#BufferedSeriesIterator"><span class="toc-text">BufferedSeriesIterator</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#tombstones-go"><span class="toc-text">tombstones.go</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Interval-Intervals"><span class="toc-text">Interval, Intervals</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#TombstoneReader"><span class="toc-text">TombstoneReader</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#wal-go"><span class="toc-text">wal.go</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#SegmentWAL"><span class="toc-text">SegmentWAL</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#LogXXXX"><span class="toc-text">LogXXXX</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#Truncate"><span class="toc-text">Truncate</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#run"><span class="toc-text">run</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Compact-go"><span class="toc-text">Compact.go</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#LeveledCompactor"><span class="toc-text">LeveledCompactor</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#Plan"><span class="toc-text">Plan</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#populateBlock"><span class="toc-text">populateBlock</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#block-go"><span class="toc-text">block.go</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Block"><span class="toc-text">Block</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#Delete"><span class="toc-text">Delete</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#Snapshot"><span class="toc-text">Snapshot</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#head-go"><span class="toc-text">head.go</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Head"><span class="toc-text">Head</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#Appender"><span class="toc-text">Appender</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#querier-go"><span class="toc-text">querier.go</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#querier-blockQuerier"><span class="toc-text">querier, blockQuerier</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#db-go"><span class="toc-text">db.go</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Appender-1"><span class="toc-text">Appender</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#DB"><span class="toc-text">DB</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#run-1"><span class="toc-text">run</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#Appender-2"><span class="toc-text">Appender</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#Qurier"><span class="toc-text">Qurier</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#Delete-1"><span class="toc-text">Delete</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#CleanTombstone"><span class="toc-text">CleanTombstone</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#dbAppender"><span class="toc-text">dbAppender</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Summary"><span class="toc-text">Summary</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#参考资料"><span class="toc-text">参考资料</span></a></li></ol></li></ol>
    </div>
  </section>


            
          
        
          
          
        
          
          
        
          
          
        
          
          
        
      
        
          
          
        
          
          
        
          
          
            
              <section class='widget grid'>
  
<header class='material'>
  <div><i class="fas fa-map-signs fa-fw" aria-hidden="true"></i>&nbsp;&nbsp;站内导航</div>
  
</header>

  <div class='content material'>
    <ul class="grid navgation">
      
        <li><a class="flat-box" title="/" href="/"
          
          
          id="home">
          
            <i class="fas fa-clock fa-fw" aria-hidden="true"></i>
          
          近期文章
        </a></li>
      
        <li><a class="flat-box" title="/categories/" href="/categories/"
          
            rel="nofollow"
          
          
          id="categories">
          
            <i class="fas fa-archive fa-fw" aria-hidden="true"></i>
          
          文章归档
        </a></li>
      
    </ul>
  </div>
</section>

            
          
        
          
          
        
          
          
        
          
          
        
      
        
          
          
        
          
          
        
          
          
        
          
          
            
              
  <section class='widget category'>
    
<header class='material'>
  <div><i class="fas fa-folder-open fa-fw" aria-hidden="true"></i>&nbsp;&nbsp;文章分类</div>
  
    <a class="rightBtn"
    
      rel="nofollow"
    
    
    href="/categories/"
    title="/categories/">
    <i class="fas fa-expand-arrows-alt fa-fw"></i></a>
  
</header>

    <div class='content material'>
      <ul class="entry">
        
          <li><a class="flat-box" title="/categories/ElasticSearch/" href="/categories/ElasticSearch/"><div class='name'>ElasticSearch</div><div class='badge'>(2)</div></a></li>
        
          <li><a class="flat-box" title="/categories/ctf/" href="/categories/ctf/"><div class='name'>ctf</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box" title="/categories/docker/" href="/categories/docker/"><div class='name'>docker</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box" title="/categories/golang/" href="/categories/golang/"><div class='name'>golang</div><div class='badge'>(2)</div></a></li>
        
          <li><a class="flat-box" title="/categories/influxdb/" href="/categories/influxdb/"><div class='name'>influxdb</div><div class='badge'>(2)</div></a></li>
        
          <li><a class="flat-box" title="/categories/k8s/" href="/categories/k8s/"><div class='name'>k8s</div><div class='badge'>(3)</div></a></li>
        
          <li><a class="flat-box" title="/categories/malloc/" href="/categories/malloc/"><div class='name'>malloc</div><div class='badge'>(2)</div></a></li>
        
          <li><a class="flat-box" title="/categories/monitor/" href="/categories/monitor/"><div class='name'>monitor</div><div class='badge'>(10)</div></a></li>
        
          <li><a class="flat-box" title="/categories/mysql/" href="/categories/mysql/"><div class='name'>mysql</div><div class='badge'>(2)</div></a></li>
        
          <li><a class="flat-box" title="/categories/prometheus/" href="/categories/prometheus/"><div class='name'>prometheus</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box" title="/categories/pwn/" href="/categories/pwn/"><div class='name'>pwn</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box" title="/categories/rabbitmq/" href="/categories/rabbitmq/"><div class='name'>rabbitmq</div><div class='badge'>(2)</div></a></li>
        
          <li><a class="flat-box" title="/categories/redis/" href="/categories/redis/"><div class='name'>redis</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box" title="/categories/tsdb/" href="/categories/tsdb/"><div class='name'>tsdb</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box" title="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/" href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"><div class='name'>分布式</div><div class='badge'>(2)</div></a></li>
        
          <li><a class="flat-box" title="/categories/%E5%BF%83%E7%81%B5%E9%B8%A1%E6%B1%A4/" href="/categories/%E5%BF%83%E7%81%B5%E9%B8%A1%E6%B1%A4/"><div class='name'>心灵鸡汤</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box" title="/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/" href="/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"><div class='name'>深度学习</div><div class='badge'>(2)</div></a></li>
        
      </ul>
    </div>
  </section>


            
          
        
          
          
        
          
          
        
      
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
            
              
  <section class='widget tagcloud'>
    
<header class='material'>
  <div><i class="fas fa-tags fa-fw" aria-hidden="true"></i>&nbsp;&nbsp;热门标签</div>
  
    <a class="rightBtn"
    
      rel="nofollow"
    
    
    href="/tags/"
    title="/tags/">
    <i class="fas fa-expand-arrows-alt fa-fw"></i></a>
  
</header>

    <div class='content material'>
      <a href="/tags/ElasticSearch/" style="font-size: 17.33px; color: #828282">ElasticSearch</a> <a href="/tags/ctf/" style="font-size: 14px; color: #999">ctf</a> <a href="/tags/galera/" style="font-size: 14px; color: #999">galera</a> <a href="/tags/golang/" style="font-size: 17.33px; color: #828282">golang</a> <a href="/tags/influxdb/" style="font-size: 17.33px; color: #828282">influxdb</a> <a href="/tags/k8s/" style="font-size: 20.67px; color: #6c6c6c">k8s</a> <a href="/tags/malloc/" style="font-size: 17.33px; color: #828282">malloc</a> <a href="/tags/monitor/" style="font-size: 24px; color: #555">monitor</a> <a href="/tags/mysql/" style="font-size: 14px; color: #999">mysql</a> <a href="/tags/pwn/" style="font-size: 14px; color: #999">pwn</a> <a href="/tags/rabbitmq/" style="font-size: 17.33px; color: #828282">rabbitmq</a> <a href="/tags/redis/" style="font-size: 14px; color: #999">redis</a> <a href="/tags/runc/" style="font-size: 14px; color: #999">runc</a> <a href="/tags/tsdb/" style="font-size: 14px; color: #999">tsdb</a> <a href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F/" style="font-size: 17.33px; color: #828282">分布式</a> <a href="/tags/%E5%BF%83%E7%81%B5%E9%B8%A1%E6%B1%A4/" style="font-size: 14px; color: #999">心灵鸡汤</a> <a href="/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/" style="font-size: 17.33px; color: #828282">深度学习</a>
    </div>
  </section>


            
          
        
          
          
        
      
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
      
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
      
    

  
</aside>

<footer id="footer" class="clearfix">
  
  
    <div class="social-wrapper">
      
        
          <a href="/atom.xml"
            class="social fas fa-rss flat-btn"
            target="_blank"
            rel="external nofollow noopener noreferrer">
          </a>
        
      
        
          <a href="https://github.com/fu4ck"
            class="social fab fa-github flat-btn"
            target="_blank"
            rel="external nofollow noopener noreferrer">
          </a>
        
      
    </div>
  
  <br>
  <div><p>博客内容遵循 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="noopener">署名-非商业性使用-相同方式共享 4.0 国际 (CC BY-NC-SA 4.0) 协议</a></p>
</div>
  <div>
    本站使用
    <a href="https://xaoxuu.com/wiki/material-x/" target="_blank" class="codename">Material X</a>
    作为主题
    
      ，
      总访问量为
      <span id="busuanzi_value_site_pv"><i class="fas fa-spinner fa-spin fa-fw" aria-hidden="true"></i></span>
      次
    
    。
  </div>
</footer>
<script>setLoadingBarProgress(80);</script>


      <script>setLoadingBarProgress(60);</script>
    </div>
    <a class="s-top fas fa-arrow-up fa-fw" href='javascript:void(0)'></a>
  </div>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script>

  <script>
    var GOOGLE_CUSTOM_SEARCH_API_KEY = "";
    var GOOGLE_CUSTOM_SEARCH_ENGINE_ID = "";
    var ALGOLIA_API_KEY = "";
    var ALGOLIA_APP_ID = "";
    var ALGOLIA_INDEX_NAME = "";
    var AZURE_SERVICE_NAME = "";
    var AZURE_INDEX_NAME = "";
    var AZURE_QUERY_KEY = "";
    var BAIDU_API_ID = "";
    var SEARCH_SERVICE = "hexo" || "hexo";
    var ROOT = "/"||"/";
    if(!ROOT.endsWith('/'))ROOT += '/';
  </script>

<script src="//instant.page/1.2.2" type="module" integrity="sha384-2xV8M5griQmzyiY3CDqh1dn4z3llDVqZDqzjzcY+jCBCk/a5fXJmuZ/40JJAPeoU"></script>


  <script async src="https://cdn.jsdelivr.net/npm/scrollreveal@4.0.5/dist/scrollreveal.min.js"></script>
  <script type="text/javascript">
    $(function() {
      const $reveal = $('.reveal');
      if ($reveal.length === 0) return;
      const sr = ScrollReveal({ distance: 0 });
      sr.reveal('.reveal');
    });
  </script>


  <script src="https://cdn.jsdelivr.net/npm/node-waves@0.7.6/dist/waves.min.js"></script>
  <script type="text/javascript">
    $(function() {
      Waves.attach('.flat-btn', ['waves-button']);
      Waves.attach('.float-btn', ['waves-button', 'waves-float']);
      Waves.attach('.float-btn-light', ['waves-button', 'waves-float', 'waves-light']);
      Waves.attach('.flat-box', ['waves-block']);
      Waves.attach('.float-box', ['waves-block', 'waves-float']);
      Waves.attach('.waves-image');
      Waves.init();
    });
  </script>


  <script async src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-busuanzi@2.3/js/busuanzi.pure.mini.js"></script>




  
  
  
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery-backstretch/2.0.4/jquery.backstretch.min.js"></script>
    <script type="text/javascript">
      $(function(){
        if ('') {
          $('').backstretch(
          ["https://img.xjh.me/desktop/bg/nature/65253358_p0.jpg", "http://img.xjh.me/desktop/bg/nature/56245464_p0.jpg", "http://img.xjh.me/desktop/bg/nature/63606459_p0.jpg", "http://img.xjh.me/desktop/bg/nature/63190697_p0.jpg", "http://img.xjh.me/desktop/bg/nature/59322814_p0.jpg"],
          {
            duration: "6000",
            fade: "2500"
          });
        } else {
          $.backstretch(
          ["https://img.xjh.me/desktop/bg/nature/65253358_p0.jpg", "http://img.xjh.me/desktop/bg/nature/56245464_p0.jpg", "http://img.xjh.me/desktop/bg/nature/63606459_p0.jpg", "http://img.xjh.me/desktop/bg/nature/63190697_p0.jpg", "http://img.xjh.me/desktop/bg/nature/59322814_p0.jpg"],
          {
            duration: "6000",
            fade: "2500"
          });
        }
      });
    </script>
  











  
<script src="/js/app.js"></script>



  
<script src="/js/search.js"></script>





<!-- 复制 -->
<script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script>
<script>
  let COPY_SUCCESS = "复制成功";
  let COPY_FAILURE = "复制失败";
  /*页面载入完成后，创建复制按钮*/
  !function (e, t, a) {
    /* code */
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '  <i class="fa fa-copy"></i><span>复制</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });

      clipboard.on('success', function(e) {
        //您可以加入成功提示
        console.info('Action:', e.action);
        console.info('Text:', e.text);
        console.info('Trigger:', e.trigger);
        success_prompt(COPY_SUCCESS);
        e.clearSelection();
      });
      clipboard.on('error', function(e) {
        //您可以加入失败提示
        console.error('Action:', e.action);
        console.error('Trigger:', e.trigger);
        fail_prompt(COPY_FAILURE);
      });
    }
    initCopyCode();

  }(window, document);

  /**
   * 弹出式提示框，默认1.5秒自动消失
   * @param message 提示信息
   * @param style 提示样式，有alert-success、alert-danger、alert-warning、alert-info
   * @param time 消失时间
   */
  var prompt = function (message, style, time)
  {
      style = (style === undefined) ? 'alert-success' : style;
      time = (time === undefined) ? 1500 : time*1000;
      $('<div>')
          .appendTo('body')
          .addClass('alert ' + style)
          .html(message)
          .show()
          .delay(time)
          .fadeOut();
  };

  // 成功提示
  var success_prompt = function(message, time)
  {
      prompt(message, 'alert-success', time);
  };

  // 失败提示
  var fail_prompt = function(message, time)
  {
      prompt(message, 'alert-danger', time);
  };

  // 提醒
  var warning_prompt = function(message, time)
  {
      prompt(message, 'alert-warning', time);
  };

  // 信息提示
  var info_prompt = function(message, time)
  {
      prompt(message, 'alert-info', time);
  };

</script>


<!-- fancybox -->
<script src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script>
<script>
  let LAZY_LOAD_IMAGE = "";
  $(".article-entry").find("fancybox").find("img").each(function () {
      var element = document.createElement("a");
      $(element).attr("data-fancybox", "gallery");
      $(element).attr("href", $(this).attr("src"));
      /* 图片采用懒加载处理时,
       * 一般图片标签内会有个属性名来存放图片的真实地址，比如 data-original,
       * 那么此处将原本的属性名src替换为对应属性名data-original,
       * 修改如下
       */
       if (LAZY_LOAD_IMAGE) {
         $(element).attr("href", $(this).attr("data-original"));
       }
      $(this).wrap(element);
  });
</script>





  <script>setLoadingBarProgress(100);</script>
</body>
</html>
